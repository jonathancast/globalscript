\documentclass{article}
\title{Global Script Byte-Code File Format}
\author{Jonathan Cast\\\texttt{<jonathanccast@fastmail.fm>}}

\begin{document}

\maketitle

\section{Overview}

\begin{itemize}
  \item Header
  \item Code Segment
  \item Data Segment
  \item Strings
\end{itemize}
NB: 2011-02-22: Ordering of sections differs between spec and loader; will need to fix loader.  End NB

\section{Header}

\begin{tabular}{cl}
  & Optional \verb+#!+ line (max 80 bytes (not chars)). \\
  & Following offsets are relative to end of this line, if present.  \\
\texttt{0x00} & Magic Number \verb+/!gs(pre|doc)bc/+ (8 bytes) \\
\texttt{0x08} & File Format Version Number (4 bytes; Era.Major.Minor.Step) \\
\texttt{0x0C} & Size of Headers (exclusive of \verb+#!+ line) (4 bytes) \\
\texttt{0x10} & Size of Code (4 bytes) \\
\texttt{0x14} & Size of Data (4 bytes) \\
\texttt{0x10} & Size of Strings (4 bytes) \\
\end{tabular}

(Total size of header (inclusive of \verb+#!+ line) will be between 0x1C and 0x6C bytes).

\section {Byte Codes}

\begin{tabular}{rl@{ --- }l}
  00 & \texttt{ALLOC} & Append to data segment \\
  01 & \texttt{ANALYZE} & Push an \texttt{analyze} frame \\
  02 & \texttt{APP} & Push an argument frame \\
  03 & \texttt{BYCONST} & Save a \texttt{byte} constant \\
  04 & \texttt{CALL} & Call a known function \\
  05 & \texttt{CCALL} & Call a manifest closure \\
  06 & \texttt{CHCONST} & Save a \texttt{char} constant \\
  07 & \texttt{EVAL} & Enter a thunk \\
  08 & \texttt{EEXEC} & Call a subprogram expression \\
  09 & \texttt{EPRIM} & Call an API primitive \\
  0A & \texttt{EXEC} & Call a manifest subprogram \\
  0B & \texttt{FORCE} & Push an eager-binding continuation \\
  0C & \texttt{JEEXEC} & Tail-call a subprogram expression \\
  0D & \texttt{JEXEC} & Tail-call a manifest subprogram \\
  0E & \texttt{JEPRIM} & Tail-call an API primitive \\
  0F & \texttt{PRIM} & Apply a primitive \\
  10 & \texttt{RETURN} & Return from a manifest block \\
  11 & \texttt{TYALLOC} & Manufacture a type at runtime \\
  12 & \texttt{UPDATE} & Push an update frame \\
  13 & \texttt{YIELD} & Yield a constant \\
\end{tabular}

The final operation in a block must not take an address; the initial declaration must take an address.
\texttt{APP} and \texttt{ANALYZE} may not take an address.
Otherwise, addresses are always optional.
Addresses must be unique across the entire source file;
only addresses of blocks annotated \texttt{.public} must be unique across all files.

Byte code layout:

\begin{tabular}{|l|l|}
\hline
  7 $\cdots$ 2 & 1 0 \\
\hline
  opcode & $\log_2$ word size \\
  00--3F & 0 : 8-bit \\
  & 1 : 16-bit \\
  & 2 : 32-bit \\
  & 3 : 64-bit \\
\hline
\end{tabular}

Here's how numeric values in a block with $n$ free variables, $m$ arguments, and $p$ generators
(statements that \emph{might} take labels) work:
numeric value $0$ refers to the environment pointer;
numeric values in the range $i \in [1, n - 1)$ refer to the $i$th free variable;
numeric values in the range $i \in [n + 1, n + m + 1)$ refer to the $(i - n)$th argument; and
numeric values in the range $i \in [n + m + 1, n + m + p + 1)$ refer to the result of the $(i - n - m)$th generator.
Forward references (references to later generators) are in general legal.

\paragraph{\texttt{ALLOC}} is followed by a count of the number of arguments (including code lable),
then the code label,
then any free variables for the code label.

\paragraph{\texttt{JEPRIM}/\texttt{EPRIM}} are followed by count of arguments (including primitive),
then any arguments to the primitive.

\section{Blocks}

\paragraph{Block-Beginning declarations}\

\begin{tabular}{rl@{ --- }l}
  0 & \texttt{.constr} & Declares a constructor \\
  1 & \texttt{.cont} & Declares an eager-binding continuation \\
  2 & \texttt{.cases} & Declares a case analysis continuation \\
  3 & \texttt{.case} & Declares a specific branch of a case analysis continuation \\
  4 & \texttt{.expr} & Declares a redex \\
  5 & \texttt{.proge} & Declares a block expression \\
  6 & \texttt{.prog} & Declare a manifest subprogram \\
  C & \texttt{.lambda} & Declare a manifest function \\
  D & \texttt{.lproge} & Delcares a block expression-bodied lambda \\
  E & \texttt{.lprog} & Declare a manifest sub-routine \\
\end{tabular}

\paragraph{Other declarations}\

\begin{tabular}{l@{ --- }l}
  \texttt{.arg} & Declare a formal parameter \\
  \texttt{.free} & Declare a free variable \\
  \texttt{.global} & Declare a free variable whose value is statically known \\
  \texttt{.tyarg} & Declares a type parameter \\
  \texttt{.tyfree} & Declares a free type variable \\
\end{tabular}

\paragraph{Block structure}

The first byte is the declaration code, with the same format as a byte code.
Word length only applies to the initial byte code.
This is followed by
\begin{itemize}
\item a count of the number of free variables whose values are statically known,
\item a count of the number of free variables,
\item for \texttt{.lambda}, \texttt{.lproge}, and \texttt{.lprog} blocks a count of the number of arguments, and
\item for \texttt{.proge}, \texttt{.prog}, \texttt{.lproge}, and \texttt{.lprog} blocks the symbol naming the block's API type.
\end{itemize}
This is followed by the symbols naming the values of any free variables whose values are statically known.
Then follows by the byte codes for the expression.
Each byte code is unambiguously initial or final, so the end of the block is self-declaring.

\section{Symbols}

\begin{tabular}{rl}
  \texttt{00} & Type \\
  & 0 : un-resolved external code reference \\
  & 1 : un-resolved external data reference \\
  & 2 : argument (debugging) \\
  & 3 : free variable (debugging) \\
  & 4 : public code symbol \\
  & 5 : private code symbol \\
  & 6 : public data symbol \\
  & 7 : private data symbol \\
  & 8 : un-used symbol \\
  & 9 : API type \\
  \texttt{01} & Hash \\
  & For now, this is just the sum $(\bmod 0x100)$ of the bytes of the string \\
  \texttt{02} & Address/Offset (4 bytes) \\
  \texttt{06} & Length (1 byte) \\
  \texttt{07} & Name of symbol (not NUL-terminated) \\
\end{tabular}

%% TODO
%%
%% * Convert to Global Script

\end{document}
