\documentclass{report}
\title{Global Script String Code Specification}
\author{Jonathan Cast\\\texttt{<jcast@globalscript.org>}}

\usepackage{cite}
\usepackage{bussproofs}
\usepackage{haskell}

\usepackage[utf8]{inputenc}

\usepackage{amssymb}

\newcommand\sequent\vdash
\newcommand\bs{$\backslash$}

\newcommand\ccode[1]{\texttt{#1}}
\newcommand\stringcode[1]{\texttt{#1}}
\newcommand\shellcode[1]{\texttt{#1}}

\newcommand\unimpl[1]{\footnote{\textbf{Unimplemented: }#1}}
\newcommand\agsonly[1]{\footnote{\textbf{\texttt{.ags}-only: }#1}}

\newcommand\old[2]{\footnote{Prior to version #1, #2}}
\newcommand\new[2]{\footnote{\textbf{New in version #1}; previously, #2}}
\newcommand\future[1]{\footnote{\textbf{Future direction:} #1}}

\newcommand\abstype{\hskwd{abstype}}
\newcommand\primtype{\hskwd{primtype}}

\begin{document}

\maketitle

\tableofcontents

\chapter{Organization of a Program}

Global Script programs are organized into a \emph{prefix},
contained in some number of \emph{prefix files},
 and a \emph{document}, contained in a single \emph{document file}.
Essentially, prefix files contain library code, whereas document files contain code specific to a single program.
At the source level, each prefix file consists of a single \emph{prefix generator};
a document file consists of an expression
--- the program's entry point or `\ccode{main}' ---
and an optional $\hskwd{where}$ clause.
For various reasons, string code syntax flattens both prefix and document files out into a sequence of \emph{items}.

\chapter{Layout of a String Code File}

Every string code file must begin with the syntax, followed by  blank line:
\begin{verbatim}
#calculus: gsdl.string-code 0.6
\end{verbatim}
Older versions are also supported: versions 0.2 through 0.5.
This document specifieds version 0.6, but it has notes on the changes from earlier versions.

Next after this is the declaration
\begin{verbatim}
	.document
\end{verbatim}
or
\begin{verbatim}
	.prefix
\end{verbatim}
declaring whether this particular file is a prefix or document file.

\section{Sections}

String code files are divided into \emph{sections}:
the data section, begun by the line
\begin{verbatim}
	.data
\end{verbatim}
containing declarations of the file's data items;
the code section, begun by the line
\begin{verbatim}
	.code
\end{verbatim}
containing auxiliary \emph{code items} which are part of the definition of the data items;
the type section, begun by the line
\begin{verbatim}
	.type
\end{verbatim}
containing declarations of the file's type items;
and the coercion section, begun by the line
\begin{verbatim}
	.coercion
\end{verbatim}
containing declarations of the file's coercion items.

Sections should normally be included in the above order;
it is illegal to include multiple sections with the same name.

\section{Lexical Syntax}

\begin{itemize}
    \item Each line consists of a sequence of fields separated by whitespace.

    \item Lines may optionally be terminated by the field value \stringcode{--}, which begins a comment.

    \item String literals and rune literals are un-quoted and may contain the standard C escapes as well as
        \stringcode{\bs{}s}, which represents an ASCII space.
        \agsonly{String literals are only supported for simplifying hand-written string code, for bootstrapping.}
        \future{We will add a syntax for writing arbitrary UTF coding units using ASCII characters.}

    \item If a line begins with whitespace, field 0 of that line is the empty string;
        any run of linear whitespace is equivalent to a single space and whitespace at the end of the line is ignored,
        so empty fields are not possible except for field 0.

    \item Lines consisting exclusively of whitespace and/or comments are ignored.

    \item In general, field 0 of any line will be referred to as the \emph{label};
        field 1 will be variously referred to as the \emph{directive} or the \emph{op}.
        Labels of width 0 will be referred to as \emph{missing};
        labels may be required or forbidden, depending on the op.
        Any non-blank non-comment line must contain a field 1;
        additional fields may be required or permitted depending on the directive or op;
        they will be referred to as the \emph{arguments}.
\end{itemize}

\chapter{Data Items}

Any data item has the form
\begin{verbatim}
label	directive	args
\end{verbatim}
\stringcode{label} is the name of the object variable being defined;
\stringcode{directive} declares the form of the declaration.
The syntax of \stringcode{args} will depend on \stringcode{directive}.

The first data item in a document's data section is the \emph{entry point};
the value of this data item is the value of the document.
The label is optional on this data item, and only this data item.

\section{\stringcode{.closure}}

\begin{verbatim}
label	.closure	<code label> <type label>?
\end{verbatim}

This is the general form for top-level data declarations,
used for functions, block statements, and thunks.

\stringcode{<code label>} is the label of an \stringcode{.expr} or \stringcode{.impprog} item in the code section,
containing the variable \stringcode{label}'s definition.

\section{\stringcode{.record}}

\begin{verbatim}
label	.record	(field	value)*
\end{verbatim}

This defines a simple object-member-only structure literal;
the value of each field is given by the object variable following the field name.

\section{\stringcode{.constr}}

\begin{verbatim}
label	.constr	type	constr	(field	value)*
\end{verbatim}
or
\begin{verbatim}
label	.constr	type	constr	arg
\end{verbatim}

This defines a literal of a sum type;
\stringcode{type} is the exact sum type the constructor should include into,
and \stringcode{constr} is the constructor name to use.

Summands in Core or String Code sum types can have one of two forms:
\begin{itemize}
    \item A regular boxed type, of any form.

        In this case, the second form will be used for \stringcode{.constr}, with a simple variable for the tagged value.

    \item An un-boxed product.

        In this case, the first form will be used for \stringcode{.constr}.
        The field name / value pairs are the same data used for a record literal, which will then be taken to be the tagged value.
\end{itemize}

\section{\stringcode{.rune}}

\begin{verbatim}
label	.rune	r
\end{verbatim}

This bind \stringcode{label} to a simple (un-boxed, un-lifted, un-cast) rune literal.
This will have type \<"definedprim rune.prim rune\>.

\section{\stringcode{.string}}

\agsonly{String literals are only supported in hand-written .ags files; the string compiler never generates them.}

\begin{verbatim}
label	.string	string
\end{verbatim}

This binds \stringcode{label} to a \emph{lifted, boxed} string literal of type \<list.t rune.t\>.
The byte-compiler will expand this definition to a chain of \<:\> constructors terminated by a \<nil\> constructor,
with literal un-boxed runes for the elements.

\section{\stringcode{.list}}

\agsonly{List literals are only supported in hand-written .ags files; the string compiler never generates them.}

\begin{verbatim}
label	.list	type	elem*
\end{verbatim}

This binds \stringcode{label} to a \emph{lifted, boxed, cast} list literal of type \<list.t type\>.
The byte-compiler will expand this definition to a chain of \<:\> constructors terminated by a \<nil\> constructor.

Alternative form:\unimpl{This isn't supported yet, and may never be, as it hasn't proven necessary yet.}

\begin{verbatim}
label	.list	type	elem*	|	tail
\end{verbatim}

This binds \stringcode{label} to a `dotted list', where \<tail\> is used in place of the final \<nil\> constructor.

\section{\stringcode{.regex}}

\agsonly{Regex literals are only supported in hand-written .ags files; the string compiler never generates them.}

\begin{verbatim}
label	.regex	re	arg*
\end{verbatim}

This binds \stringcode{label} to a \emph{lifted, boxed, cast} regex literal of type \<regex.t rune.t\>.
The byte-compiler will expand this definition to a tree of constructor literals;
the character \stringcode{ยง} can be used to insert another data item, taken from the \stringcode{arg} list, into the generated tree.

\section{\stringcode{.undefined}}

\begin{verbatim}
label	.undefined	type
\end{verbatim}

This binds \stringcode{label} to the least element of the lifted, boxed type \stringcode{type}.
This is used to translate undefined variables at the core or source level.

\section{\stringcode{.cast}}

\begin{verbatim}
label	.undefined	x	co
\end{verbatim}

This binds \stringcode{label} to the same value as \stringcode{x} (a data item),
but with a new type obtained by coercing it through \stringcode{co} (a coercion item).
This is useful for casting data items created by \stringcode{.constr} or \stringcode{.record} generators into abstract types,
although it will be used more generally.

\chapter{Code Items}

Code items are substantially more complicated than data items.

\section{\stringcode{.expr}}

\begin{verbatim}
label	.expr
ops
\end{verbatim}

This defines a code item which represents a discrete expression, or a lambda term whose body is an expression.

The contents of a \stringcode{.expr} code item will be:
\begin{itemize}
    \item A list of the items (global variables) this expression depends on, comprised of:
        \begin{itemize}
            \item A sequence of global type variable declarations (section \ref{code_type_gvar});
            \item A sequence of sub-code declarations (section \ref{subcode});
            \item A sequence of global coercion variable declarations (section \ref{coercion_gvar}); and
            \item A sequence of global object variable declarations (section \ref{value_gvar}).
        \end{itemize}
    \item A list of the (non-global) free variables of this expression, comprised of:
        \begin{itemize}
            \item A sequence of free type variable declarations (section \ref{type_fv});
            \item A sequence of type lets using the free type variables decared above (section \ref{code_type_let});
            \item A sequence of free object variable declarations (section \ref{value_fv}), using the type variables declared above;
        \end{itemize}
    \item A sequence, intermixed in the appropriate order, of:
        \begin{itemize}
            \item Type argument declarations (section \ref{code_type_arg});
            \item Type lets using the type arguments declared above (and other type variables in scope at this point) (section \ref{code_type_let}); and
            \item Object argument declarations, using the type variables declared above (section \ref{value_arg}).
        \end{itemize}
    \item A list of local declarations within this expression,
        intermixed in the appropriate order,\future{We plan to support recursion at this point, at which point the only restriction will be that forward references will have to be to variables with type signatures.}
        consisting of
        \begin{itemize}
            \item Thunk allocations (section \ref{thunk_alloc}); and
            \item Value allocations (section \ref{value_alloc}).
        \end{itemize}
    \item A list of evaluation contexts, in the appropriate order (section \ref{cont_push}).
        And, finally,
    \item A terminal operator (section \ref{terminal_op}).
\end{itemize}

\section{\stringcode{.forcecont}}

\begin{verbatim}
label	.forcecont
\end{verbatim}

This defines a code item which represents an evaluation context of the form \<\hskwd{for} \lfloor{}x_0\rfloor \propto \bullet. e1\>.
This represents a continuation for a lifted expression, which receives the unlifted value as an argument.

The contents of a \stringcode{.forcecont} code item will be:
\begin{itemize}
    \item A list of the items (global variables) this evaluation context depends on, comprised of:
        \begin{itemize}
            \item A sequence of global type variable declarations (section \ref{code_type_gvar});
            \item A sequence of sub-code declarations (section \ref{subcode});
            \item A sequence of global coercion variable declarations (section \ref{coercion_gvar}); and
            \item A sequence of global object variable declarations (section \ref{value_gvar}).
        \end{itemize}
    \item A list of the (non-global) free variables of this evaluation context, comprised of:
        \begin{itemize}
            \item A sequence of free type variable declarations (section \ref{type_fv});
            \item A sequence of type lets using the free type variables decared above (section \ref{code_type_let});
            \item A sequence of free object variable declarations (section \ref{value_fv}), using the type variables declared above;
        \end{itemize}
    \item A further sequence of type lets (section \ref{code_type_let}).
    \item A single continuation argument (section \ref{cont_arg}).
    \item A list of local declarations within this evaluation context,
        intermixed in the appropriate order,\future{We plan to support recursion, at which point the only restriction will be that forward references will have to be to variables with type signatures.}
        consisting of
        \begin{itemize}
            \item Thunk allocations (section \ref{thunk_alloc}); and
            \item Value allocations (section \ref{value_alloc}).
        \end{itemize}
    \item A list of evaluation contexts, in the appropriate order (section \ref{cont_push}).
        And, finally,
    \item A terminal operator (section \ref{terminal_op}).
\end{itemize}

\section{\stringcode{.strictcont}}

\begin{verbatim}
label	.strictcont
\end{verbatim}

This defines a code item which represents an evaluation context of the form \<\hskwd{for} !x = \bullet. e1\>.
This represents a continuation for a lifted expression, which receives the unlifted value as an argument.

The contents of a \stringcode{.strictcont} code item will be:
\begin{itemize}
    \item A list of the items (global variables) this evaluation context depends on, comprised of:
        \begin{itemize}
            \item A sequence of global type variable declarations (section \ref{code_type_gvar});
            \item A sequence of sub-code declarations (section \ref{subcode});
            \item A sequence of global coercion variable declarations (section \ref{coercion_gvar}); and
            \item A sequence of global object variable declarations (section \ref{value_gvar}).
        \end{itemize}
    \item A list of the (non-global) free variables of this evaluation context, comprised of:
        \begin{itemize}
            \item A sequence of free type variable declarations (section \ref{type_fv});
            \item A sequence of type lets using the free type variables decared above (section \ref{code_type_let});\unimpl{This hasn't been implemented yet (\stringcode{.strictcont}s are little used); yell if you need it.}
            \item A sequence of free object variable declarations (section \ref{value_fv}), using the type variables declared above;
        \end{itemize}
    \item A further sequence of type lets (section \ref{code_type_let}).
    \item A single continuation argument (section \ref{cont_arg}).
    \item A list of local declarations within this evaluation context,
        intermixed in the appropriate order,\future{We plan to support recursion, at which point the only restriction will be that forward references will have to be to variables with type signatures.}
        consisting of
        \begin{itemize}
            \item Thunk allocations (section \ref{thunk_alloc});\unimpl{This hasn't been implemented yet, either.} and
            \item Value allocations (section \ref{value_alloc}).
        \end{itemize}
    \item A list of evaluation contexts, in the appropriate order (section \ref{cont_push}).
        And, finally,
    \item A terminal operator (section \ref{terminal_op}).
\end{itemize}

\section{\stringcode{.ubcasecont}}

\begin{verbatim}
label	.ubcasecont
\end{verbatim}

The elimination context for an un-boxed sum type has the form
\begin{haskell}
    \hskwd{analyze} \bullet. \hskwd{case} c_0 x_0. e_0 \ldots \hskwd{case} c_{n-1} x_{n-1}. e_{n-1}
\end{haskell}.
GSDL Global Script uses a \emph{vectored return}\cite{stg} to implement this construct,
where the evaluation context is stored on the stack as a vector of \stringcode{.ubcasecont}s corresponding to the individual cases,
together with a single common vector of free variable bindings.
This allows an un-boxed constructor (or primitive) to pop the appropriate case off the stack and branch to it directly.
A \stringcode{.ubcasecont} code item thus corresponds to a single \<\hskwd{case}\> in the above construct.

The contents of a \stringcode{.ubcasecont} code item will be:
\begin{itemize}
    \item A list of the items (global variables) this evaluation context depends on, comprised of:
        \begin{itemize}
            \item A sequence of global type variable declarations (section \ref{code_type_gvar});
            \item A sequence of sub-code declarations (section \ref{subcode});
            \item A sequence of global coercion variable declarations (section \ref{coercion_gvar}); and
            \item A sequence of global object variable declarations (section \ref{value_gvar}).
        \end{itemize}
    \item A list of the (non-global) free variables of this evaluation context, comprised of:
        \begin{itemize}
            \item A sequence of free type variable declarations (section \ref{type_fv});
            \item A sequence of type lets using the free type variables decared above (section \ref{code_type_let});\unimpl{This hasn't been implemented yet; yell if you need it.}
            \item A sequence of free object variable declarations (section \ref{value_fv}), using the type variables declared above;
        \end{itemize}
    \item A further sequence of type lets (section \ref{code_type_let}).
    \item A continuation argument, declared either as
        \begin{itemize}
            \item A single continuation argument (section \ref{cont_arg}), or
            \item A list of continuation argument fields (section \ref{field_cont_arg}).
        \end{itemize}
    \item A list of local declarations within this evaluation context,
        intermixed in the appropriate order,\future{We plan to support recursion, at which point the only restriction will be that forward references will have to be to variables with type signatures.}
        consisting of
        \begin{itemize}
            \item Thunk allocations (section \ref{thunk_alloc});\unimpl{This hasn't been implemented yet, either.} and
            \item Value allocations (section \ref{value_alloc}).
        \end{itemize}
    \item A list of evaluation contexts, in the appropriate order (section \ref{cont_push}).
        And, finally,
    \item A terminal operator (section \ref{terminal_op}).
\end{itemize}

\section{\stringcode{.impprog}}

\begin{verbatim}
label	.impprog	primset	primtype
\end{verbatim}

This defines a closure of the form \<\hskwd{for} @m \overline{g_i}_i. e\>.\future{Or \<\hskwd{for}\;\hskwd{rec}\;@m\;\overline{g_i}_i.\;e\>, once we add support for recursion.}
These are special values, since they need to be executed on an API thread rather than being part of regular evaluation.

Closures with \stringcode{.impprog} bodies are considered 'boxed', which makes them un-lifted,
unless you specifically lift them using a \stringcode{.lift} evaluation context or give them arguments.\new{0.6}{
  these were considered lifted if and only if the \stringcode{.body} expression was lifted,
  and they were required to be lifted if the expression on the right-hand side of the first\stringcode{.bind} expression was lifted.
}

The contents of an \stringcode{.impprog} code item will be:
\begin{itemize}
    \item A list of the items (global variables) this evaluation context depends on, comprised of:
        \begin{itemize}
            \item A sequence of global type variable declarations (section \ref{code_type_gvar});
            \item A sequence of sub-code declarations (section \ref{subcode});
            \item A sequence of global coercion variable declarations (section \ref{coercion_gvar});\unimpl{This isn't implemented yet, since no implemented generator or body form would support it yet} and
            \item A sequence of global object variable declarations (section \ref{value_gvar}).\unimpl{This isn't implemented yet, since no implemented generator or body form would support it yet}
        \end{itemize}
    \item A list of the (non-global) free variables of this evaluation context, comprised of:
        \begin{itemize}
            \item A sequence of free type variable declarations (section \ref{type_fv});
            \item A sequence of type lets using the free type variables decared above (section \ref{code_type_let});\unimpl{This hasn't been implemented yet; yell if you need it.}
            \item A sequence of free object variable declarations (section \ref{value_fv}), using the type variables declared above;
        \end{itemize}
    \item A further sequence of type lets (section \ref{code_type_let}).\unimpl{This hasn't been implemented yet, either.}
    \item A sequence, intermixed in the appropriate order,\unimpl{The arbitrary inter-mixing isn't supported yet; currently, the sequence must be type arguments, then type lets, then value arguments.} of:
        \begin{itemize}
            \item Type argument declarations (section \ref{code_type_arg});
            \item Type lets using the type arguments declared above (and other type variables in scope at this point) (section \ref{code_type_let}); and
            \item Object argument declarations, using the type variables declared above (section \ref{value_arg}).
        \end{itemize}
    \item A list of local declarations within this evaluation context,
        intermixed in the appropriate order,\future{We plan to support recursion.
            Obviously, we will still require that bind generators be placed in the order they will be executed in,
            but at that point allocations can be listed in any order.
        }
        consisting of
        \begin{itemize}
            \item Thunk allocations (section \ref{thunk_alloc}); and
            \item Bind generators (section \ref{bind}).
        \end{itemize}
        And, finally,
    \item A body expression (section \ref{body}).
\end{itemize}

\section{Global Type Variables}
\label{code_type_gvar}

These are type variables with definitions that are global in scope,
as opposed to `free' type variables, which are defined (actually, lambda-bound) in an intermediate enclosing scope.

\subsection{\stringcode{.tygvar}}

\begin{verbatim}
t	.tygvar
\end{verbatim}

This declares (a dependency on) the global type variable \stringcode{t},
which is any type label defined at the top level, either a type synonym or an abstract type (= type constant).

\subsection{\stringcode{.tyextabstype}}

\begin{verbatim}
t	.tyextabstype	ki
\end{verbatim}

This declares \stringcode{t} to be specifically the type constant \stringcode{t},
which must have kind \stringcode{ki} (see section \ref{kinds}).
This construct allows the string compiler to produce output files that are relatively independent of each other.

\subsection{\stringcode{.tyextelimprim}}

\begin{verbatim}
t	.tyextelimprim	ps	pn	ki
\end{verbatim}

This declares \stringcode{t} to be the elimination primitive type \stringcode{pn} from primitive set \stringcode{ps},
with kinds \stringcode{ki} (see section \ref{kinds}).
This isn't really an external dependency;
it's more a kind of type literal, that simplifies the implementation of the string compiler.

\section{Sub-Code Items}
\label{subcode}

These declare dependencies on code items which sub-expressions or evaluation contexts within this expression were compiled to.

\subsection{\stringcode{.subcode}}

\begin{verbatim}
c	.subcode
\end{verbatim}

This declares that the code item \stringcode{c} is a sub-expression or evaluation context of the current code item.

\section{Global Coercion Variables}
\label{coercion_gvar}

These are type variables with definitions that are global in scope,
as opposed to `free' coercion variables,\unimpl{we don't support coercion abstractions or definitions, yet.}
which are lambda-bound at a higher level or defined in an intermediate enclosing scope.

\subsection{\stringcode{.cogvar}}

\begin{verbatim}
co	.cogvar
\end{verbatim}

This declares a dependency on the global coercion variable \stringcode{co}.

\section{Global Data Variables}
\label{value_gvar}

These are value variables (generally, object variables) with definitions that are global in scope,
as opposed to `free' value variables, which are lambda-bound at a higher level or defined in an intermediate enclosing scope.

\subsection{\stringcode{.gvar}}

\begin{verbatim}
x	.gvar
\end{verbatim}

This declares a dependency on the global variable \stringcode{x}.

\subsection{\stringcode{.rune}}

\begin{verbatim}
r	.rune	ch
\end{verbatim}

This binds \stringcode{r} to the rune literal \stringcode{ch}.
Technically, this is a generator, but is kept with the global variables so we have a good storage location for \stringcode{ch}.

\subsection{\stringcode{.natural}}

\begin{verbatim}
x	.natural	n
\end{verbatim}

This binds \stringcode{x} to the decimal natural number literal \stringcode{n}.
\stringcode{n} should be small enough to be stored un-boxed, which makes this syntax somewhat machine-dependent.
This is technically a generator, but is kept with the global variables so we have a good storage location for \stringcode{n}.

\section{Free Type Variables}
\label{type_fv}

These are type variables that are lambda-bound in an enclosing expression.
These should only be lambda-bound variables, and not let-defined variables, because string code is typed bottom-up,
which means each code item is typed (in terms of its free type variables) first, then that type is used to type-check the enclosing context.
This means that free type variables will be treated as lambda-bound regardless of how they are actually defined.

\subsection{\stringcode{.tyfv}}

\begin{verbatim}
t	.tyfv	ki
\end{verbatim}

This declares \stringcode{t} to be a free type variable of kind \stringcode{ki} (see section \ref{kinds}).

\section{Free Variables}
\label{value_fv}

These are free object or value variables that are bound in an intermediate scope between this expression or evaluation context and the global level of the program.

\subsection{\stringcode{.fv}}

\begin{verbatim}
x	.fv	tyf	tyx0	...	tyxn-1
\end{verbatim}

This declares \stringcode{x} to be a free variable of type \stringcode{tyf tyx$_0$ $\ldots$ tyx$_{n-1}$}.

\subsection{\stringcode{.efv}}

\begin{verbatim}
x	.efv	tyf	tyx0	...	tyxn-1
\end{verbatim}

This is the same as \stringcode{.fv}, but warns that \stringcode{x}, which is of un-lifted type, may nevertheless be bound to a (fulfilled) promise.
As such, when this expression is entered, \stringcode{x} should first have all indirections removed before the value is used.

This is required for any (unlifted) free variable which is bind-bound in the enclosing scope,
as well in some cases involving mutual recursion between lifted and unlifted variables.

\section{Type Arguments}
\label{code_type_arg}

These are abstractions over type variables.

\subsection{\stringcode{.tyarg}}

\begin{verbatim}
t	.tyarg	ki
\end{verbatim}

This declares \stringcode{t} to be a type variable with kind \stringcode{ki}  (see section \ref{kinds}).

\section{Type Continuation Arguments}
\label{cont_type_arg}

\subsection{\stringcode{.exkarg}}

\begin{verbatim}
t	.exkarg	ki
\end{verbatim}

This declares that the argument to the continuation has an existential quantifier,
with quantified type variable \stringcode{t} of kind \stringcode{ki}  (see section \ref{kinds}).

\section{Value Arguments}
\label{value_arg}

These are abstractions over object or value variables.

\subsection{\stringcode{.larg}}

\begin{verbatim}
x	.larg	tyf	tyx_0	...	tyx_n-1
\end{verbatim}

This does two jobs:
it declares \stringcode{x} to be an argument of type \stringcode{tyf $tyx_0$ $\ldots$ $tyx_{n-1}$},
and it lifts the resulting lambda term.

\subsection{\stringcode{.arg}}

\begin{verbatim}
x	.arg	tyf	tyx_0	...	tyx_n-1
\end{verbatim}

This only declares \stringcode{x} to be an argument of type \stringcode{tyf $tyx_0$ $\ldots$ $tyx_{n-1}$};
the resulting expression is un-lifted.

\section{(Boxed) Continuation Arguments}
\label{cont_arg}

This declares the (single) value argument to a continuation for a boxed type.

\subsection{\stringcode{.karg}}

\begin{verbatim}
x	.karg	tyf	tyx0	...	tyxn-1
\end{verbatim}

This declares \stringcode{x} to be the continuation's argument, of type \stringcode{tyf tyx$_0$ $\ldots$ tyx$_{n-1}$}.

\section{(Un-boxed Product) Continuation Arguments}
\label{field_cont_arg}

This declares the (single) value argument to a continuation for a boxed type.

\subsection{\stringcode{.karg}}

\begin{verbatim}
x	.fkarg	f	tyf	tyx0	...	tyxn-1
\end{verbatim}

This declares \stringcode{x} to be the field \stringcode{f} of the continuation's (un-boxed product) argument,
of type \stringcode{tyf tyx$_0$ $\ldots$ tyx$_{n-1}$}.

\section{Local Type Definitions}
\label{code_type_let}

These allow for location type variable definitions,
mainly for cases where a complex type expression is need but the syntax requires a simple variable.

\subsection{\stringcode{.tylet}}

\begin{verbatim}
t	.tylet	tyf	tyx_0	...	tyx_n
\end{verbatim}

This defines \stringcode{t} to be the result of applying \stringcode{tyf} to the type variables \stringcode{tyx\_0} $\ldots$ \stringcode{tyx\_n}.

Technically, this only allows type applications to be named;
more complicated type expressions can be dealt with via lambda-lifting.

\section{Thunk (Closure) Allocations}
\label{thunk_alloc}

These are actually just the allocations that are supported in both expressions and in imperative block statements.

\subsection{\stringcode{.closure}}
\new{0.3}{this construct was called \stringcode{.alloc}.}

\begin{verbatim}
label	.closure	<code label>
\end{verbatim}

\stringcode{<code label>} should be either an \stringcode{.expr} or a \stringcode{.impprog} code item;
this construct binds \stringcode{label} to the expression defined by \stringcode{<code label>}.

Legally, the label can be omitted with a warning (since allocation operations are side-effect-free).

\subsection{\stringcode{.impprim}}
\new{0.5}{in imperative block statements, this had to be put out in a \stringcode{.closure} and the result returned.}
\unimpl{This is un-supported in imperative block statements as yet.}

\begin{verbatim}
x	.impprim	primset	primtype	prim	type	tyx0	...	tyxn-1	|	x0	...	xn-1
\end{verbatim}

This defines \stringcode{x} to be the image of \stringcode{prim}, from \stringcode{primset},
at type arguments \stringcode{tyx$_0$, $\ldots$, tyx$_{n-1}$}
and value arguments \stringcode{x$_0$, $\ldots$, x$_{n-1}$}.
\stringcode{type} should be a type synonym that expands to the actual, polymorphic, type of \stringcode{prim};
for primsets known to the interpreter, it will be checked against the actual type,
and for primsets unknown to the interpreter,
it will be blindly believed and used to type-check the arguments and assign a type to \stringcode{x}.
The result type must be an appliction of \stringcode{primtype} from the same primitive set,
which must be an imperative primitive type.

\subsection{\stringcode{.lfield}}
\new{0.5}{in imperative block statements, this had to be put out in a \stringcode{.closure} and the result returned.}
\unimpl{This is un-supported in imperative block statements as yet.}

\begin{verbatim}
x	.lfield	f	r
\end{verbatim}

This binds \stringcode{x} to the field \stringcode{f} of \stringcode{r}, which must be a lifted record with a field \stringcode{f}, which must in turn have lifted type.

\subsection{\stringcode{.undefined}}
\new{0.5}{in imperative block statements, a \stringcode{.undef} had to be put out in a \stringcode{.closure}.}
\unimpl{This is un-supported in imperative block statements as yet.}

\begin{verbatim}
x	.undefined	tyf	tyx0	...	tyxn-1
\end{verbatim}

This binds \stringcode{x} to the `undefined' value of type \stringcode{tyf tyx$_0$ $\ldots$ tyx$_{n-1}$},
which must be a lifted type.

\subsection{\stringcode{.lifted}}
\new{0.5}{in imperative block statements, a \stringcode{.lift} had to be put out in a \stringcode{.closure}.}
\unimpl{This is un-supported in imperative block statements as yet.}

\begin{verbatim}
y	.lifted	x
\end{verbatim}

This binds \stringcode{y} to the image of \stringcode{x} under the unit of the lifting monad.

\subsection{\stringcode{.cast}}
\new{0.5}{in imperative block statements, a \stringcode{.coerce} had to be put out in a \stringcode{.closure}.}
\unimpl{This is un-supported in imperative block statements as yet.}

\begin{verbatim}
y	.cast	x	cof	tyx0	...	tyxn-1
\end{verbatim}

This binds \stringcode{x} to the image of \stringcode{x} under the application of the coercion \stringcode{cof} to the type variables \stringcode{tyx$_0$, $\ldots$, tyx$_{n-1}$}.

\subsection{\stringcode{.apply}}
\new{0.5}{in imperative block statements, a \stringcode{.app} had to be put out in a \stringcode{.closure}.}
\unimpl{This is un-supported in imperative block statements as yet.}

\begin{verbatim}
y	.cast	f	tyx0	...	tyxn-1	|	x0	...	xm-1
\end{verbatim}

This binds \stringcode{y} to the image of \stringcode{f} a type arguments \stringcode{tyx$_0$ $\ldots$ tyx$_{n-1}$} and value arguments \stringcode{x$_0$ $\ldots$ x$_{m-1}$}.

\section{Value Allocations}
\label{value_alloc}

These are the allocations that are not legal in imperative block statements.

\subsection{\stringcode{.prim}}

\begin{verbatim}
x	.prim	primset	prim	type	tyx0	...	tyxn-1	|	x0	...	xn-1
\end{verbatim}

This defines \stringcode{x} to be the image of \stringcode{prim}, from \stringcode{primset},
at type arguments \stringcode{tyx$_0$, $\ldots$, tyx$_{n-1}$}
and value arguments \stringcode{x$_0$, $\ldots$, x$_{n-1}$}.
\stringcode{type} should be a type synonym that expands to the actual, polymorphic, type of \stringcode{prim};
for primsets known to the interpreter, it will be checked against the actual type,
and for primsets unknown to the interpreter,
it will be blindly believed and used to type-check the arguments and assign a type to \stringcode{x}.

\subsection{\stringcode{.constr}}

\begin{verbatim}
x	.constr	t	c	<args>
\end{verbatim}

\stringcode{<args>} should either be a single variable,\unimpl{only the record form is supported currently}
or a list of field name / variable pairs, which will be treated as an un-boxed record literal.
\stringcode{t} should be a sum type with a constructor \stringcode{c},
whose argument type is the type of \stringcode{<args>}, however interpreted.
The construct as a whole binds \stringcode{x} to the image of \stringcode{<args>} under the injection defined by \stringcode{c} into \stringcode{t}.

\subsection{\stringcode{.exconstr}}

\begin{verbatim}
x	.exconstr	t	c	<type args> |	<args>
\end{verbatim}

\stringcode{<args>} should either be a single variable,\unimpl{only the record form is supported currently}
or a list of field name / variable pairs, which will be treated as an un-boxed record literal.
\stringcode{t} should be a sum type with a constructor \stringcode{c},
whose argument type has as many existential quantifiers as there are type arguments,
and whose body, after substituting the values of the type arguments for those quantified variables,
is the type of \stringcode{<args>}, however interpreted.
The construct as a whole binds \stringcode{x} to the image of \stringcode{<args>} under the injection defined by \stringcode{c} into \stringcode{t}.

\subsection{\stringcode{.record}, \stringcode{.lrecord}}

\begin{verbatim}
x	.record	<field args>
x	.record	<field args> |	tyf	tyx0	...	tyxn-1
x	.lrecord	<field args>
x	.lrecord	<field args> |	tyf	tyx0	...	tyxn-1
\end{verbatim}

\stringcode{<field args>} is a sequence of field name, variable pairs, giving the values of the fields of the record.
\stringcode{.record} binds \stringcode{x} to the so-defined record;
\stringcode{.lrecord} binds \stringcode{x} to its image under the unit of the lifting monad.
The clause \stringcode{| tyf tyx$_0$ $\ldots$ tyx$_{n-1}$}, if present, is a type signature;
it gives the type of \stringcode{x}, so in the \stringcode{.lrecord} case it must itself be lifted.
Every field in the record must be given a value explicitly; there is no support for undefined fields.

\subsection{\stringcode{.field}}

\begin{verbatim}
x	.field	f	r
\end{verbatim}

This binds \stringcode{x} to the field \stringcode{f} of \stringcode{r}, which must be an unlifted record with a field \stringcode{f}.

\section{Bind Generators}
\label{bind}

These are used in imperative block statements to execute sub-programs and name their results.

\subsection{\stringcode{.bind}}
\old{0.4}{\stringcode{.bind} meant what is now written \stringcode{.bind	.closure}.}
\new{0.5}{these were combined into one token; e.g., what is now written \stringcode{.bind	.closure} was \stringcode{.bind.closure}.}

\begin{verbatim}
x	.bind	<alloc op>
\end{verbatim}

This declares \stringcode{x} to be the result of executing the subprogram denoted by the allocation operator.
The allocation operator can be any specified in section \ref{thunk_alloc},
although since it will need to be of imperative type, not all allocations will be useful.\unimpl{Only \stringcode{.closure} is currently implemented.}

\section{Block Statement Bodies}
\label{body}

These are similar to bind generators (section \ref{bind}), but they define the last sub-program in a block statement.
The result of these sub-programs is returned directly from the block statement, rather than being captured and used inside it.

\subsection{\stringcode{.body}}
\old{0.4}{\stringcode{.body} meant wah is now written \stringcode{.body	.closure}.}
\new{0.5}{these were combined into one token; e.g., what is now written \stringcode{.body	.closure} was \stringcode{.body.closure}.}

\begin{verbatim}
	.body	<alloc op>
\end{verbatim}

This declares the result of the block statement to be the result of executing the subprogram denoted by the allocation operator.
As with bind generators, the allocation operator can be any specified in section \ref{thunk_alloc},
although since it will need to be of imperative type, not all allocations will be useful.\unimpl{Only \stringcode{.closure} is currently implemented.}

\section{Evaluation Contexts}
\label{cont_push}

\subsection{\stringcode{.lift}}

\begin{verbatim}
	.lift
\end{verbatim}

This corresponds to the evaluation context \<\lfloor\bullet\rfloor\>, which returns the image of the following expression under the unit of the lifting monad.

\subsection{\stringcode{.coerce}}

\begin{verbatim}
	.coerce	cof	tyx0	...	tyxn-1
\end{verbatim}
This corresponds to the evaluation context \<\bullet\;"\!\rhd\;cof (\hskwd{type} tyx_0) \ldots (\hskwd{type} tyx_{n-1})\>,
which returns the image of the following expression under the given coercion.

\subsection{\stringcode{.app}}

\begin{verbatim}
	.app	x0	...	xn-1
\end{verbatim}
This corresponds to the evalution context \<\bullet\;x_0\;\ldots\;x_n{-1}\>,
which returns the image of the given arguments under the following expression.

\subsection{\stringcode{.force}}

\begin{verbatim}
	.force	k
\end{verbatim}
This corresponds to the evaluation context denoted by the code item labeled by \stringcode{k},
which must be a \stringcode{.forcecont}.

\subsection{\stringcode{.strict}}

\begin{verbatim}
	.strict	k
\end{verbatim}
This corresponds to the evaluation context denoted by the code item labeled by \stringcode{k},
which must be a \stringcode{.strictcont}.

\subsection{\stringcode{.ubanalyze}}

\begin{verbatim}
	.ubanalyze	c0	k0	...	cn-1	kn-1
\end{verbatim}
This corresponds to an evaluation context of the form
\begin{haskell}
\hskwd{analyze}\;\bullet.\;\hskwd{case}\;c_0\;x_0.\;e_0\ldots\hskwd{case}\;c_{n-1}\;x_{n-1}.\;e_{n-1}
\end{haskell},
where the scrutinee has un-boxed sum type or lifted un-boxed sum type,
the constructors are the arguments \stringcode{c$_0$, $\ldots$, c$_{n-1}$},
and the corresponding cases are given by the code items labeled by \stringcode{k$_0$, $\ldots$, k$_{n-1}$}.

\section{Terminal Operators}
\label{terminal_op}

\subsection{\stringcode{.undef}}

\begin{verbatim}
	.undef	tyf	tyx0	...	tyxn-1
\end{verbatim}

This allocates and returns the least element of the type \stringcode{tyf tyx$_0$ $\ldots$ tyx$_{n-1}$}, which must be a lifted type.

\subsection{\stringcode{.yield}}

\begin{verbatim}
	.yield	x	tyx0	...	tyxn-1
\end{verbatim}

This returns the value of \stringcode{x} applied to the type arguments \stringcode{tyx$_0$ $\ldots$ tyx$_{n-1}$}.
\stringcode{x} must be of unlifted type, and hence bound to an actual value.

\subsection{\stringcode{.enter}}

\begin{verbatim}
	.enter	x	tyx0	...	tyxn-1
\end{verbatim}

This expression has the value of \stringcode{x} applied to the type arguments \stringcode{tyx$_0$ $\ldots$ tyx$_{n-1}$}.
\stringcode{x} must be of lifted type, and so may be bound to a value or to a thunk.
If bound to a value, the \stringcode{.enter} instruction will return that value;
if bound to a thunk, the \stringcode{.enter} instruction will enter that thunk.

\subsection{\stringcode{.ubprim}}

\begin{verbatim}
	.ubprim	primset	prim	ty	tyx0	...	tyxn-1	|	x0	...	xn-1
\end{verbatim}

This returns the image of the primitive \stringcode{prim} from primset \stringcode{primset} at type arguments \stringcode{tyx$_0$ $\ldots$ tyx$_{n-1}$} and value arguments \stringcode{x$_0$ $\ldots$ x$_{n-1}$},
which should be a saturated application.
\stringcode{ty} should be the actual (possibly polymorphic) type of the primitive,
and the type of the whole application should be a (possibly lifted) un-boxed sum or un-boxed product.

XXX Do lifted un-boxed primitives use this or \stringcode{.lprim}?

\subsection{\stringcode{.lprim}}

\begin{verbatim}
	.lprim	primset	prim	ty	tyx0	...	tyxn-1	|	x0	...	xn-1
\end{verbatim}

This returns the image of the primitive \stringcode{prim} from primset \stringcode{primset} at type arguments \stringcode{tyx$_0$ $\ldots$ tyx$_{n-1}$} and value arguments \stringcode{x$_0$ $\ldots$ x$_{n-1}$},
which should be a saturated application.
\stringcode{ty} should be the actual (possibly polymorphic) type of the primitive,
and the type of the whole application should be lifted.

(Non-imperative) primitives are actually divided at the implementation level into three classes:
\begin{itemize}
    \item Simple primitives, which run in a bounded amount of time (and are un-interruptible) and return a boxed un-lifted value;
    \item Un-boxed primitives, which return an un-boxed value and so need a vector of continuations to return to; and
    \item Lifted primitives, which may block (and so need to be interrupted), may never return, and return a lifted value.
\end{itemize}
The different primitive instructions correspond to this breakdown.

\subsection{\stringcode{.analyze}}

This isn't really a 'terminal' operator, but it's legal only where we allow terminal operators.

\begin{verbatim}
	.analyze	x	c0	...	cn-1
\end{verbatim}

This branches on \stringcode{x}, which must be of (un-lifted) sum type with constructors \stringcode{c$_0$, $\ldots$, c$_{n-1}$}.
The constructors must be given in unibetical order by printed name, as used in the source code.
\stringcode{x} may  not have empty sum type.

The \stringcode{.analyze} statement must be followed by a sequence of \stringcode{case} ops (see section \ref{case}),
in order, one per constructor, defining the behavior for the various branches.

\subsection{\stringcode{.danalyze}}

This isn't really a 'terminal' operator, but it's legal only where we allow terminal operators.

\begin{verbatim}
	.danalyze	x	c0	...	cn-1
\end{verbatim}

This branches on \stringcode{x}, which must be of (un-lifted) sum type which has constructors \stringcode{c$_0$, $\ldots$, c$_{n-1}$},
among others.
The constructors must be given in unibetical order by printed name, as used in the source code.
There must be at least one constructor listed, but the type of \stringcode{x} may have other constructors not listed.
In that case, if \stringcode{x} is the image of one of those constructors, evaluation will proceed with the default case.

The \stringcode{.analyze} statement must be followed by a \stringcode{default} op (see section \ref{default}),
then a sequence of \stringcode{case} ops (see section \ref{case}),
in order, one per constructor, defining the behavior for the various branches.

\section{\stringcode{.case} and \stringcode{.default}}
\label{case}

\begin{verbatim}
	.case	c
	ops
\end{verbatim}
or
\begin{verbatim}
	.default
	ops
\end{verbatim}

This defines a specific case, or the default case of a \stringcode{.danalyze}.

The contents of a \stringcode{.case} will be:
\begin{itemize}
    \item A sequence of:
        \begin{itemize}
            \item Type argument declarations (section \ref{cont_type_arg}).
        \end{itemize}
    \item A sequence of:
        \begin{itemize}
            \item Type lets using the type arguments declared above (and other type variables in scope at this point) (section \ref{code_type_let}).
        \end{itemize}
    \item A continuation argument, declared either as
        \begin{itemize}
            \item A single continuation argument (section \ref{cont_arg}), or
            \item A list of continuation argument fields (section \ref{field_cont_arg}).
        \end{itemize}
    \item A list of local declarations within this expression,
        intermixed in the appropriate order,\future{We plan to support recursion at this point, at which point the only restriction will be that forward references will have to be to variables with type signatures.}
        consisting of
        \begin{itemize}
            \item Thunk allocations (section \ref{thunk_alloc}); and
            \item Value allocations (section \ref{value_alloc}).
        \end{itemize}
    \item A list of evaluation contexts, in the appropriate order (section \ref{cont_push}).
        And, finally,
    \item A terminal operator (section \ref{terminal_op}).
\end{itemize}
A \stringcode{.default} will have the same contents, but with the arguments and type lets omitted.

\chapter{Types}

Free variables are handled by having type $\lambda$ nodes, and allowing
\begin{verbatim}
tv	.tylet	tf	x	y	z
\end{verbatim}
in type items, with arguments implemented by doing $\beta$-reduction directly on type trees.

In certain kinds of type declarations, type applications are also permitted:
\begin{verbatim}
x	.fv	t	alpha	beta	gamma
x	.arg	t	alpha	beta	gamma
\end{verbatim}
\verb+t+ can be an abstract type or primitive type or a type synonym.

In both cases, the argument is declared in the type item using \verb+.tylambda+:\footnote{Well, sort of.}
\begin{verbatim}
t	.tylambda	*
\end{verbatim}

\chapter{API Block Statements}

These are similar to expressions;
in fact, the data items use \verb+.closure+ like expressions do;
only the code items are different.

In Core, a block statement looks like
\begin{haskell}
    \hskwd{for}\;@\hsinf{type arg} \hsinf{gens}. \hsinf{body}
\end{haskell}
or
\begin{haskell}
    \hskwd{for}\;\hskwd{rec}\;@\hsinf{type arg} \hsinf{gens}. \hsinf{body}
\end{haskell}
The generators look like
\begin{haskell*}
    \hsinf{var} & = & \hsinf{expr}; \hscom{Let} \\
    \lfloor\hsinf{var}\rfloor & \propto & \hsinf{expr}; \hscom{Force} \\
    \hsinf{var} & \leftarrow & \hsinf{expr}; \hscom{Bind} \\
\end{haskell*}
; the body is an expression.

String code only permits `let' generators at lifted types and `bind' generators in its `imperative block statement' construct;
the others are compiled to \verb+.expr+s.\footnote{Not so!  Ignores the issue of RRF RHSs!}
\footnote{
    Unlifted `let' generators and `force' generators bind variables of unlifted types,
    and so cannot participate in recursion,
    \emph{including forward references to bind generators}.
    NB: That's not entirely true --- variables of unlifted but pointed type, like unlifted function types,
    \emph{can} be recursively defined --- need to think about that more.
    Update: I've thought about this; it's a \emph{long} story.
}

A block statement gets compiled to an \verb+.impprog+ code item.

The syntax is
\begin{verbatim}
label	.impprog	primset	primtype
\end{verbatim}
That is followed by global variables, free variables, and arguments as for an \verb+.expr+.

`Let' generators get compiled to\new{0.3}{this was called \stringcode{.alloc}.}
\begin{verbatim}
var	.closure	code-label
\end{verbatim}
`Bind' generators get compiled to\new{0.4}{this was just \stringcode{.bind}.} \new{0.5}{this was one token, \stringcode{.bind.closure}.}
\begin{verbatim}
var	.bind	.closure	code-label
\end{verbatim}
The body gets compiled to\new{0.4}{this was just \stringcode{.body}.} \new{0.5}{this was one token, \stringcode{.body.closure}.}
\begin{verbatim}
	.body	.closure	code-label
\end{verbatim}

\chapter{\stringcode{.regex} Literals}\agsonly{Regex literals are only supported for simplifying hand-written string code, for bootstrapping.}

We have interpolation support in string code regex literals.
To use, put \stringcode{ยง} (with no name) in the literal
and then follow the literal with the variable to use for each interpolation:
\begin{verbatim}
foo.re .regex ยง|ยง _foo.re_long.expression.1.re _foo_re_long.expression.2.re
_foo.re_long.expression.1.re .regex long|complicated\sexpression
...
\end{verbatim}

You can interpolate any top-level data item, not just \stringcode{.regex} literals.

\stringcode{.regex} won't support any grouping operator,
so interpolation will be the only way to override the default precedence order.
Interpolations aren't supported inside classes yet but they will be.

\chapter{Source Code}

\begin{verbatim}
long
gsparse_type_item(struct gsparse_input_pos *pos, gsparsedfile *parsedfile, struct uxio_ichannel *chan, char *line, char **fields, ulong numfields, struct gsfile_symtable *symtable)
{
    static gsinterned_string gssymtyintrprim, gssymtyelimprim;

    struct gsparsedline *parsedline;

    parsedline = gsparsed_file_addline(pos, parsedfile, numfields);
    parsedfile->types->numitems++;

    if (*fields[0])
        parsedline->label = gsintern_string(gssymtypelable, fields[0]);
    else
        gsfatal("%s:%d: Missing type label", pos->real_filename, pos->real_lineno);

    gssymtable_add_type_item(symtable, parsedline->label, parsedfile, parsedfile->last_seg, parsedline);

    parsedline->directive = gsintern_string(gssymtypedirective, fields[1]);

    if (gssymeq(parsedline->directive, gssymtypedirective, ".tyexpr")) {
        if (numfields > 2 + 0)
            parsedline->arguments[0] = gsintern_string(gssymkindexpr, fields[2 + 0])
        ;
        if (numfields > 2 + 1)
            gsfatal("%s:%d: Too many arguments to .tyexpr", pos->real_filename, pos->real_lineno)
        ;
        return gsparse_type_ops(pos, parsedfile, parsedline, chan, line, fields);
    } else if (gssymeq(parsedline->directive, gssymtypedirective, ".tydefinedprim")) {
        if (numfields < 2 + 1)
            gsfatal("%s:%d: Missing primitive group name", pos->real_filename, pos->real_lineno);
        parsedline->arguments[0] = gsintern_string(gssymprimsetlable, fields[2 + 0]);
        if (numfields < 2 + 2)
            gsfatal("%s:%d: Missing primitive type relative name", pos->real_filename, pos->real_lineno);
        parsedline->arguments[1] = gsintern_string(gssymtypelable, fields[2 + 1]);
        if (numfields < 2 + 3)
            gsfatal("%s:%d: Missing kind on primitive type", pos->real_filename, pos->real_lineno);
        parsedline->arguments[2] = gsintern_string(gssymkindexpr, fields[2 + 2]);
        return 0;
    } else if (gssymceq(parsedline->directive, gssymtyintrprim, gssymtypedirective, ".tyintrprim")) {
        if (numfields < 2 + 1)
            gsfatal("%s:%d: Missing primitive group name", pos->real_filename, pos->real_lineno);
        parsedline->arguments[0] = gsintern_string(gssymprimsetlable, fields[2 + 0]);
        if (numfields < 2 + 2)
            gsfatal("%s:%d: Missing primitive type relative name", pos->real_filename, pos->real_lineno);
        parsedline->arguments[1] = gsintern_string(gssymtypelable, fields[2 + 1]);
        if (numfields < 2 + 3)
            gsfatal("%s:%d: Missing kind on primitive type", pos->real_filename, pos->real_lineno);
        parsedline->arguments[2] = gsintern_string(gssymkindexpr, fields[2 + 2]);
        return 0;
    } else if (gssymceq(parsedline->directive, gssymtyelimprim, gssymtypedirective, ".tyelimprim")) {
        if (numfields < 2 + 1)
            gsfatal("%s:%d: Missing primitive group name", pos->real_filename, pos->real_lineno);
        parsedline->arguments[0] = gsintern_string(gssymprimsetlable, fields[2 + 0]);
        if (numfields < 2 + 2)
            gsfatal("%s:%d: Missing primitive type relative name", pos->real_filename, pos->real_lineno);
        parsedline->arguments[1] = gsintern_string(gssymtypelable, fields[2 + 1]);
        if (numfields < 2 + 3)
            gsfatal("%s:%d: Missing kind on primitive type", pos->real_filename, pos->real_lineno);
        parsedline->arguments[2] = gsintern_string(gssymkindexpr, fields[2 + 2]);
        return 0;
    } else if (gssymeq(parsedline->directive, gssymtypedirective, ".tyimpprim")) {
        if (numfields < 2 + 1)
            gsfatal("%s:%d: Mising primitive group name", pos->real_filename, pos->real_lineno);
        parsedline->arguments[0] = gsintern_string(gssymprimsetlable, fields[2 + 0]);
        if (numfields < 2 + 2)
            gsfatal("%s:%d: Missing primitive type relative name", pos->real_filename, pos->real_lineno);
        parsedline->arguments[1] = gsintern_string(gssymtypelable, fields[2 + 1]);
        if (numfields < 2 + 3)
            gsfatal("%s:%d: Missing kind on primitive type", pos->real_filename, pos->real_lineno);
        parsedline->arguments[2] = gsintern_string(gssymkindexpr, fields[2 + 2]);
        return 0;
    } else if (gssymeq(parsedline->directive, gssymtypedirective, ".tyelimprim")) {
        if (numfields < 2 + 1)
            gsfatal("%s:%d: Mising primitive group name", pos->real_filename, pos->real_lineno);
        parsedline->arguments[0] = gsintern_string(gssymprimsetlable, fields[2 + 0]);
        if (numfields < 2 + 2)
            gsfatal("%s:%d: Missing primitive type relative name", pos->real_filename, pos->real_lineno);
        parsedline->arguments[1] = gsintern_string(gssymtypelable, fields[2 + 1]);
        if (numfields < 2 + 3)
            gsfatal("%s:%d: Missing kind on primitive type", pos->real_filename, pos->real_lineno);
        parsedline->arguments[2] = gsintern_string(gssymkindexpr, fields[2 + 2]);
        return 0;
    } else if (gssymeq(parsedline->directive, gssymtypedirective, ".tyabstract")) {
        if (numfields < 2 + 1)
            gsfatal("%s:%d: Missing kind on .tyabstract", pos->real_filename, pos->real_lineno);
        parsedline->arguments[0] = gsintern_string(gssymkindexpr, fields[2 + 0]);
        if (numfields > 2 + 1)
            gsfatal("%s:%d: Too many arguments to .tyabstract", pos->real_filename, pos->real_lineno);
        return gsparse_type_ops(pos, parsedfile, parsedline, chan, line, fields);
    } else {
        gsfatal(UNIMPL("%s:%d: Unimplemented type directive %s"), pos->real_filename, pos->real_lineno, fields[1]);
    }

    gsfatal("%s:%d: gsparse_type_item next", __FILE__, __LINE__);

    return -1;
}

static int gsparse_type_global_var_op(struct gsparse_input_pos *, struct gsparsedline *, char **, long);
static int gsparse_type_arg_op(struct gsparse_input_pos *, struct gsparsedline *, char **, long);

static
long
gsparse_type_ops(struct gsparse_input_pos *pos, gsparsedfile *parsedfile, struct gsparsedline *typedirective, struct uxio_ichannel *chan, char *line, char **fields)
{
    static gsinterned_string gssymtyforall, gssymtyexists, gssymtylet, gssymtylift, gssymtyfun, gssymtyref, gssymtysum, gssymtyubsum, gssymtyproduct, gssymtyubproduct;

    struct gsparsedline *parsedline;
    int i;
    long n;

    while ((n = gsgrabline(pos, chan, line, fields)) > 0) {
        parsedline = gsparsed_file_addline(pos, parsedfile, n);

        parsedline->directive = gsintern_string(gssymtypeop, fields[1]);

        if (gsparse_type_global_var_op(pos, parsedline, fields, n)) {
        } else if (gsparse_type_arg_op(pos, parsedline, fields, n)) {
        } else if (gssymceq(parsedline->directive, gssymtyforall, gssymtypeop, ".tyforall")) {
            if (*fields[0])
                parsedline->label = gsintern_string(gssymtypelable, fields[0]);
            else
                gsfatal("%s:%d: Labels required on .tyforall", pos->real_filename, pos->real_lineno);
            if (n < 3)
                gsfatal("%s:%d: Missing kind on .tyforall-bound type variable", pos->real_filename, pos->real_lineno);
            parsedline->arguments[0] = gsintern_string(gssymkindexpr, fields[2]);
            if (n > 3)
                gsfatal("%s:%d: Too many arguments to .tyforall", pos->real_filename, pos->real_lineno);
        } else if (gssymceq(parsedline->directive, gssymtyexists, gssymtypeop, ".tyexists")) {
            if (*fields[0])
                parsedline->label = gsintern_string(gssymtypelable, fields[0])
            ; else
                gsfatal("%s:%d: Labels required on .tyexists", pos->real_filename, pos->real_lineno)
            ;
            if (n < 3)
                gsfatal("%s:%d: Missing kind on .tyexists-bound type variable", pos->real_filename, pos->real_lineno)
            ;
            parsedline->arguments[0] = gsintern_string(gssymkindexpr, fields[2]);
            if (n > 3)
                gsfatal("%s:%d: Too many arguments to .tyexists", pos->real_filename, pos->real_lineno)
            ;
        } else if (gssymceq(parsedline->directive, gssymtylet, gssymtypeop, ".tylet")) {
            if (*fields[0])
                parsedline->label = gsintern_string(gssymtypelable, fields[0]);
            else
                gsfatal("%s:%d: Labels required on .tylet", pos->real_filename, pos->real_lineno);
            if (n < 3)
                gsfatal("%s:%d: Missing type label on .tylet", pos->real_filename, pos->real_lineno);
            parsedline->arguments[0] = gsintern_string(gssymtypelable, fields[2]);
            if (n < 4)
                gswarning("%s:%d: Consider using .tygvar instead", pos->real_filename, pos->real_lineno);
            for (i = 0; 3 + i < n; i++) {
                parsedline->arguments[1 + i] = gsintern_string(gssymtypelable, fields[3 + i]);
            }
        } else if (gssymceq(parsedline->directive, gssymtylift, gssymtypeop, ".tylift")) {
            if (*fields[0])
                gsfatal("%s:%d: Labels illegal on continuation ops", pos->real_filename, pos->real_lineno);
            else
                parsedline->label = 0;
            if (n > 2)
                gsfatal("%s:%d: Too many arguments to .tylift", pos->real_filename, pos->real_lineno);
        } else if (gssymceq(parsedline->directive, gssymtyfun, gssymtypeop, ".tyfun")) {
            if (*fields[0])
                gsfatal("%s:%d: Labels illegal on continuation ops", pos->real_filename, pos->real_lineno);
            else
                parsedline->label = 0;
            if (n < 3)
                gsfatal("%s:%d: Missing argument type to .tyfun", pos->real_filename, pos->real_lineno);
            for (i = 2; i < n; i++)
                parsedline->arguments[i - 2] = gsintern_string(gssymtypelable, fields[i])
            ;
        } else if (gssymceq(parsedline->directive, gssymtyref, gssymtypeop, ".tyref")) {
            if (*fields[0])
                gsfatal("%s:%d: Labels illegal on terminal ops", pos->real_filename, pos->real_lineno);
            else
                parsedline->label = 0;
            if (n < 3)
                gsfatal("%s:%d: Missing referent argument to .tyref", pos->real_filename, pos->real_lineno);
            parsedline->arguments[2 - 2] = gsintern_string(gssymtypelable, fields[2]);
            for (i = 3; i < n; i++)
                parsedline->arguments[i - 2] = gsintern_string(gssymtypelable, fields[i]);
            return 0;
        } else if (gssymceq(parsedline->directive, gssymtysum, gssymtypeop, ".tysum")) {
            if (*fields[0])
                gsfatal("%s:%d: Labels illegal on terminal ops", pos->real_filename, pos->real_lineno);
            else
                parsedline->label = 0;
            if (n % 2)
                gsfatal("%s:%d: Can't have odd number of arguments to .tysum", pos->real_filename, pos->real_lineno);
            for (i = 0; 2 + i < n; i += 2) {
                parsedline->arguments[i] = gsintern_string(gssymconstrlable, fields[2 + i]);
                parsedline->arguments[i + 1] = gsintern_string(gssymtypelable, fields[2 + i + 1]);
            }
            return 0;
        } else if (gssymceq(parsedline->directive, gssymtyubsum, gssymtypeop, ".tyubsum")) {
            if (*fields[0])
                gsfatal("%s:%d: Labels illegal on terminal ops", pos->real_filename, pos->real_lineno);
            else
                parsedline->label = 0;
            if (n % 2)
                gsfatal("%s:%d: Can't have odd number of arguments to .tyubsum", pos->real_filename, pos->real_lineno);
            for (i = 0; 2 + i < n; i += 2) {
                parsedline->arguments[i] = gsintern_string(gssymconstrlable, fields[2 + i]);
                parsedline->arguments[i + 1] = gsintern_string(gssymtypelable, fields[2 + i + 1]);
            }
            return 0;
        } else if (gssymceq(parsedline->directive, gssymtyproduct, gssymtypeop, ".typroduct")) {
            if (*fields[0])
                gsfatal("%s:%d: Labels illegal on terminal ops", pos->real_filename, pos->real_lineno);
            else
                parsedline->label = 0;
            if (n % 2)
                gsfatal("%s:%d: Can't have odd number of arguments to .typroduct", pos->real_filename, pos->real_lineno)
            ;
            for (i = 0; 2 + i < n; i += 2) {
                parsedline->arguments[i] = gsintern_string(gssymfieldlable, fields[2 + i]);
                parsedline->arguments[i + 1] = gsintern_string(gssymtypelable, fields[2 + i + 1]);
            }
            return 0;
        } else if (gssymceq(parsedline->directive, gssymtyubproduct, gssymtypeop, ".tyubproduct")) {
            if (*fields[0])
                gsfatal("%s:%d: Labels illegal on terminal ops", pos->real_filename, pos->real_lineno);
            else
                parsedline->label = 0;
            if (n % 2)
                gsfatal("%s:%d: Can't have odd number of arguments to .tyubproduct", pos->real_filename, pos->real_lineno);
            for (i = 0; 2 + i < n; i += 2) {
                parsedline->arguments[i] = gsintern_string(gssymfieldlable, fields[2 + i]);
                parsedline->arguments[i + 1] = gsintern_string(gssymtypelable, fields[2 + i + 1]);
            }
            return 0;
        } else {
            gsfatal(UNIMPL("%s:%d: Unimplemented type op %s"), pos->real_filename, pos->real_lineno, fields[1]);
        }
    }
    if (n < 0)
        gsfatal("%s:%d: Error in reading type line: %r", pos->real_filename, pos->real_lineno);
    else
        gsfatal("%P: EOF in middle of reading type expression", typedirective->pos);

    return -1;
}

int
gsparse_type_global_var_op(struct gsparse_input_pos *pos, struct gsparsedline *parsedline, char **fields, long n)
{
    static gsinterned_string gssymtygvar, gssymtyextabstype, gssymtyextelimprim, gssymtyextimpprim;

    if (gssymceq(parsedline->directive, gssymtygvar, gssymtypeop, ".tygvar")) {
        if (*fields[0])
            parsedline->label = gsintern_string(gssymtypelable, fields[0]);
        else
            gsfatal("%s:%d: Labels required on .tygvar", pos->real_filename, pos->real_lineno);
        if (n > 2)
            gsfatal("%s:%d: Too many arguments to .tygvar", pos->real_filename, pos->real_lineno);
    } else if (gssymceq(parsedline->directive, gssymtyextabstype, gssymtypeop, ".tyextabstype")) {
        if (*fields[0])
            parsedline->label = gsintern_string(gssymtypelable, fields[0])
        ; else
            gsfatal("%s:%d: Labels required on .tyextabstype", pos->real_filename, pos->real_lineno)
        ;
        if (n < 3) gsfatal("%s:%d: Missing kind on .tyextabstype", pos->real_filename, pos->real_lineno);
        parsedline->arguments[2 - 2] = gsintern_string(gssymkindexpr, fields[2]);
        if (n > 3) gsfatal("%s:%d: Too many arguments to .tyextabstype", pos->real_filename, pos->real_lineno);
    } else if (
        gssymceq(parsedline->directive, gssymtyextelimprim, gssymtypeop, ".tyextelimprim")
        || gssymceq(parsedline->directive, gssymtyextimpprim, gssymtypeop, ".tyextimpprim")
    ) {
        if (*fields[0])
            parsedline->label = gsintern_string(gssymtypelable, fields[0])
        ; else
            gsfatal("%s:%d: Labels required on %y", pos->real_filename, pos->real_lineno, parsedline->directive)
        ;
        if (n < 3)
            gsfatal("%s:%d: Missing primitive set name", pos->real_filename, pos->real_lineno);
        parsedline->arguments[0] = gsintern_string(gssymprimsetlable, fields[2 + 0]);
        if (n < 4)
            gsfatal("%s:%d: Missing primitive type name", pos->real_filename, pos->real_lineno);
        parsedline->arguments[1] = gsintern_string(gssymtypelable, fields[2 + 1]);
        if (n < 5)
            gsfatal("%s:%d: Missing kind on primitive type", pos->real_filename, pos->real_lineno);
        parsedline->arguments[2] = gsintern_string(gssymkindexpr, fields[2 + 2]);
        if (n > 5)
            gsfatal("%s:%d: Too many arguments to %y; expected primset, primname, and kind", pos->real_filename, pos->real_lineno, parsedline->directive)
        ;
    } else {
        return 0;
    }

    return 1;
}

int
gsparse_type_arg_op(struct gsparse_input_pos *pos, struct gsparsedline *parsedline, char **fields, long n)
{
    if (gssymeq(parsedline->directive, gssymtypeop, ".tylambda")) {
        if (*fields[0])
            parsedline->label = gsintern_string(gssymtypelable, fields[0])
        ; else
            gsfatal("%s:%d: Labels required on .tylambda", pos->real_filename, pos->real_lineno)
        ;
        if (n < 3)
            gsfatal("%s:%d: Missing kind on .tylambda", pos->real_filename, pos->real_lineno)
        ;
        parsedline->arguments[2 - 2] = gsintern_string(gssymkindexpr, fields[2]);
        if (n > 3)
            gsfatal("%s:%d: Too many arguments to .tylambda; I only know what the kind is", pos->real_filename, pos->real_lineno)
        ;
        return 1;
    } else {
        return 0;
    }

    return 1;
}

static
long
gsparse_coercion_item(struct gsparse_input_pos *pos, gsparsedfile *parsedfile, struct uxio_ichannel *chan, char *line, char **fields, ulong numfields, struct gsfile_symtable *symtable)
{
    struct gsparsedline *parsedline;

    parsedline = gsparsed_file_addline(pos, parsedfile, numfields);
    parsedfile->coercions->numitems++;

    if (*fields[0])
        parsedline->label = gsintern_string(gssymcoercionlable, fields[0])
    ; else
        gsfatal("%s:%d: Missing type label", pos->real_filename, pos->real_lineno)
    ;

    gssymtable_add_coercion_item(symtable, parsedline->label, parsedfile, parsedfile->last_seg, parsedline);

    parsedline->directive = gsintern_string(gssymcoerciondirective, fields[1]);

    if (gssymeq(parsedline->directive, gssymcoerciondirective, ".tycoercion")) {
        if (numfields > 2 + 0)
            gsfatal("%s:%d: Too many arguments to .tycoercion", pos->real_filename, pos->real_lineno)
        ;
        return gsparse_coerce_ops(pos, parsedfile, parsedline, chan, line, fields);
    } else {
        gsfatal("%s:%d: %s:%d: Unimplemented coercion directive %s", __FILE__, __LINE__, pos->real_filename, pos->real_lineno, fields[1]);
    }

    gsfatal("%s:%d: gsparse_coercion_item next", __FILE__, __LINE__);

    return -1;
}

static int gsparse_coercion_global_var_op(struct gsparse_input_pos *, struct gsparsedline *, char **, long);
static int gsparse_coercion_arg_op(struct gsparse_input_pos *, struct gsparsedline *, char **, long);

long
gsparse_coerce_ops(struct gsparse_input_pos *pos, gsparsedfile *parsedfile, struct gsparsedline *typedirective, struct uxio_ichannel *chan, char *line, char **fields)
{
    struct gsparsedline *parsedline;
    int i;
    long n;

    while ((n = gsgrabline(pos, chan, line, fields)) > 0) {
        parsedline = gsparsed_file_addline(pos, parsedfile, n);

        parsedline->directive = gsintern_string(gssymcoercionop, fields[1]);

        if (gsparse_coercion_global_var_op(pos, parsedline, fields, n)) {
        } else if (gsparse_coercion_arg_op(pos, parsedline, fields, n)) {
        } else if (gssymeq(parsedline->directive, gssymcoercionop, ".tyinvert")) {
            if (*fields[0])
                gsfatal("%s:%d: Labels illegal on continuations");
            else
                parsedline->label = 0;
            if (n > 2)
                gsfatal("%s:%d: Too many arguments to .tyinvert");
        } else if (gssymeq(parsedline->directive, gssymcoercionop, ".tydefinition")) {
            if (*fields[0])
                gsfatal("%s:%d: Labels illegal on terminal op");
            else
                parsedline->label = 0;
            if (n < 2 + 1)
                gsfatal("%s:%d: Missing abstract type to cast to");
            parsedline->arguments[0] = gsintern_string(gssymtypelable, fields[2 + 0]);
            for (i = 0; 2 + i < n; i++)
                parsedline->arguments[i] = gsintern_string(gssymtypelable, fields[2 + i]);
            return 0;
        } else {
            gsfatal("%s:%d: %s:%d: Unimplemented coercion op %s", __FILE__, __LINE__, pos->real_filename, pos->real_lineno, fields[1]);
        }
    }
    if (n < 0)
        gsfatal("%s:%d: Error in reading type line: %r", pos->real_filename, pos->real_lineno)
    ;
    else
        gsfatal("%P: EOF in middle of reading type expression", typedirective->pos)
    ;

    return -1;
}

int
gsparse_coercion_global_var_op(struct gsparse_input_pos *pos, struct gsparsedline *parsedline, char **fields, long n)
{
    if (gssymeq(parsedline->directive, gssymcoercionop, ".tygvar")) {
        if (*fields[0])
            parsedline->label = gsintern_string(gssymtypelable, fields[0]);
        else
            gsfatal("%s:%d: Labels required on .tygvar", pos->real_filename, pos->real_lineno);
        if (n > 2)
            gsfatal("%s:%d: Too many arguments to .tygvar", pos->real_filename, pos->real_lineno);
    } else if (gssymeq(parsedline->directive, gssymcoercionop, ".tyextabstype")) {
        if (*fields[0])
            parsedline->label = gsintern_string(gssymtypelable, fields[0])
        ; else
            gsfatal("%s:%d: Labels required on .tyextabstype", pos->real_filename, pos->real_lineno)
        ;
        if (n < 3) gsfatal("%s:%d: Missing kind on .tyextabstype", pos->real_filename, pos->real_lineno);
        parsedline->arguments[2 - 2] = gsintern_string(gssymkindexpr, fields[2]);
        if (n > 3) gsfatal("%s:%d: Too many arguments to .tyextabstype", pos->real_filename, pos->real_lineno);
    } else {
        return 0;
    }

    return 1;
}

int
gsparse_coercion_arg_op(struct gsparse_input_pos *pos, struct gsparsedline *parsedline, char **fields, long n)
{
    if (gssymeq(parsedline->directive, gssymcoercionop, ".tylambda")) {
        if (*fields[0])
            parsedline->label = gsintern_string(gssymtypelable, fields[0])
        ; else
            gsfatal("%s:%d: Labels required on .tylambda", pos->real_filename, pos->real_lineno)
        ;
        if (n < 3)
            gsfatal("%s:%d: Missing kind on .tylambda", pos->real_filename, pos->real_lineno)
        ;
        parsedline->arguments[2 - 2] = gsintern_string(gssymkindexpr, fields[2]);
        if (n > 3)
            gsfatal("%s:%d: Too many arguments to .tylambda; I only know what the kind is", pos->real_filename, pos->real_lineno)
        ;
        return 1;
    } else {
        return 0;
    }

    return 1;
}

/* Loader */

static
void
gsload_scc(gsparsedfile *parsedfile, struct gsfile_symtable *symtable, struct gsbc_scc *pscc, struct gspos *pentrypos, gsvalue *pentry, struct gstype **ptype)
{
    struct gsbc_scc *p;
    struct gsbc_item items[MAX_ITEMS_PER_SCC];
    struct gstype *types[MAX_ITEMS_PER_SCC], *defns[MAX_ITEMS_PER_SCC];
    struct gskind *kinds[MAX_ITEMS_PER_SCC];
    gsvalue heap[MAX_ITEMS_PER_SCC];
    struct gsbco *bcos[MAX_ITEMS_PER_SCC];
    int n, i;

    n = 0;

    for (p = pscc; p; p = p->next_item) {
        if (n >= MAX_ITEMS_PER_SCC)
            gsfatal("%P: Too many items in this SCC; max 0x%x", p->item.v->pos, MAX_ITEMS_PER_SCC)
        ;
        items[n++] = p->item;
    }

    /* ยงsection Type-checking */

    gstypes_process_type_declarations(symtable, items, kinds, n);
    gstypes_compile_types(symtable, items, types, n);
    gstypes_compile_type_definitions(symtable, items, defns, n);
    gstypes_kind_check_scc(symtable, items, types, defns, kinds, n);
    gstypes_process_type_signatures(symtable, items, ptype, n);
    gstypes_type_check_scc(symtable, items, types, kinds, ptype, n);

    /* ยงsection Byte-compilation */

    gsbc_alloc_data_for_scc(symtable, items, heap, n);
    gsbc_alloc_code_for_scc(symtable, items, bcos, n);
    gsbc_bytecompile_scc(symtable, items, heap, bcos, n);

    if (pentry) {
        for (i = 0; i < n; i++) {
            if (
                items[i].type == gssymdatalable
                && items[i].v == GSDATA_SECTION_FIRST_ITEM(parsedfile->data)
            ) {
                *pentrypos = items[i].v->pos;
                if (heap[i])
                    *pentry = heap[i];
                else
                    gsfatal_unimpl(__FILE__, __LINE__, "%s: Entry point: couldn't find in any SCC");
                if (items[i].v->label) {
                    gsfatal_unimpl(__FILE__, __LINE__, "%P: set *ptype", items[i].v->pos);
                } else
                    /* Don't have to save ยงc{*ptype} in this case, because we handle that while doing the initial type-checking */
                ;
                goto have_entry;
            }
        }
        gsfatal("%s: Couldn't find entry point", parsedfile->name->name);
    have_entry:
        ;
    }
}
\end{verbatim}

\bibliography{citations}
\bibliographystyle{plain}

\end{document}
