\documentclass{article}
\title{Global Script String Code Specification}
\author{Jonathan Cast\\\texttt{<jcast@globalscript.org>}}

\usepackage{bussproofs}
\usepackage{haskell}

\newcommand\sequent\vdash
\newcommand\bs{$\backslash$}

\newcommand\ccode[1]{\texttt{#1}}
\newcommand\stringcode[1]{\texttt{#1}}
\newcommand\shellcode[1]{\texttt{#1}}

\newcommand\unimpl[1]{\footnote{\textbf{Unimplemented: }#1}}
\newcommand\agsonly[1]{\footnote{\textbf{\texttt{.ags}-only: }#1}}

\newcommand\abstype{\hskwd{abstype}}
\newcommand\primtype{\hskwd{primtype}}

\begin{document}

\maketitle

\section{Organization of a Program}

Global Script programs are organized into a \emph{prefix},
contained in some number of \emph{prefix files},
 and a \emph{document}, contained in a single \emph{document file}.
Essentially, prefix files contain library code, whereas document files contain code specific to a single program.
At the source level, each prefix file consists of a single \emph{prefix generator};
a document file consists of an expression
--- the program's entry point or `\ccode{main}' ---
and an optional $\hskwd{where}$ clause.
For various reasons, string code syntax flattens both prefix and document files out into a sequence of \emph{items}.

\section{Layout of a String Code File}

\subsection{Lexical Syntax}

\begin{itemize}
    \item Each line consists of a sequence of fields separated by whitespace.

    \item Lines may optionally be terminated by the character \stringcode{\#}, which begins a comment.

    \item String constants and character constants are un-quoted and may contain the standard C escapes as well as
        \stringcode{\bs{}s}, which represents an ASCII space,
        \stringcode{\bs{}h}, which represents a \stringcode{\#} character,
        and a syntax for writing arbitrary UTF coding units using ASCII characters.
        \unimpl{String and character literals are un-implemented.}
        \agsonly{String literals are only supported for simplifying hand-written string code, for bootstrapping.}

    \item If a line begins with whitespace, field 0 of that line is the empty string;
        any run of linear whitespace is equivalent to a signle space and whitespace at the end of the line is ignored,
        so empty fields are not possible except for field 0.

    \item Lines consisting exclusively of whitespace and/or comments are ignored.

    \item In general, field 0 of any line will be referred to as the \emph{label};
        field 1 will be variously referred to as the \emph{directive} or the \emph{op}.
        Labels of width 0 will be referred to as \emph{missing};
        labels may be required or forbidden, depending on the op.
        Any non-blank non-comment line must contain a field 1;
        additional fields may be required or permitted depending on the directive or op;
        they will be referred to as the \emph{arguments}.
\end{itemize}

\section{Types}

Free variables are handled by having type $\lambda$ nodes, and allowing
\begin{verbatim}
tv	.tylet	tf	x	y	z
\end{verbatim}
in type items, with arguments implemented by doing $\beta$-reduction directly on type trees.

So we need to `apply' two kinds of things: \<\abstype\>s/\<\primtype\>s, and type functions.
These are different things.
No binary application at the type-level.
\begin{verbatim}
x	.tylet	tau	alpha	beta	gamma	# Apply to expression
	.tyref	tau	alpha	beta	gamma	# Apply to prim/abs
\end{verbatim}
In certain kinds of type declarations, the second kind of application is also permitted:
\begin{verbatim}
x	.fv	tau	alpha	beta	gamma
x	.arg	tau	alpha	beta	gamma
\end{verbatim}
if \verb+tau+ is an abstract or primitive type, but
\begin{verbatim}
t	.tylet	tau	alpha	beta	gamma
x	.fv	t
x	.arg	t
\end{verbatim}
if \verb+tau+ is a type expression.

In both cases, the argument is declared in the type item using \verb+.tylambda+:
\begin{verbatim}
t	.tylambda	*
\end{verbatim}

\section{API Block Statements}

These are similar to expressions;
in fact, the data items use \verb+.closure+ like expressions do;
only the code items are different.

In Core, a block statement looks like
\begin{haskell}
    \hskwd{for}\;@(\hskwd{type} \hsinf{type}) \hsinf{gens}. \hsinf{body}
\end{haskell}
or
\begin{haskell}
    \hskwd{for}\;\hskwd{rec}\;@(\hskwd{type} \hsinf{type}) \hsinf{gens}. \hsinf{body}
\end{haskell}
The generators look like
\begin{haskell*}
    \hsinf{var} & = & \hsinf{expr}; \hscom{Let} \\
    \lfloor\hsinf{var}\rfloor & \propto & \hsinf{expr}; \hscom{Strict let} \\
    \hsinf{var} & \leftarrow & \hsinf{expr}; \hscom{Bind} \\
\end{haskell*}
; the body is an expression.

String code only permits `let' generators at lifted types and `bind' generators in its `API block statement' construct;
the others are compiled to \verb+.expr+s.
\footnote{
    Unlifted `let' generators and `strict let' generators bind variables of unlifted types,
    and so cannot participate in recursion,
    \emph{including forward references to bind generators}.
    NB: That's not entirely true --- variables of unlifted but pointed type, like unlifted function types,
    \emph{can} be recursively defined --- need to think about that more.
}

A block statement gets compiled to either a \verb+.prog+ or a \verb+.eprog+ block;
technically, \verb+.eprog+ should be used for block statements beginning with
let generators or
bind generators with non-HNF RHSs;
these should technically be reduxes,
and only a block statement beginning with a bind generator with a non-\<unit\> RHS
or a let generator with a forward reference to/past such a bind generator should be considered a WHNF.
Probably we're going to ignore that for now.

The syntax is
\begin{verbatim}
label	.prog	primset	primtype
\end{verbatim}
or
\begin{verbatim}
label	.eprog	primset	primtype
\end{verbatim}
That is followed by global variables, free variables, and arguments as for a \verb+.expr+.

`Let' generators get compiled to
\begin{verbatim}
var	.alloc	code-label	fvs
\end{verbatim}
`Bind' generators get compiled to
\begin{verbatim}
var	.bind	code-label	fvs
\end{verbatim}
The body gets compiled to
\begin{verbatim}
	.body	code-label	fvs
\end{verbatim}

Another complication is that, in the expression \<\hskwd{for} @(\hskwd{type} m) x \leftarrow e_0. e_1\>,
we have three possibilities for the types of \<e_0\> and \<e_1\>:
\footnote{We assume that \<e_1\> has the same type as the expression as a whole.}
\begin{enumerate}
    \item \<e_0 :: m \alpha\>, \<e_1 :: m \beta\>;
    \item \<e_0 :: m \alpha \>, \<e_1 :: \lfloor m \beta \rfloor\>; or
    \item \<e_0 :: \lfloor m \alpha \rfloor\>, \<e_1 :: \lfloor m \beta \rfloor\>.
    \footnote{
        If the whole expression has an unlifted type, \<e_0\> cannot have a lifted type,
        since \<\hskwd{for}\;@(\hskwd{type}\;m)\;x \leftarrow [].\;e_1\> is an evaluation context.
    }
\end{enumerate}

There's no real difference between the implementation of these possibilities, though,
so we can dis-regard them when compiling to string code.

\section{\stringcode{.regex} Literals}\agsonly{Regex literals are only supported for simplifying hand-written string code, for bootstrapping.}

We have interpolation support in string code regex literals.
To use, put \stringcode{ยง} (with no name) in the literal
and then follow the literal with the variable to use for each interpolation:
\begin{verbatim}
foo.re .regex ยง|ยง _foo.re_long.expression.1.re _foo_re_long.expression.2.re
_foo.re_long.expression.1.re .regex long|complicated\sexpression
...
\end{verbatim}

You can interpolate any top-level data item, not just \stringcode{.regex} literals.

\stringcode{.regex} won't support any grouping operator,
so interpolation will be the only way to override the default precedence order.
Interpolations aren't supported inside classes yet but they will be.

\end{document}
