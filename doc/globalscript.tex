\documentclass{report}
\title{Global Script Program Calculus}
\author{Jonathan Cast}

\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{mathabx}
\usepackage{MnSymbol}
\usepackage{bussproofs}
\usepackage{haskell}

\newcommand\sequent\vdash
\newcommand\provides\rhd
\newcommand\match\propto

\hscommand\from{\leftarrow}

\newcommand\type{\hskwd{type}}
\newcommand\module{\hskwd{module}}
\newcommand\view{\hskwd{view}}
\newcommand\analyze{\hskwd{analyze}}
\newcommand\case{\hskwd{case}}
\hscommand\for{\hskwd{for}}
\newcommand\gslambda{\hskwd{\lambda}}
\hscommand\where{\hskwd{where}}
\hscommand\rec{\hskwd{rec}}
\hscommand\macro{\hskwd{macro}}
\hscommand\error{\hskwd{error}}

\hscommand\reduceto{:\!\!-}

\hscommand\lift[1]{\lfloor#1\rfloor}
\hscommand\emdash{\text{---}}

\newcommand\inlinelambda[2]{\gslambda\ #1. #2}
\hscommand\inlinefor[2]{\for\ #1.\ #2}
\hscommand\inlinetuple[1]{\llangle #1 \rrangle}
\hscommand\inlinewhere[1]{\where\hsbody{\hsalign{#1}}}

\newcommand\blockanalyze[2]{\analyze\ #1.\hsbody{\hsalign{#2}}}
\newcommand\blocklambda[2]{\gslambda\ #1. \hsbody{\hsalign{#2}}}
\hscommand\blockfor[2]{\for\ (#1)\hsbody{\hsalign{#2}}}
\hscommand\blockwhere[1]{(\where\hsbody{\hsalign{#1}})}

\hscommand\structure[1]{\langle\hsbody{#1}\rangle}

\hscommand\pvar[1]{'\!#1}
\hscommand\pview[1]{\(\text{#1}\)}

\newcommand\qq[1]{qq\{\text{\texttt{#1}}\}}
\newcommand\str[1]{\(str\{\text{#1}\}\)}
\newcommand\omode[1]{\(o/\text{\texttt{#1}}/\)}
\hscommand\matchre[1]{\(m/\text{#1}/\)}

\hscommand\ifrom{<\!<}

\newcommand\defn[1]{\emph{#1}}

\newcommand\chapterref[1]{Chapter \ref{#1}}
\newcommand\sectionref[1]{Section \ref{#1}}

\newcommand\implicit{\hskwd{implicit}}

\newcommand\kwd[1]{\textbf{#1}}

\newcommand\sh[1]{\texttt{#1}}

\hscommand\diverges{\uparrow}
\hscommand\fails{\downarrow}
\hscommand\Den[1]{Den\ldbrack#1\rdbrack}
\hscommand\Pat[1]{\mathbb{P}\ldbrack#1\rdbrack}
\hscommand\Expr[1]{\mathbb{E}\ldbrack#1\rdbrack}
\hscommand\Type[1]{\mathbb{T}\ldbrack#1\rdbrack}
\hscommand\Kind[1]{\mathbb{K}\ldbrack#1\rdbrack}

\begin{document}

\maketitle

\tableofcontents

\chapter{Introduction}

This document specifies the \defn{Global Script Program Calculus}, a purely-functional, completely machine-independent program calculus designed to support the Global Script Type-Setting System.

\section{Excursus on the Term `Programming Language'}

The term `programming language' has an odd, and in the opinion of the developer of this system deleterious, definition in normal usage.
`Programming language' clearly derives from the verb `program', (rather than the noun);
it does not mean `language that is engaged in programming', so it must mean `language for the act of programming'.
But the verb `program' is a transitive verb: `program the i686 processor', `program the fuel injection system', `program the accounting system', etc.
To \defn{program} a machine is to make it do what the programmer wishes;
the act of programming makes no sense except in reference to a machine.
So `machine-independent programming language' is, properly speaking, a nonsensical concept.

Originally, it simply meant `programming language which targets multiple machines'
(or, usually rather, `family of programming languages indexed by multiple machines'),
which really means (if it means anything) `programming language which targets a family of machines sharing similar capabilities'.
Typically this class of machines encompases most of the machines typically encountered by programmers
(but not most programmable machines in use!),\footnote{Most software is actually embedded software, which lacks access to the familiar keyboard / screen / mouse facilities assumed by the typical definition of `general-purpose' language.}
so the myth has grown up that typical languages `support all computers';
and even that languages lacking I/O facilities are not Turing-complete!\footnote{The Intercal manual (implicitly) makes this claim.}

Meanwhile, `programming language' has come to mean something like what this document intends by `program calculus':
methods for algorithmic computation, variable naming, function definition, program partitioning, etc.
I/O `isn't part of the language' or `shouldn't be part of the language' (!).\footnote{Thus excluding denotational semantics from `the language'\ldots.}
The problem with this position\footnote{Beyond the fact that you can't interpret I/O operations in an arbitrary model of a language that lacks them!}
is that it justifies the neglect of I/O that programming language designers have traditionally lavished on it.
Almost every language has genuinely wretched I/O facilities,
precisely because of the second-class status assigned to I/O by the concept of the `general-purpose programming language'.
Global Script thus includes I/O in `the language', not only because that is the only way to give a denotation for I/O,
but because I/O deserves the same careful design as any other aspect of the language.
The Global Script Program Calculus is thus a genuine programming language (to wit, environment-dependent and I/Oful)
stripped of its environment-specific and I/O-related facilities.
In fact, because the calculus and the I/O system are so largely orthogonal, it is several (distinct) languages so stripped of their environmental facilities;
the list includes at least:
\begin{itemize}
    \item Global Script Log --- a logical markup language;
    \item Global Script Set --- a page description language;
    \item Global Script Type --- ditto, but for line printers;
    \item IBIO --- a concurrent stream I/O language, suitable for writing Unix filters (and, although not designed for them, compilers);
    \item Cord --- a relational database language; and
    \item Dance --- an FRP GUI language.
\end{itemize}
These share the same calculus; the type system distinguishes between the operations of different languages.
An implementation of one language \emph{simpliciter} never need link in an implementation of any of the others.

\chapter{Syntax}

\chapter{Type System}

Global Script has a standard natural deduction-based type system, based on \defn{judgment}s of the form
\begin{displaymath}
    \Gamma \sequent \text{conclusion}
\end{displaymath}
The context \<\Gamma\> several classes of variables (type variables, object variables, views, etc.) to various sorts of meta-data (kinds, types, implicit arguments, macro properties, etc.).
Nevertheless, the context will generally be treated as a single object, except in the denotational semantics,
where it will be split into a kind context \<\Delta\> and a type context \<\Gamma\>.

\chapter{Models and Denotations}

Note: `semantics' means `meaning'; specifically, the kind of detailed meaning that might be found in a language specification.
`Denotation' means `meaning'; specifically, the kind of formal meaning that might be found in a language specification.
So `denotational semantics' is redundant.
End note.

A \defn{model} of Global Script is a (directed-)complete partial order-enriched category $\mathcal{C}$ with:
\begin{itemize}
    \item Finite products indexed by sets of Global Script identifiers (note that this implies in particular the existence of a terminal object \<\star\>);
    \item Finite coproducts indexed by sets of Global Script identifiers (note that this implies in particular the existence of an initial object \<\epsilon\>);
    \item Exponentials;
    \item An existential quantifier, which is a functor $\exists : \mathcal{C}^\kappa \to \mathcal{C}$, which is the left adjoint of the constant functor $K : \mathcal{C} \to \mathcal{C}^\kappa$, for $\kappa$ at least the denotations of the kind environments as defined below; and
    \item A universal quantifier, which is a functor $\forall : \mathcal{C}^\kappa \to \mathcal{C}$ which is the right adjoint of of the constant functor $K : \mathcal{C} \to \mathcal{C}^\kappa$, for $\kappa$ at least the denotations of the kind environments as defined below;
\end{itemize}
together with a designated \defn{lifting monad}, which is a monad \<\lift{\emdash}\> on $\mathcal{C}$ together with a natural transformation $\bot : K\star \to \lift{\emdash}$ so that $\bot_\alpha \circ \star_\beta$ is the least homomorphism $: \beta \to \lift{\alpha}$ for all objects $\alpha$, $\beta$.

Note: we need a couple of other things:
\begin{itemize}
    \item A `strength' $: \exists (K\alpha \times F) \to \alpha \times \exists F$;
    \item A way to `lift' $\exists$ and $\forall$ to functors with more than one argument (eliminating only the last one).
\end{itemize}
These seem like they should be definable in any category, though.
TODO: Will need to confirm / deny that.

For the purpose of the denotational semantics, contexts will be divided into two pieces:
a kind environment $\Delta$ and a type environment $\Gamma$.
The kind environment $\Delta$ can be thought of as a mapping from type variables to kinds;
the denotation of a kind is a category, and the denotation of a type environment $\Delta$, written $\Den{\Delta}$, is
\begin{displaymath}
    \prod_{t\in Dom\Delta}\Kind{\Delta(t)}
\end{displaymath}
The denotation of the type environment $\Gamma$, which will be written $\Den{\lambda\Delta.\Gamma}$, will be a functor $F : \Den{\Delta} \to \mathcal{C}$.

\chapter{Equational Theory}

\chapter{Operational Model}

\chapter{Implementations}

\chapter{Object Expressions}

The judgment form for an expression $e$ in context $\Gamma$ is
\begin{equation}
    \Gamma \sequent e :: \tau
\end{equation}
for some type $\tau$.

The denotation of an expression will be a natural transformation $\Expr{\Delta, \Gamma \sequent e :: \tau} : \Den{\lambda\Delta.\Gamma} \to \Type{\lambda\Delta.\tau}$.

\section{Variables}
\label{sec:variables}

The judgment form for a variable \<v\> in context \<\Gamma\> is
\begin{equation}\label{eqn:var-judgment}
    \Gamma \sequent v :: \overline{\tau_i :: \kappa_i}_{i=0}^{n-1}; \overline{a_j :: \tau_j}_{j=n}^{n+m-1}; \tau
\end{equation}.
\begin{itemize}
    \item $\overline{\tau_i :: \kappa_i}_{i=0}^{n-1}$ is a sequence of \defn{default type arguments} and their kinds,
    \item $\overline{a_j :: \tau_j}_{j=n}^{n+m-1}$ is a sequence of \defn{default arguments} and their types, and
    \item $\tau$ is the (monomorphic) type of the variable term.
\end{itemize}
The meta-variable \<v\> can stand for a simple identifier (this case will be written \<x\>, \<x_i\>, etc.), or for an application (see below).

A variable has no denotation, but see section \ref{subsec:var-exprs} below.

\subsection{Variables Without \kwd{implicit} Declarations}

\begin{prooftree}
    \AxiomC{$\Gamma \sequent \overline{\tau_i :: \kappa_i}$}
    \UnaryInfC{
        \<\Gamma, x :: \forall\;\overline{'\alpha_i :: \kappa_i}. \tau \sequent x :: \overline{\tau_i :: \kappa_i}; ; \tau'\>
    }
\end{prooftree}
\begin{itemize}
    \item $i \in [0, n)$;
    \item $\Gamma$ does not contain an \<\implicit\> declaration for $x$;
    \item $\tau'$ means $[\overline{\alpha_i\to\tau_i}]\tau$,
        the result of substituting the type arguments for the $\forall$-bound variables in $\tau$.
\end{itemize}

\subsection{Variables With \kwd{implicit} Declarations}

\begin{prooftree}
    \AxiomC{$\Gamma \sequent \overline{\tau_i :: \kappa_i}$}
    \AxiomC{$\Gamma \sequent \overline{e_j :: \tau'_j}$}
    \BinaryInfC{
        \<\Gamma, x :: \forall\;\overline{'\alpha_i :: \kappa_i}. \overline{\tau_j} \to \tau, \implicit\;x\;\overline{e_j} \sequent x :: \overline{\tau_i :: \kappa_i}; \overline{e_j :: \tau'_j}; \tau'\>
    }
\end{prooftree}
\begin{itemize}
    \item $i \in [0, n)$, $j \in [n, n + m)$;
    \item $\tau'_j$ means $[\overline{\alpha_i\to\tau_i}]\tau_j$,
        the result of substituting the type arguments for the $\forall$-bound variables in $\tau_j$;
    \item $\tau'$ means $[\overline{\alpha_i\to\tau_i}]\tau$,
        the result of substituting the type arguments for the $\forall$-bound variables in $\tau$.
\end{itemize}

\subsection{Explicit Type Applications}

\begin{prooftree}
    \AxiomC{$\Gamma \sequent v :: \tau_0 :: \kappa_0, \overline{\tau_i :: \kappa_i}; \overline{e_j :: \tau_j}; \tau$}
    \UnaryInfC{
        \<\Gamma \sequent v\;@(\type\;\tau_0) :: \overline{\tau_i :: \kappa_i}; \overline{e_j :: \tau_j}; \tau\>
    }
\end{prooftree}
($i \in [1, n)$, $j \in [n, n + m)$).

\subsection{Explicit Applications}

\begin{prooftree}
    \AxiomC{$\Gamma \sequent v :: \overline{\tau_i :: \kappa_i}; e_n :: \tau_n, \overline{e_j :: \tau_j}; \tau$}
    \AxiomC{$\Gamma \sequent e :: \tau_n$}
    \BinaryInfC{
        $\Gamma \sequent v\;@e :: \overline{\tau_i :: \kappa_i}; \overline{e_j :: \tau_j}; \tau$
    }
\end{prooftree}
($i \in [1, n)$, $j \in [n + 1, n + m)$).

\subsection{Variables Used as Expressions}
\label{subsec:var-exprs}

\begin{prooftree}
    \AxiomC{$\Gamma \sequent v :: \overline{\tau_i :: \kappa_i}; \overline{e_j :: \tau_j}; \tau$}
    \UnaryInfC{$\Gamma \sequent v :: \tau$}
\end{prooftree}
($i \in [1, n)$, $j \in [n, n + m)$).

\subsection{TODOs}

\begin{itemize}
    \item Really shouldn't require explicit arguments to be well-typed unless they end up being used.
\end{itemize}

\section{Functions}

\subsection{Function Literals}

Lambda terms have the rule:\footnote{See \chapterref{patterns}, Patterns}
\begin{prooftree}
    \AxiomC{$\Gamma \sequent p :: \tau_1 \provides \Gamma'$}
    \AxiomC{$\Gamma, \Gamma', \sequent e :: \tau_2$}
    \BinaryInfC{$\Gamma \sequent \lambda{} p. e :: \tau_1 \to \tau_2$}
\end{prooftree}
The pattern $p$ must be a lax or strict (not monoidal) pattern; see \sectionref{pattern-classes}, Classes of Patterns.
BUG: $\lambda$ takes \emph{multiple} patterns (0 or more).
End BUG.

\subsection{Applications}

Applications have the rule:
\begin{prooftree}
    \AxiomC{$\Gamma \sequent e_1 :: \tau_1 \to \tau_2$}
    \AxiomC{$\Gamma \sequent e_2 :: \tau_1$}
    \BinaryInfC{$\Gamma \sequent e_1\hsap e_2 :: \tau_2$}
\end{prooftree}

\section{\kwd{for} Expressions}

\<\for\> expressions are used to make local definitions within an expression.
The syntax is \<\inlinefor{\hsinf{generators}}{\hsinf{body expression}}\>.
The generators in a \<\for\> are non-recursive, but cannot shadow variables defined in the same \<\for\>.

In the simplest case, the generators in a \<\for\> are all let and (non-monoidal) match generators.
\begin{prooftree}
    \AxiomC{\<\Gamma \sequent \overline{g_i} \provides \Gamma'\>}
    \AxiomC{\<\Gamma, \Gamma', \sequent e :: \tau\>}
    \BinaryInfC{\<\Gamma \sequent (\inlinefor{\overline{g_i}}{e}) :: \tau\>}
\end{prooftree}

\<\for\> can also be used to name intermediate values inside a monad.
E.g. \<\inlinefor{'x \from e_0}{e_1}\>.
The type rule for this is
\begin{prooftree}
    \AxiomC{\<\Gamma \sequent \module\;monad.c\;m\>}
    \AxiomC{\<\Gamma \sequent \overline{g_i} \provides_m \Gamma'\>}
    \AxiomC{\<\Gamma, \Gamma', \sequent e :: m\;\tau\>}
    \TrinaryInfC{\<\Gamma \sequent \inlinefor{\overline{g_i}}{e} :: m\;\tau\>}
\end{prooftree}

As might be expected, the monad structure to use in de-sugaring this syntax can be over-ridden:
\begin{prooftree}
    \AxiomC{\<\Gamma \sequent mon :: monad.t\;m\>}
    \AxiomC{\<\Gamma \sequent \overline{g_i} \provides_m \Gamma'\>}
    \AxiomC{\<\Gamma, \Gamma', \sequent e :: m\;\tau\>}
    \TrinaryInfC{\<\Gamma \sequent \for\;@{}mon\;(\overline{g_i})\;e :: m\;\tau\>}
\end{prooftree}

The sequence of generators inside the \<()\> in a \<\for\> can either be a single generator or a sequence of 0 or more generators terminated by semi-colons.
In the special case of a single \<\rec\> generator, the syntax \<\for\;(\rec(\overline{g_i}))\> can be abreviated to \<\for\;\rec\;(\overline{g_i})\>.

\section{Branch Expressions}

An \<\analyze\> expression,
Syntactically, \<\analyze\ \overline{expr_i} \overline{\case\ \overline{p_{ji}}. body_j}\>,
takes a sequence of scrutinee expressions and matches them against the patterns in the cases,
top-to-bottom and left-to-right.
If matching a scrutinee against any pattern diverges or no case matches evaluation diverges;
otherwise the \<\analyze\> expression evaluates to the body of the first matching case.
Note: if a case matches and matching the scrutinees against the patterns in a previous case diverges,
evaluation diverges.
If a case matches and matching the scrutinees against a subsequent case diverges,
the evaluation proceeds with the body of the matching case.

This syntax has a `dangling else' problem when a \<\case\> ends with an \<\analyze\> expression;
this is resolved as usual by associating each \<\case\> to the nearest preceding \<\analyze\> expression.
This resolution can be over-ridden by putting parentheses around the inner \<\analyze\> expression or its enclosing \<\case\>.

\subsection{Cases}

The judgment form for \<\case\> terms is:
\begin{haskell}
    \Gamma;  \sequent \case\ \overline{p_i}. e :: \overline{\tau_i} \rightarrow \tau
\end{haskell}

Single cases type thus:

\begin{prooftree}
    \AxiomC{$\Gamma \sequent \tau :: *$}
    \AxiomC{$\Gamma \sequent e :: \tau$}
    \BinaryInfC{$\Gamma \sequent \case.\;e ::\;\rightarrow\ \tau$}
\end{prooftree}

\begin{prooftree}
    \AxiomC{$\Gamma \sequent \tau :: *$}
    \AxiomC{$\Gamma \sequent p_0 :: \tau_0 \rhd \Gamma'$}
    \AxiomC{$\Gamma, \Gamma', \sequent \case\;\overline{p_i}.\;e :: \overline{\tau_i} \rightarrow \tau$}
    \TrinaryInfC{$\Gamma \sequent \case\;p_0,\;\overline{p_i},.\;e :: \tau_0,\;\overline{\tau_i}, \rightarrow \tau$}
\end{prooftree}
NB: \<p_0, \overline{p_i}\> should define disjoint sets of variables.
This has implications.
The principle is --- hrm.
So we have a can-be-bound-by set for a pattern --- in a context --- and then an is-bound-by function for sequences/sets of patterns.
Usually these are the same.
However, certain patterns do \emph{not} bind variables that can be bound by other patterns (whether they are or not).
But that all goes in the Patterns chapter (Chapter \ref{patterns}).

\chapter{Patterns}
\label{patterns}

The judgment form for patterns is
\begin{equation}
    \Gamma \sequent \overline{p_i :: \tau_i} \provides \Gamma'
\end{equation}

\section{Concatenating Sequences of Patterns}

\begin{prooftree}
    \AxiomC{$\Gamma \sequent \overline{p_i :: \tau_i} \provides \Gamma'_1$}
    \AxiomC{$\Gamma \sequent \overline{p_j :: \tau_j} \provides \Gamma'_2$}
    \BinaryInfC{$\Gamma \sequent \overline{p_i :: \tau_i}, \overline{p_j :: \tau_j}, \provides \Gamma'_1, \Gamma'_2,$}
\end{prooftree}
($i \in [0, n)$, $j \in [n, n+m)$).
The bound variables of the patterns must all be distinct.
TODO: need a way to handle module patterns \<\module\;'m\>,
for which the bound variables are selected to be distinct from any other patterns in the same sequence.
The rule is basically: calculate the set of variables which \emph{could} be bound by any given pattern.
Then each \<\module\;'m\> pattern brings into scope those variables which could be bound by it,
and which cannot be bound by any other pattern.
This only applies to $\module$ patterns with no export list,
or whose export list contain $..$ .  See \chapterref{modules}, Modules.
End TODO.

\section{Classes of Patterns}
\label{pattern-classes}

\begin{itemize}
    \item \defn{Lax} patterns are precisely these:
        \begin{itemize}
            \item Pattern variables \<'x\>;
            \item Wildcard patterns \<\_\>;
            \item Module patterns where:
                \begin{itemize}
                    \item there is no export list, e.g. \<\module\;'m\>,
                    \item there is a simple export list, e.g. \<\module\;'m.(x, y, z,)\>,
                    \item there is a complex export list,
                        e.g. \<\module\;'m.\left(\hsalign[c]{x = p_0,\\y = p_1,\\z = p_2,}\right)\>,
                        where all of the patterns given for the members are themselves lax;
                    \end{itemize}
                \item Lazy patterns \<\sim{}\!p\>; and
                \item Parallel patterns \<\parallel\!p\>.
        \end{itemize}
    \item \defn{Strict} patterns are precisely those patterns of the form \<!p\>.
    \item \defn{Monoidal} patterns are precisely those patterns that are neither lax nor strict.
\end{itemize}

\section{Specific patterns}

\paragraph{Pattern variables}
Pattern variables have the syntactic form \<'x\>, the ASCII apostrophe followed by a variable name.
Pattern variables where the variable is an infix operator need to be enclosed in parentheses, e.g., \<('+)\>
\begin{prooftree}
    \AxiomC{$\Gamma \sequent \tau :: *$}
    \UnaryInfC{$\Gamma \sequent\; 'x :: \tau \provides x :: \tau$}
\end{prooftree}

\paragraph{Wildcard Patterns}
\begin{prooftree}
    \AxiomC{$\Gamma \sequent \tau :: *$}
    \UnaryInfC{$\Gamma \sequent \_ :: \tau \provides$}
\end{prooftree}

\paragraph{Views}
The typing judgment for views has the form $\Gamma \sequent \view\;v :: \overline{\tau_i}; \tau$, for $i \in [0, n)$.
This means:
\begin{itemize}
    \item $v$ is a view,
    \item $v$ has arrity $n$,
    \item $v$'s arguments have types $\tau_i$, respectively, and
    \item $v$'s result has type $\tau$.
\end{itemize}
Note that, if $v$ is both a view and a function, \emph{it need not have the same type in both cases}.
Nor, if it does have the same type, need its definition as a view and as a function have any specific relation.
Nevertheless giving them the same type and relating the definitions in some (documented) way is strongly recommended.
Global Script does not draw a distinction between constructors and views.
\begin{prooftree}
    \AxiomC{$\Gamma \sequent \view\;v :: \overline{\tau_i}; \tau$}
    \AxiomC{$\Gamma \sequent \overline{p_i :: \tau_i} \provides \Gamma'$}
    \BinaryInfC{$\Gamma \sequent v\;\overline{p_i} :: \tau \provides \Gamma'$}
\end{prooftree}
TODO: How do you declare views?  How do views and constructors interract, exactly? End TODO.

TODO: Existential types.  End TODO.

Language TODO: Expression arguments to views (e.g., \<n+m\> patterns).  End TODO.

\section{Reasoning at the Source Level}

Source-level reasoning about programs uses three predicates:
\begin{itemize}
    \item \<p \match e\diverges\>, read ``matching pattern \<p\> against expression \<e\> diverges''.
    \item \<p \match e\fails\>, read ``matching pattern \<p\> against expression \<e\> fails''.
    \item \<p \match e\>, read ``matching pattern \<p\> against expression \<e\> succeeds''.
\end{itemize}
Note that, for a given pattern \<p\> and expression \<e\>, precisely one of these predicates will hold.

If \<p \match e\>, the syntax \<\Pat{p \match e}\> will be used to denote the value environment induced by the pattern match;
\<\Pat{p \match e}e1\> will be used to denote \<e1\> with the values bound by \<p\>:
\begin{haskell}
    \Expr{\Pat{p \match e}e1}\eta = \Expr{e1}\{\eta;\Pat{p \match e}\}
\end{haskell}
If \<p \match e\diverges\> or \<p \match e\fails\>, \<\Pat{p \match e}\> and \<\Pat{p \match e}e1\> will be undefined.

We have a few basic cases:
\begin{prooftree}
    \AxiomC{}
    \UnaryInfC{\<'x \match e\>} 
\end{prooftree}

For a basic view pattern \<v \overline{p_i}\>, when matching against an expression \<e\>,
use a pattern matching algorithm as follows:
\begin{itemize}
    \item First consider the expression \<'d = match v bool.false (\inlinelambda{\overline{'x_i}}{bool.true}) e\>.
        \begin{itemize}
            \item If \<d = \bot\>, \<v \overline{p_i} \match e\diverges\>.
            \item If \<d = bool.false\>, \<v \overline{p_i} \match e\fails\>.
        \end{itemize}
        Otherwise, \<d = bool.true\>.
    \item Second, if \<d = bool.true\>, let \<t_0 = match v \error (\inlinelambda{\overline{'x_i}}{\inlinetuple{\overline{x_i,}}}) e\>.
        Let \<\overline{x_i = \#i t_0}\> be the components of \<t_0\>.
        \begin{itemize}
            \item If, for any $'k\in[0,n)$, \<\forall\ 'i\in[0,k). p_i \match x_i\> and \<p_k \match x_k\diverges\>,
                \<v \overline{p_i} \match e\diverges\>.
            \item If, for any $'k\in[0,n)$, \<\forall\ 'i\in[0,k). p_i \match x_i\> and \<p_k \match x_k\fails\>,
                \<v \overline{p_i} \match e\fails\>.
            \item Otherwise, for all $'i\in[0,n)$, \<p_i \match x_i\>.
                In this case, \<v \overline{p_i} \match e\>
                and \<\Pat{v \overline{p_i} \match e}\> is the concatenation of \<\overline{\Pat{p_i \match x_i}}\>.
        \end{itemize}
\end{itemize}

\chapter{Generators}

The judgment form for generators is:
\begin{haskell}
  \Gamma \sequent g \provides \Gamma'
\end{haskell}
\<g\> can be a single generator, or a sequence of (semicolon-terminated) generators.
This is read ``In type environment \<\Gamma\>,
the generator(s) \<g\> is (are) well-typed
and induce(s) the type environment \<\Gamma'\>.

\defn{Monoidal} generators can fail at run time, which is indicated by using a judgment of the form
\begin{haskell}
  \Gamma \sequent g \provides^? \Gamma'
\end{haskell}

\defn{Monadic} generators run in a particular monad, which is indicated by using a judgment of the form
\begin{haskell}
  \Gamma \sequent g \provides_m \Gamma'
\end{haskell}

And, finally, there are \defn{monadic monoidal} generators:
\begin{haskell}
  \Gamma \sequent g \provides_m^? \Gamma'
\end{haskell}

Some simple generators are:
\begin{prooftree}
  \AxiomC{\<\Gamma \sequent p :: \tau \provides \Gamma'\>}
  \AxiomC{\<\Gamma \sequent e :: \tau\>}
  \BinaryInfC{\<\Gamma \sequent p \propto e \provides \Gamma'\>}
\end{prooftree}
\begin{prooftree}
  \AxiomC{\<\Gamma \sequent p :: \tau \provides^? \Gamma'\>}
  \AxiomC{\<\Gamma \sequent e :: \tau\>}
  \BinaryInfC{\<\Gamma \sequent p \propto e \provides^? \Gamma'\>}
\end{prooftree}

\chapter{Types}

\chapter{Modules}
\label{modules}

\chapter{Overloading}

\chapter{IDMC}

IDMC is more complicated than other aspects of the language,
because each QLO can define its own syntax and type system for that syntax.

So the judgement form for QLO bits is:
\begin{haskell}
    \Gamma \sequent \hsinf{text} ::_{qlo} \tau
\end{haskell}
\<\hsinf{text}\> is a bit of marked-up text; \<qlo\> is a QLO.

The master inference rule for QLOs then is:
\begin{prooftree}
    \AxiomC{\<\Gamma \sequent \hsinf{text} ::_{qlo} \tau\>}
    \UnaryInfC{\<\Gamma \sequent qlo\{\hsinf{text}\} :: \tau\>}
\end{prooftree}
The curly braces \<\{\}\> can be replaced with any delimiters you want (only in this construct).

Expression interpolations:
\begin{prooftree}
    \AxiomC{\<\Gamma \sequent e :: \tau\>}
    \UnaryInfC{\<\Gamma \sequent \S(e) ::_{qlo} \tau\>}
\end{prooftree}

Text interpolations:
\begin{prooftree}
    \AxiomC{\<\Gamma \sequent \hsinf{text} ::_{qlo} \tau\>}
    \UnaryInfC{\<\Gamma \sequent \S\{\hsinf{text}\} ::_{qlo} \tau\>}
\end{prooftree}

\paragraph{Variable/macro interpolations}
Macro interpolations have the form
\begin{haskell}
    \S{}x@(\type{} \tau_0)\ldots@(\type{} \tau_{n-1})@arg_0\ldots@arg_{m-1}arg_m\ldots{}arg_{m+n-1}
\end{haskell}
where each \<arg\>,
whether optional or required,
has the form \<\{\hsinf{text}\}\> or \<(exp)\>.

The judgment form for a macro interpolation is
\begin{haskell}
    \Gamma \sequent v :: \overline{\tau_i :: \kappa_i}; \overline{a_j :: \tau_j}; \overline{qlo_k}; \tau
\end{haskell}
where each \<qlo_k\> is either a QLO name or \<\_\>.
The empty sequence at the end of the sequence \<\overline{qlo_k}\> is equivalent to an infinite sequence of \<\_\>s.

If \<\Gamma\> contains no \<\macro\> declaration for \<x\>:
\begin{prooftree}
    \AxiomC{\<\Gamma \sequent x :: \overline{\tau_i :: \kappa_i}; \overline{a_j :: \tau_j}; \tau\>}
    \AxiomC{\<\overline{\Gamma \sequent \tau_i :: \kappa_i}\>}
    \BinaryInfC{\<\Gamma \sequent \S{}x ::_{qlo} \overline{\tau_i :: \kappa_i}; \overline{a_j :: \tau_j}; \tau\>}
\end{prooftree}
Otherwise:
\begin{prooftree}
    \AxiomC{\<\macro\;x\;\overline{qlo_k} \in \Gamma\>}
    \AxiomC{\<\Gamma \sequent x :: \overline{\tau_i :: \kappa_i}; \overline{a_j :: \tau_j}; \tau\>}
    \AxiomC{\<\overline{\Gamma \sequent \tau_i :: \kappa_i}\>}
    \TrinaryInfC{\<\Gamma \sequent \S{}x ::_{qlo} \overline{\tau_i :: \kappa_i}; \overline{a_j :: \tau_j}; \overline{qlo_k}; \tau\>}
\end{prooftree}

\chapter{Programs}

The judgment form for whole programs is
\begin{haskell}
    \sequent\;\langle\overline{g_i}; d\rangle:: \langle\Gamma; \tau\rangle
\end{haskell}
The type environment must be empty because whole programs include the entire library and so can have no free variables.

A program consists of a sequence of generators and a §defn{document};
ideally, Global Script implementations should assemble programs from separately maintained components,
including the §defn{standard library} (see \chapterref{stdlib}).\footnote{So including multiple components in the program isn't really optional.}
A program's value is the value of its document.

TODO: The standard library and the standard libraries of languages like IBIO and CORD are quite magic in bringing things into scope there's no way to define in the language.  End TODO.

The generators in a program (at the top level) must be:
\begin{itemize}
    \item Match generators \<p \match e\> where \<p\> is lax;
    \item Let generators \<'f \overline{p_i} = e\>;
    \item Type signatures \<x :: \sigma\>; and
    \item Recursive groups \<\rec\;(\overline{g_i})\> where all the \<g_i\> are otherwise legal at the top level.
\end{itemize}

Implementations may and are likely to further restrict accepted top-level generators;
they must support these cases:
\begin{itemize}
    \item Match generators \<p \match e\> defining variables in a single module.
        (When defining multiple variables,
        the best way to ensure this is to use a generator of the form
        \<module 'm.(\hsinf{export list}) \match e\>).

    \item Functions defined by a single let equation \<'f \overline{p_i} = e\>.
        Note that using monoidal patterns in such an equation must be legal,
        but is sub-optimal programming practice as it must be an error for any pattern in the head to fail.
\end{itemize}

The inference rule from programs is
\begin{prooftree}
    \AxiomC{\<\sequent\;\overline{g_i} \provides \Gamma\>}
    \AxiomC{\<\Gamma\sequent d :: \tau\>}
    \BinaryInfC{\<\sequent\;\langle \overline{g_i}; d\rangle :: \langle \Gamma; \tau\rangle\>}
\end{prooftree}

\chapter{Documents}

\begin{prooftree}
    \AxiomC{\<\Gamma\sequent e :: \tau\>}
    \UnaryInfC{\<\Gamma\sequent e :: \tau\>}
\end{prooftree}

\begin{prooftree}
    \AxiomC{\<\Gamma, \Gamma' \sequent \overline{g_i} \provides \Gamma'\>}
    \AxiomC{\<\Gamma, \Gamma' \sequent e :: \tau\>}
    \BinaryInfC{\<\Gamma \sequent e\;(\where\;\overline{g_i}) :: \tau\>}
\end{prooftree}
The parentheses around the \<\where\> clause can be omitted when there is only one generator,
in which case that generator must not have a trailing \<;\>, as usual.
The standard limits on the generators legal in a \<\where\> clause apply

TODO: Have we said what the `standard limits' on \<\where\> clauses are yet?  End TODO.

A §defn{document} is an expression together with an optional \<\where\> clause.
The document \<e\;(\where\;\overline{g_i})\> is equivalent to the expression \<\for\;\rec\;(\overline{g_i})\;e\>,
as might be expected.
(Except that more generators are legal in a \<\for\> than in a \<\where\>.)

\chapter{Standard Library}
\label{stdlib}

\chapter{Examples}

\section{Fibionacci Numbers}

\begin{haskell}
    \pvar{fibs} \propto 0 : 1 : map_2 @by.zip (+) fibs (drop 1 fibs);
\end{haskell}

\section{Prime Numbers}

\begin{haskell}
    \pvar{primes} = w 2 (repeat true) \blockwhere{
        \pvar{w} !\pvar{n} (\pview{false} : \pvar{bs}) &\reduceto w (n + 1) bs; \\
        \pvar{w} !\pvar{p} (\pview{true} : \pvar{bs}) &\reduceto p : w (p + 1) (set (chunksof p \circ elems \circ last) false bs);
    };
\end{haskell}

\section{\sh{gstype} Hello, World}

\begin{haskell}
    \qq{Hello, world!$\backslash$n}
\end{haskell}

\section{\sh{gsdraw} Hello, World}

\begin{haskell}
    text \str{Hello, world!}
\end{haskell}

\section{Dance Hello, World}

\begin{haskell}
    text \str{Hello, world!}
\end{haskell}

\section{IBIO \sh{echo}}

\begin{haskell}
    \inlinefor{\pvar{as} \leftarrow getM env.args}{send \$ concat (intersperse \qq{\ } as) <> \qq{$\backslash$n}}
\end{haskell}

\section{IBIO \sh{cat}}

\begin{haskell}
    \inlinefor{\pvar{as} \leftarrow getM env.args}{\blockanalyze{as}{%
        \case\ \pview{nil}. cat \\
        (\case\ \_. foreachM \$ \blocklambda{\pvar{a}}{
            \inlinefor{\pvar{eif} \leftarrow file.open \omode{r} \$ file.name.in a}{\blockanalyze{eif}{
                \case\ \pview{left} \pvar{e}. abend e \\
                \case\ \pview{right} \pvar{if}. cat \ifrom{} if
            }}
        })
    }} \inlinewhere{
        \pvar{cat} = \inlinefor{\pvar{s} \leftarrow receive (many symbol)}{send s}
    }
\end{haskell}

\section{IBIO \sh{wc}}

\begin{haskell}
    \pvar{wc} = \inlinefor{\pvar{ls} \leftarrow receive (many line)}{unit !(foldl.! accum init ls)} \blockwhere{
        \pvar{init} \propto \structure{
            \pvar{lines} \propto 0; \\
            \pvar{words} \propto 0; \\
            \pvar{runes} \propto 0;
        }; \\
        \pvar{accum} \pvar{as} (\pvar{l} :: vector.t rune.t) = \structure{
            !\pvar{lines} \propto as \#lines + 1; \\
            !\pvar{words} \propto as \#words + (l =\sim split \matchre{$\backslash${}s+}) \#length; \\
            !\pvar{runes} \propto as \#runes + l \#length;
        };
    };
\end{haskell}

\end{document}
