\documentclass{report}
\title{Global Script Program Calculus}
\author{Jonathan Cast}

\usepackage{amsmath}
\usepackage{bussproofs}
\usepackage{latexsym}
\usepackage{haskell}

\newcommand\sequent\vdash
\newcommand\provides\rhd

\newcommand\type{\hskwd{type}}
\newcommand\module{\hskwd{module}}
\newcommand\view{\hskwd{view}}
\newcommand\analyze{\hskwd{analyze}}
\newcommand\case{\hskwd{case}}
\newcommand\for{\hskwd{for}}
\newcommand\gslambda{\hskwd{\lambda}}
\hscommand\where{\hskwd{where}}

\newcommand\inlinelambda[2]{\gslambda\ #1. #2}
\hscommand\inlinefor[2]{\for\ (#1)\ #2}

\newcommand\blockanalyze[2]{\analyze\ #1\hsbody{\hsalign{#2}}}
\newcommand\blocklambda[2]{\gslambda\ #1. \hsbody{\hsalign{#2}}}
\hscommand\blockfor[2]{\for\ (#1)\hsbody{\hsalign{#2}}}
\hscommand\blockwhere[1]{(\where\hsbody{\hsalign{#1}})}

\newcommand\qq[1]{qq\{\text{\texttt{#1}}\}}
\newcommand\str[1]{\(str\{\text{#1}\}\)}

\hscommand\ifrom{<\!<}

\newcommand\defn[1]{\emph{#1}}

\newcommand\chapterref[1]{Chapter \ref{#1}}
\newcommand\sectionref[1]{Section \ref{#1}}

\newcommand\implicit{\hskwd{implicit}}

\newcommand\kwd[1]{\textbf{#1}}

\newcommand\sh[1]{\texttt{#1}}

\begin{document}

\maketitle

\tableofcontents

\chapter{Object Expressions}

\section{Variables}

The judgment form for variables is
\begin{equation}
    \Gamma \sequent v :: \overline{\tau_i :: \kappa_i}; \overline{a_j :: \tau_j}; \tau
\end{equation}
($i \in [0, n)$, $j \in [n, n + m)$).
\begin{itemize}
    \item $\Gamma$ is the type environment,
    \item $v$ is the variable term in question,
    \item $\overline{\tau_i :: \kappa_i}$ is a sequence of \defn{default type arguments} and their kinds,
    \item $\overline{a_j :: \tau_j}$ is a sequence of \defn{default arguments} and their types, and
    \item $\tau$ is the (monomorphic) type of the variable term.
\end{itemize}
A \defn{variable term} is a simple variable
followed by a sequence of \defn{explicit type arguments} of the form \<@(\type \tau)\>
followed by a sequence of \defn{explicit arguments} of the form \<@e\>.

\subsection{Variables Without \kwd{implicit} Declarations}

\begin{prooftree}
    \AxiomC{$\Gamma \sequent \overline{\tau_i :: \kappa_i}$}
    \UnaryInfC{
        \<\Gamma, x :: \forall\;\overline{'\alpha_i :: \kappa_i}. \tau \sequent x :: \overline{\tau_i :: \kappa_i}; ; \tau'\>
    }
\end{prooftree}
\begin{itemize}
    \item $i \in [0, n)$;
    \item $\Gamma$ does not contain an \<\implicit\> declaration for $x$;
    \item $\tau'$ means $[\overline{\alpha_i\to\tau_i}]\tau$,
        the result of substituting the type arguments for the $\forall$-bound variables in $\tau$.
\end{itemize}

\subsection{Variables With \kwd{implicit} Declarations}

\begin{prooftree}
    \AxiomC{$\Gamma \sequent \overline{\tau_i :: \kappa_i}$}
    \AxiomC{$\Gamma \sequent \overline{e_j :: \tau'_j}$}
    \BinaryInfC{
        \<\Gamma, x :: \forall\;\overline{'\alpha_i :: \kappa_i}. \overline{\tau_j} \to \tau, \implicit\;x\;\overline{e_j} \sequent x :: \overline{\tau_i :: \kappa_i}; \overline{e_j :: \tau'_j}; \tau'\>
    }
\end{prooftree}
\begin{itemize}
    \item $i \in [0, n)$, $j \in [n, n + m)$;
    \item $\tau'_j$ means $[\overline{\alpha_i\to\tau_i}]\tau_j$,
        the result of substituting the type arguments for the $\forall$-bound variables in $\tau_j$;
    \item $\tau'$ means $[\overline{\alpha_i\to\tau_i}]\tau$,
        the result of substituting the type arguments for the $\forall$-bound variables in $\tau$.
\end{itemize}

\subsection{Explicit Type Applications}

\begin{prooftree}
    \AxiomC{$\Gamma \sequent x :: \tau_0 :: \kappa_0, \overline{\tau_i :: \kappa_i}; \overline{e_j :: \tau_j}; \tau$}
    \UnaryInfC{
        \<\Gamma \sequent x\;@(\type\;\tau_0) :: \overline{\tau_i :: \kappa_i}; \overline{e_j :: \tau_j}; \tau\>
    }
\end{prooftree}
($i \in [1, n)$, $j \in [n, n + m)$).

\subsection{Explicit Applications}

\begin{prooftree}
    \AxiomC{$\Gamma \sequent x :: \overline{\tau_i :: \kappa_i}; e_n :: \tau_n, \overline{e_j :: \tau_j}; \tau$}
    \AxiomC{$\Gamma \sequent e :: \tau_n$}
    \BinaryInfC{
        $\Gamma \sequent x\;@e :: \overline{\tau_i :: \kappa_i}; \overline{e_j :: \tau_j}; \tau$
    }
\end{prooftree}
($i \in [1, n)$, $j \in [n + 1, n + m)$).

\subsection{Variables Used as Expressions}

\begin{prooftree}
    \AxiomC{$\Gamma \sequent x :: \overline{\tau_i :: \kappa_i}; \overline{e_j :: \tau_j}; \tau$}
    \UnaryInfC{$\Gamma \sequent x :: \tau$}
\end{prooftree}
($i \in [1, n)$, $j \in [n, n + m)$).

\subsection{TODOs}

\begin{itemize}
    \item Really shouldn't require explicit arguments to be well-typed unless they end up being used.
\end{itemize}

\section{Functions}

\subsection{Function Literals}

Lambda terms have the rule:\footnote{See \chapterref{patterns}, Patterns}
\begin{prooftree}
    \AxiomC{$\Gamma \sequent p :: \tau_1 \provides \Gamma'$}
    \AxiomC{$\Gamma, \Gamma', \sequent e :: \tau_2$}
    \BinaryInfC{$\Gamma \sequent \lambda{} p. e :: \tau_1 \to \tau_2$}
\end{prooftree}
The pattern $p$ must be a lax or strict (not monoidal) pattern; see \sectionref{pattern-classes}, Classes of Patterns.
BUG: $\lambda$ takes \emph{multiple} patterns (0 or more).
End BUG.

\subsection{Applications}

Applications have the rule:
\begin{prooftree}
    \AxiomC{$\Gamma \sequent e_1 :: \tau_1 \to \tau_2$}
    \AxiomC{$\Gamma \sequent e_2 :: \tau_1$}
    \BinaryInfC{$\Gamma \sequent e_1\hsap e_2 :: \tau_2$}
\end{prooftree}

\section{Branch Expressions}

An \<\analyze\> expression,
Syntactically, \<\analyze\ \overline{expr_i} \overline{\case\ \overline{p_{ji}}. body_j}\>,
takes a sequence of scrutinee expressions and matches them against the patterns in the cases,
top-to-bottom and left-to-right.
If matching a scrutinee against any pattern diverges or no case matches evaluation diverges;
otherwise the \<\analyze\> expression evaluates to the body of the first matching case.
Note: if a case matches and matching the scrutinees against the patterns in a previous case diverges,
evaluation diverges.
If a case matches and matching the scrutinees against a subsequent case diverges,
the evaluation proceeds with the body of the matching case.

This syntax has a `dangling else' problem when a \<\case\> ends with an \<\analyze\> expression;
this is resolved as usual by associating each \<\case\> to the nearest preceding \<\analyze\> expression.
This resolution can be over-ridden by putting parentheses around the inner \<\analyze\> expression or its enclosing \<\case\>.

\subsection{Cases}

The judgment form for \<\case\> terms is:
\begin{haskell}
    \Gamma;  \sequent \case\ \overline{p_i}. e :: \overline{\tau_i} \rightarrow \tau
\end{haskell}

Single cases type thus:

\begin{prooftree}
    \AxiomC{$\Gamma \sequent \tau :: *$}
    \AxiomC{$\Gamma \sequent e :: \tau$}
    \BinaryInfC{$\Gamma \sequent \case.\;e ::\;\rightarrow\ \tau$}
\end{prooftree}

\begin{prooftree}
    \AxiomC{$\Gamma \sequent \tau :: *$}
    \AxiomC{$\Gamma \sequent p_0 :: \tau_0 \rhd \Gamma'$}
    \AxiomC{$\Gamma, \Gamma', \sequent \case\;\overline{p_i}.\;e :: \overline{\tau_i} \rightarrow \tau$}
    \TrinaryInfC{$\Gamma \sequent \case\;p_0,\;\overline{p_i},.\;e :: \tau_0,\;\overline{\tau_i}, \rightarrow \tau$}
\end{prooftree}
NB: \<p_0, \overline{p_i}\> should define disjoint sets of variables.
This has implications.
The principle is --- hrm.
So we have a can-be-bound-by set for a pattern --- in a context --- and then an is-bound-by function for sequences/sets of patterns.
Usually these are the same.
However, certain patterns do \emph{not} bind variables that can be bound by other patterns (whether they are or not).
But that all goes in the Patterns chapter (Chapter \ref{patterns}).

\chapter{Patterns}
\label{patterns}

The judgment form for patterns is
\begin{equation}
    \Gamma \sequent \overline{p_i :: \tau_i} \provides \Gamma'
\end{equation}

\section{Concatenating Sequences of Patterns}

\begin{prooftree}
    \AxiomC{$\Gamma \sequent \overline{p_i :: \tau_i} \provides \Gamma'_1$}
    \AxiomC{$\Gamma \sequent \overline{p_j :: \tau_j} \provides \Gamma'_2$}
    \BinaryInfC{$\Gamma \sequent \overline{p_i :: \tau_i}, \overline{p_j :: \tau_j}, \provides \Gamma'_1, \Gamma'_2,$}
\end{prooftree}
($i \in [0, n)$, $j \in [n, n+m)$).
The bound variables of the patterns must all be distinct.
TODO: need a way to handle module patterns \<\module\;'m\>,
for which the bound variables are selected to be distinct from any other patterns in the same sequence.
The rule is basically: calculate the set of variables which \emph{could} be bound by any given pattern.
Then each \<\module\;'m\> pattern brings into scope those variables which could be bound by it,
and which cannot be bound by any other pattern.
This only applies to $\module$ patterns with no export list,
or whose export list contain $..$ .  See \chapterref{modules}, Modules.
End TODO.

\section{Classes of Patterns}
\label{pattern-classes}

\begin{itemize}
    \item \defn{Lax} patterns are precisely these:
        \begin{itemize}
            \item Pattern variables \<'x\>;
            \item Wildcard patterns \<\_\>;
            \item Module patterns where:
                \begin{itemize}
                    \item there is no export list, e.g. \<\module\;'m\>,
                    \item there is a simple export list, e.g. \<\module\;'m.(x, y, z,)\>,
                    \item there is a complex export list,
                        e.g. \<\module\;'m.\left(\hsalign[c]{x = p_0,\\y = p_1,\\z = p_2,}\right)\>,
                        where all of the patterns given for the members are themselves lax;
                    \end{itemize}
                \item Lazy patterns \<\sim{}\!p\>; and
                \item Parallel patterns \<\parallel\!p\>.
        \end{itemize}
    \item \defn{Strict} patterns are precisely those patterns of the form \<!p\>.
    \item \defn{Monoidal} patterns are precisely those patterns that are neither lax nor strict.
\end{itemize}

\section{Specific patterns}

\paragraph{Pattern variables}
Pattern variables have the syntactic form \<'x\>, the ASCII apostrophe followed by a variable name.
Pattern variables where the variable is an infix operator need to be enclosed in parentheses, e.g., \<('+)\>
\begin{prooftree}
    \AxiomC{$\Gamma \sequent \tau :: *$}
    \UnaryInfC{$\Gamma \sequent\; 'x :: \tau \provides x :: \tau$}
\end{prooftree}

\paragraph{Wildcard Patterns}
\begin{prooftree}
    \AxiomC{$\Gamma \sequent \tau :: *$}
    \UnaryInfC{$\Gamma \sequent \_ :: \tau \provides$}
\end{prooftree}

\paragraph{Views}
The typing judgment for views has the form $\Gamma \sequent \view\;v :: \overline{\tau_i}; \tau$, for $i \in [0, n)$.
This means:
\begin{itemize}
    \item $v$ is a view,
    \item $v$ has arrity $n$,
    \item $v$'s arguments have types $\tau_i$, respectively, and
    \item $v$'s result has type $\tau$.
\end{itemize}
Note that, if $v$ is both a view and a function, \emph{it need not have the same type in both cases}.
Nor, if it does have the same type, need its definition as a view and as a function have any specific relation.
Nevertheless giving them the same type and relating the definitions in some (documented) way is strongly recommended.
Global Script does not draw a distinction between constructors and views.
\begin{prooftree}
    \AxiomC{$\Gamma \sequent \view\;v :: \overline{\tau_i}; \tau$}
    \AxiomC{$\Gamma \sequent \overline{p_i :: \tau_i} \provides \Gamma'$}
    \BinaryInfC{$\Gamma \sequent v\;\overline{p_i} :: \tau \provides \Gamma'$}
\end{prooftree}
TODO: How do you declare views?  How do views and constructors interract, exactly? End TODO.

TODO: Existential types.  End TODO.

Language TODO: Expression arguments to views (e.g., \<n+m\> patterns).  End TODO.

\chapter{Types}

\chapter{Modules}
\label{modules}

\chapter{Overloading}

\chapter{Standard Library}

\chapter{Examples}

\section{\sh{gstype} Hello, World}

\begin{haskell}
    \qq{Hello, world!$\backslash$n}
\end{haskell}

\section{\sh{gsdraw} Hello, World}

\begin{haskell}
    text \str{Hello, world!}
\end{haskell}

\section{Dance Hello, World}

\begin{haskell}
    text \str{Hello, world!}
\end{haskell}

\section{IBIO \sh{echo}}

\begin{haskell}
    \inlinefor{'as \leftarrow env.args.get}{send \$ concat (intersperse \qq{\ } as) <> \qq{$\backslash$n}}
\end{haskell}

\section{IBIO \sh{cat}}

\begin{haskell}
    (\inlinefor{'as \leftarrow env.args.get}{\blockanalyze{as}{%
        \case\ nil. cat \\
        \case\ \_. foreachM \$ \blocklambda{'a}{
            \inlinefor{'eif \leftarrow file.open o/r/ \$ file.name.in a}{\blockanalyze{eif}{
                \case\ left 'e. abend e \\
                \case\ right 'if. cat \ifrom{} if
            }}
        }
    }}) \blockwhere{
        'cat = \inlinefor{'s \leftarrow receive (many symbol)}{send s};
    }
\end{haskell}

\end{document}
