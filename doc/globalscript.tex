\documentclass{report}
\title{Global Script Program Calculus}
\author{Jonathan Cast}

\usepackage{amsmath}
\usepackage{bussproofs}
\usepackage{latexsym}
\usepackage{haskell}

\newcommand\sequent\vdash
\newcommand\provides\rhd
\newcommand\match\propto

\hscommand\from{\leftarrow}

\newcommand\type{\hskwd{type}}
\newcommand\module{\hskwd{module}}
\newcommand\view{\hskwd{view}}
\newcommand\analyze{\hskwd{analyze}}
\newcommand\case{\hskwd{case}}
\hscommand\for{\hskwd{for}}
\newcommand\gslambda{\hskwd{\lambda}}
\hscommand\where{\hskwd{where}}
\hscommand\rec{\hskwd{rec}}
\hscommand\macro{\hskwd{macro}}

\newcommand\inlinelambda[2]{\gslambda\ #1. #2}
\hscommand\inlinefor[2]{\for\ (#1)\ #2}

\newcommand\blockanalyze[2]{\analyze\ #1\hsbody{\hsalign{#2}}}
\newcommand\blocklambda[2]{\gslambda\ #1. \hsbody{\hsalign{#2}}}
\hscommand\blockfor[2]{\for\ (#1)\hsbody{\hsalign{#2}}}
\hscommand\blockwhere[1]{(\where\hsbody{\hsalign{#1}})}

\newcommand\qq[1]{qq\{\text{\texttt{#1}}\}}
\newcommand\str[1]{\(str\{\text{#1}\}\)}

\hscommand\ifrom{<\!<}

\newcommand\defn[1]{\emph{#1}}

\newcommand\chapterref[1]{Chapter \ref{#1}}
\newcommand\sectionref[1]{Section \ref{#1}}

\newcommand\implicit{\hskwd{implicit}}

\newcommand\kwd[1]{\textbf{#1}}

\newcommand\sh[1]{\texttt{#1}}

\begin{document}

\maketitle

\tableofcontents

\chapter{Object Expressions}

\section{Variables}

The judgment form for variables is
\begin{equation}
    \Gamma \sequent v :: \overline{\tau_i :: \kappa_i}; \overline{a_j :: \tau_j}; \tau
\end{equation}
($i \in [0, n)$, $j \in [n, n + m)$).
\begin{itemize}
    \item $\Gamma$ is the type environment,
    \item $v$ is the variable term in question,
    \item $\overline{\tau_i :: \kappa_i}$ is a sequence of \defn{default type arguments} and their kinds,
    \item $\overline{a_j :: \tau_j}$ is a sequence of \defn{default arguments} and their types, and
    \item $\tau$ is the (monomorphic) type of the variable term.
\end{itemize}
A \defn{variable term} is a simple variable
followed by a sequence of \defn{explicit type arguments} of the form \<@(\type \tau)\>
followed by a sequence of \defn{explicit arguments} of the form \<@e\>.
Variable terms are designated \<v\>; simple variables are designated \<x\>.

\subsection{Variables Without \kwd{implicit} Declarations}

\begin{prooftree}
    \AxiomC{$\Gamma \sequent \overline{\tau_i :: \kappa_i}$}
    \UnaryInfC{
        \<\Gamma, x :: \forall\;\overline{'\alpha_i :: \kappa_i}. \tau \sequent x :: \overline{\tau_i :: \kappa_i}; ; \tau'\>
    }
\end{prooftree}
\begin{itemize}
    \item $i \in [0, n)$;
    \item $\Gamma$ does not contain an \<\implicit\> declaration for $x$;
    \item $\tau'$ means $[\overline{\alpha_i\to\tau_i}]\tau$,
        the result of substituting the type arguments for the $\forall$-bound variables in $\tau$.
\end{itemize}

\subsection{Variables With \kwd{implicit} Declarations}

\begin{prooftree}
    \AxiomC{$\Gamma \sequent \overline{\tau_i :: \kappa_i}$}
    \AxiomC{$\Gamma \sequent \overline{e_j :: \tau'_j}$}
    \BinaryInfC{
        \<\Gamma, x :: \forall\;\overline{'\alpha_i :: \kappa_i}. \overline{\tau_j} \to \tau, \implicit\;x\;\overline{e_j} \sequent x :: \overline{\tau_i :: \kappa_i}; \overline{e_j :: \tau'_j}; \tau'\>
    }
\end{prooftree}
\begin{itemize}
    \item $i \in [0, n)$, $j \in [n, n + m)$;
    \item $\tau'_j$ means $[\overline{\alpha_i\to\tau_i}]\tau_j$,
        the result of substituting the type arguments for the $\forall$-bound variables in $\tau_j$;
    \item $\tau'$ means $[\overline{\alpha_i\to\tau_i}]\tau$,
        the result of substituting the type arguments for the $\forall$-bound variables in $\tau$.
\end{itemize}

\subsection{Explicit Type Applications}

\begin{prooftree}
    \AxiomC{$\Gamma \sequent v :: \tau_0 :: \kappa_0, \overline{\tau_i :: \kappa_i}; \overline{e_j :: \tau_j}; \tau$}
    \UnaryInfC{
        \<\Gamma \sequent v\;@(\type\;\tau_0) :: \overline{\tau_i :: \kappa_i}; \overline{e_j :: \tau_j}; \tau\>
    }
\end{prooftree}
($i \in [1, n)$, $j \in [n, n + m)$).

\subsection{Explicit Applications}

\begin{prooftree}
    \AxiomC{$\Gamma \sequent v :: \overline{\tau_i :: \kappa_i}; e_n :: \tau_n, \overline{e_j :: \tau_j}; \tau$}
    \AxiomC{$\Gamma \sequent e :: \tau_n$}
    \BinaryInfC{
        $\Gamma \sequent v\;@e :: \overline{\tau_i :: \kappa_i}; \overline{e_j :: \tau_j}; \tau$
    }
\end{prooftree}
($i \in [1, n)$, $j \in [n + 1, n + m)$).

\subsection{Variables Used as Expressions}

\begin{prooftree}
    \AxiomC{$\Gamma \sequent v :: \overline{\tau_i :: \kappa_i}; \overline{e_j :: \tau_j}; \tau$}
    \UnaryInfC{$\Gamma \sequent v :: \tau$}
\end{prooftree}
($i \in [1, n)$, $j \in [n, n + m)$).

\subsection{TODOs}

\begin{itemize}
    \item Really shouldn't require explicit arguments to be well-typed unless they end up being used.
\end{itemize}

\section{Functions}

\subsection{Function Literals}

Lambda terms have the rule:\footnote{See \chapterref{patterns}, Patterns}
\begin{prooftree}
    \AxiomC{$\Gamma \sequent p :: \tau_1 \provides \Gamma'$}
    \AxiomC{$\Gamma, \Gamma', \sequent e :: \tau_2$}
    \BinaryInfC{$\Gamma \sequent \lambda{} p. e :: \tau_1 \to \tau_2$}
\end{prooftree}
The pattern $p$ must be a lax or strict (not monoidal) pattern; see \sectionref{pattern-classes}, Classes of Patterns.
BUG: $\lambda$ takes \emph{multiple} patterns (0 or more).
End BUG.

\subsection{Applications}

Applications have the rule:
\begin{prooftree}
    \AxiomC{$\Gamma \sequent e_1 :: \tau_1 \to \tau_2$}
    \AxiomC{$\Gamma \sequent e_2 :: \tau_1$}
    \BinaryInfC{$\Gamma \sequent e_1\hsap e_2 :: \tau_2$}
\end{prooftree}

\section{\kwd{for} Expressions}

\<\for\> expressions are used to make local definitions within an expression.
The syntax is \<\inlinefor{\hsinf{generators}}{\hsinf{body expression}}\>.
The generators in a \<\for\> are non-recursive, but cannot shadow variables defined in the same \<\for\>.

In the simplest case, the generators in a \<\for\> are all let and (non-monoidal) match generators.
\begin{prooftree}
    \AxiomC{\<\Gamma \sequent \overline{g_i} \provides \Gamma'\>}
    \AxiomC{\<\Gamma, \Gamma', \sequent e :: \tau\>}
    \BinaryInfC{\<\Gamma \sequent (\inlinefor{\overline{g_i}}{e}) :: \tau\>}
\end{prooftree}

\<\for\> can also be used to name intermediate values inside a monad.
E.g. \<\inlinefor{'x \from e_0}{e_1}\>.
The type rule for this is
\begin{prooftree}
    \AxiomC{\<\Gamma \sequent \module\;monad.c\;m\>}
    \AxiomC{\<\Gamma \sequent \overline{g_i} \provides_m \Gamma'\>}
    \AxiomC{\<\Gamma, \Gamma', \sequent e :: m\;\tau\>}
    \TrinaryInfC{\<\Gamma \sequent \inlinefor{\overline{g_i}}{e} :: m\;\tau\>}
\end{prooftree}

As might be expected, the monad structure to use in de-sugaring this syntax can be over-ridden:
\begin{prooftree}
    \AxiomC{\<\Gamma \sequent mon :: monad.t\;m\>}
    \AxiomC{\<\Gamma \sequent \overline{g_i} \provides_m \Gamma'\>}
    \AxiomC{\<\Gamma, \Gamma', \sequent e :: m\;\tau\>}
    \TrinaryInfC{\<\Gamma \sequent \for\;@{}mon\;(\overline{g_i})\;e :: m\;\tau\>}
\end{prooftree}

The sequence of generators inside the \<()\> in a \<\for\> can either be a single generator or a sequence of 0 or more generators terminated by semi-colons.
In the special case of a single \<\rec\> generator, the syntax \<\for\;(\rec(\overline{g_i}))\> can be abreviated to \<\for\;\rec\;(\overline{g_i})\>.

\section{Branch Expressions}

An \<\analyze\> expression,
Syntactically, \<\analyze\ \overline{expr_i} \overline{\case\ \overline{p_{ji}}. body_j}\>,
takes a sequence of scrutinee expressions and matches them against the patterns in the cases,
top-to-bottom and left-to-right.
If matching a scrutinee against any pattern diverges or no case matches evaluation diverges;
otherwise the \<\analyze\> expression evaluates to the body of the first matching case.
Note: if a case matches and matching the scrutinees against the patterns in a previous case diverges,
evaluation diverges.
If a case matches and matching the scrutinees against a subsequent case diverges,
the evaluation proceeds with the body of the matching case.

This syntax has a `dangling else' problem when a \<\case\> ends with an \<\analyze\> expression;
this is resolved as usual by associating each \<\case\> to the nearest preceding \<\analyze\> expression.
This resolution can be over-ridden by putting parentheses around the inner \<\analyze\> expression or its enclosing \<\case\>.

\subsection{Cases}

The judgment form for \<\case\> terms is:
\begin{haskell}
    \Gamma;  \sequent \case\ \overline{p_i}. e :: \overline{\tau_i} \rightarrow \tau
\end{haskell}

Single cases type thus:

\begin{prooftree}
    \AxiomC{$\Gamma \sequent \tau :: *$}
    \AxiomC{$\Gamma \sequent e :: \tau$}
    \BinaryInfC{$\Gamma \sequent \case.\;e ::\;\rightarrow\ \tau$}
\end{prooftree}

\begin{prooftree}
    \AxiomC{$\Gamma \sequent \tau :: *$}
    \AxiomC{$\Gamma \sequent p_0 :: \tau_0 \rhd \Gamma'$}
    \AxiomC{$\Gamma, \Gamma', \sequent \case\;\overline{p_i}.\;e :: \overline{\tau_i} \rightarrow \tau$}
    \TrinaryInfC{$\Gamma \sequent \case\;p_0,\;\overline{p_i},.\;e :: \tau_0,\;\overline{\tau_i}, \rightarrow \tau$}
\end{prooftree}
NB: \<p_0, \overline{p_i}\> should define disjoint sets of variables.
This has implications.
The principle is --- hrm.
So we have a can-be-bound-by set for a pattern --- in a context --- and then an is-bound-by function for sequences/sets of patterns.
Usually these are the same.
However, certain patterns do \emph{not} bind variables that can be bound by other patterns (whether they are or not).
But that all goes in the Patterns chapter (Chapter \ref{patterns}).

\chapter{Patterns}
\label{patterns}

The judgment form for patterns is
\begin{equation}
    \Gamma \sequent \overline{p_i :: \tau_i} \provides \Gamma'
\end{equation}

\section{Concatenating Sequences of Patterns}

\begin{prooftree}
    \AxiomC{$\Gamma \sequent \overline{p_i :: \tau_i} \provides \Gamma'_1$}
    \AxiomC{$\Gamma \sequent \overline{p_j :: \tau_j} \provides \Gamma'_2$}
    \BinaryInfC{$\Gamma \sequent \overline{p_i :: \tau_i}, \overline{p_j :: \tau_j}, \provides \Gamma'_1, \Gamma'_2,$}
\end{prooftree}
($i \in [0, n)$, $j \in [n, n+m)$).
The bound variables of the patterns must all be distinct.
TODO: need a way to handle module patterns \<\module\;'m\>,
for which the bound variables are selected to be distinct from any other patterns in the same sequence.
The rule is basically: calculate the set of variables which \emph{could} be bound by any given pattern.
Then each \<\module\;'m\> pattern brings into scope those variables which could be bound by it,
and which cannot be bound by any other pattern.
This only applies to $\module$ patterns with no export list,
or whose export list contain $..$ .  See \chapterref{modules}, Modules.
End TODO.

\section{Classes of Patterns}
\label{pattern-classes}

\begin{itemize}
    \item \defn{Lax} patterns are precisely these:
        \begin{itemize}
            \item Pattern variables \<'x\>;
            \item Wildcard patterns \<\_\>;
            \item Module patterns where:
                \begin{itemize}
                    \item there is no export list, e.g. \<\module\;'m\>,
                    \item there is a simple export list, e.g. \<\module\;'m.(x, y, z,)\>,
                    \item there is a complex export list,
                        e.g. \<\module\;'m.\left(\hsalign[c]{x = p_0,\\y = p_1,\\z = p_2,}\right)\>,
                        where all of the patterns given for the members are themselves lax;
                    \end{itemize}
                \item Lazy patterns \<\sim{}\!p\>; and
                \item Parallel patterns \<\parallel\!p\>.
        \end{itemize}
    \item \defn{Strict} patterns are precisely those patterns of the form \<!p\>.
    \item \defn{Monoidal} patterns are precisely those patterns that are neither lax nor strict.
\end{itemize}

\section{Specific patterns}

\paragraph{Pattern variables}
Pattern variables have the syntactic form \<'x\>, the ASCII apostrophe followed by a variable name.
Pattern variables where the variable is an infix operator need to be enclosed in parentheses, e.g., \<('+)\>
\begin{prooftree}
    \AxiomC{$\Gamma \sequent \tau :: *$}
    \UnaryInfC{$\Gamma \sequent\; 'x :: \tau \provides x :: \tau$}
\end{prooftree}

\paragraph{Wildcard Patterns}
\begin{prooftree}
    \AxiomC{$\Gamma \sequent \tau :: *$}
    \UnaryInfC{$\Gamma \sequent \_ :: \tau \provides$}
\end{prooftree}

\paragraph{Views}
The typing judgment for views has the form $\Gamma \sequent \view\;v :: \overline{\tau_i}; \tau$, for $i \in [0, n)$.
This means:
\begin{itemize}
    \item $v$ is a view,
    \item $v$ has arrity $n$,
    \item $v$'s arguments have types $\tau_i$, respectively, and
    \item $v$'s result has type $\tau$.
\end{itemize}
Note that, if $v$ is both a view and a function, \emph{it need not have the same type in both cases}.
Nor, if it does have the same type, need its definition as a view and as a function have any specific relation.
Nevertheless giving them the same type and relating the definitions in some (documented) way is strongly recommended.
Global Script does not draw a distinction between constructors and views.
\begin{prooftree}
    \AxiomC{$\Gamma \sequent \view\;v :: \overline{\tau_i}; \tau$}
    \AxiomC{$\Gamma \sequent \overline{p_i :: \tau_i} \provides \Gamma'$}
    \BinaryInfC{$\Gamma \sequent v\;\overline{p_i} :: \tau \provides \Gamma'$}
\end{prooftree}
TODO: How do you declare views?  How do views and constructors interract, exactly? End TODO.

TODO: Existential types.  End TODO.

Language TODO: Expression arguments to views (e.g., \<n+m\> patterns).  End TODO.

\chapter{Types}

\chapter{Modules}
\label{modules}

\chapter{Overloading}

\chapter{IDMC}

IDMC is more complicated than other aspects of the language,
because each QLO can define its own syntax and type system for that syntax.

So the judgement form for QLO bits is:
\begin{haskell}
    \Gamma \sequent \hsinf{text} ::_{qlo} \tau
\end{haskell}
\<\hsinf{text}\> is a bit of marked-up text; \<qlo\> is a QLO.

The master inference rule for QLOs then is:
\begin{prooftree}
    \AxiomC{\<\Gamma \sequent \hsinf{text} ::_{qlo} \tau\>}
    \UnaryInfC{\<\Gamma \sequent qlo\{\hsinf{text}\} :: \tau\>}
\end{prooftree}
The curly braces \<\{\}\> can be replaced with any delimiters you want (only in this construct).

Expression interpolations:
\begin{prooftree}
    \AxiomC{\<\Gamma \sequent e :: \tau\>}
    \UnaryInfC{\<\Gamma \sequent \S(e) ::_{qlo} \tau\>}
\end{prooftree}

Text interpolations:
\begin{prooftree}
    \AxiomC{\<\Gamma \sequent \hsinf{text} ::_{qlo} \tau\>}
    \UnaryInfC{\<\Gamma \sequent \S\{\hsinf{text}\} ::_{qlo} \tau\>}
\end{prooftree}

\paragraph{Variable/macro interpolations}
Macro interpolations have the form
\begin{haskell}
    \S{}x@(\type{} \tau_0)\ldots@(\type{} \tau_{n-1})@arg_0\ldots@arg_{m-1}arg_m\ldots{}arg_{m+n-1}
\end{haskell}
where each \<arg\>,
whether optional or required,
has the form \<\{\hsinf{text}\}\> or \<(exp)\>.

The judgment form for a macro interpolation is
\begin{haskell}
    \Gamma \sequent v :: \overline{\tau_i :: \kappa_i}; \overline{a_j :: \tau_j}; \overline{qlo_k}; \tau
\end{haskell}
where each \<qlo_k\> is either a QLO name or \<\_\>.
The empty sequence at the end of the sequence \<\overline{qlo_k}\> is equivalent to an infinite sequence of \<\_\>s.

If \<\Gamma\> contains no \<\macro\> declaration for \<x\>:
\begin{prooftree}
    \AxiomC{\<\Gamma \sequent x :: \overline{\tau_i :: \kappa_i}; \overline{a_j :: \tau_j}; \tau\>}
    \AxiomC{\<\overline{\Gamma \sequent \tau_i :: \kappa_i}\>}
    \BinaryInfC{\<\Gamma \sequent \S{}x ::_{qlo} \overline{\tau_i :: \kappa_i}; \overline{a_j :: \tau_j}; \tau\>}
\end{prooftree}
Otherwise:
\begin{prooftree}
    \AxiomC{\<\macro\;x\;\overline{qlo_k} \in \Gamma\>}
    \AxiomC{\<\Gamma \sequent x :: \overline{\tau_i :: \kappa_i}; \overline{a_j :: \tau_j}; \tau\>}
    \AxiomC{\<\overline{\Gamma \sequent \tau_i :: \kappa_i}\>}
    \TrinaryInfC{\<\Gamma \sequent \S{}x ::_{qlo} \overline{\tau_i :: \kappa_i}; \overline{a_j :: \tau_j}; \overline{qlo_k}; \tau\>}
\end{prooftree}

\chapter{Programs}

The judgment form for whole programs is
\begin{haskell}
    \sequent\;\langle\overline{g_i}; d\rangle:: \langle\Gamma; \tau\rangle
\end{haskell}
The type environment must be empty because whole programs include the entire library and so can have no free variables.

A program consists of a sequence of generators and a §defn{document};
ideally, Global Script implementations should assemble programs from separately maintained components,
including the §defn{standard library} (see \chapterref{stdlib}).\footnote{So including multiple components in the program isn't really optional.}
A program's value is the value of its document.

TODO: The standard library and the standard libraries of languages like IBIO and CORD are quite magic in bringing things into scope there's no way to define in the language.  End TODO.

The generators in a program (at the top level) must be:
\begin{itemize}
    \item Match generators \<p \match e\> where \<p\> is lax;
    \item Let generators \<'f \overline{p_i} = e\>;
    \item Type signatures \<x :: \sigma\>; and
    \item Recursive groups \<\rec\;(\overline{g_i})\> where all the \<g_i\> are otherwise legal at the top level.
\end{itemize}

Implementations may and are likely to further restrict accepted top-level generators;
they must support these cases:
\begin{itemize}
    \item Match generators \<p \match e\> defining variables in a single module.
        (When defining multiple variables,
        the best way to ensure this is to use a generator of the form
        \<module 'm.(\hsinf{export list}) \match e\>).

    \item Functions defined by a single let equation \<'f \overline{p_i} = e\>.
        Note that using monoidal patterns in such an equation must be legal,
        but is sub-optimal programming practice as it must be an error for any pattern in the head to fail.
\end{itemize}

The inference rule from programs is
\begin{prooftree}
    \AxiomC{\<\sequent\;\overline{g_i} \provides \Gamma\>}
    \AxiomC{\<\Gamma\sequent d :: \tau\>}
    \BinaryInfC{\<\sequent\;\langle \overline{g_i}; d\rangle :: \langle \Gamma; \tau\rangle\>}
\end{prooftree}

\chapter{Documents}

\begin{prooftree}
    \AxiomC{\<\Gamma\sequent e :: \tau\>}
    \UnaryInfC{\<\Gamma\sequent e :: \tau\>}
\end{prooftree}

\begin{prooftree}
    \AxiomC{\<\Gamma, \Gamma' \sequent \overline{g_i} \provides \Gamma'\>}
    \AxiomC{\<\Gamma, \Gamma' \sequent e :: \tau\>}
    \BinaryInfC{\<\Gamma \sequent e\;(\where\;\overline{g_i}) :: \tau\>}
\end{prooftree}
The parentheses around the \<\where\> clause can be omitted when there is only one generator,
in which case that generator must not have a trailing \<;\>, as usual.
The standard limits on the generators legal in a \<\where\> clause apply

TODO: Have we said what the `standard limits' on \<\where\> clauses are yet?  End TODO.

A §defn{document} is an expression together with an optional \<\where\> clause.
The document \<e\;(\where\;\overline{g_i})\> is equivalent to the expression \<\for\;\rec\;(\overline{g_i})\;e\>,
as might be expected.
(Except that more generators are legal in a \<\for\> than in a \<\where\>.)

\chapter{Standard Library}
\label{stdlib}

\chapter{Examples}

\section{\sh{gstype} Hello, World}

\begin{haskell}
    \qq{Hello, world!$\backslash$n}
\end{haskell}

\section{\sh{gsdraw} Hello, World}

\begin{haskell}
    text \str{Hello, world!}
\end{haskell}

\section{Dance Hello, World}

\begin{haskell}
    text \str{Hello, world!}
\end{haskell}

\section{IBIO \sh{echo}}

\begin{haskell}
    \inlinefor{'as \leftarrow env.args.get}{send \$ concat (intersperse \qq{\ } as) <> \qq{$\backslash$n}}
\end{haskell}

\section{IBIO \sh{cat}}

\begin{haskell}
    (\inlinefor{'as \leftarrow env.args.get}{\blockanalyze{as}{%
        \case\ nil. cat \\
        \case\ \_. foreachM \$ \blocklambda{'a}{
            \inlinefor{'eif \leftarrow file.open o/r/ \$ file.name.in a}{\blockanalyze{eif}{
                \case\ left 'e. abend e \\
                \case\ right 'if. cat \ifrom{} if
            }}
        }
    }}) \blockwhere{
        'cat = \inlinefor{'s \leftarrow receive (many symbol)}{send s};
    }
\end{haskell}

\end{document}
