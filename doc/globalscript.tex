\documentclass{report}
\title{Global Script Program Calculus}
\author{Jonathan Cast}

\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{mathabx}
\usepackage{MnSymbol}
\usepackage{bussproofs}
\usepackage{haskell}
\usepackage[utf8]{inputenc}
\frenchspacing

\newcommand\sequent\vdash
\newcommand\provides\rhd
\newcommand\match\propto

\hscommand\from{\leftarrow}

\newcommand\type{\hskwd{type}}
\newcommand\module{\hskwd{module}}
\newcommand\view{\hskwd{view}}
\newcommand\analyze{\hskwd{analyze}}
\newcommand\case{\hskwd{case}}
\hscommand\for{\hskwd{for}}
\newcommand\gslambda{\hskwd{\lambda}}
\hscommand\where{\hskwd{where}}
\hscommand\rec{\hskwd{rec}}
\hscommand\macro{\hskwd{macro}}
\hscommand\error{\hskwd{error}}

\hscommand\reduceto{:\!\!-}

\hscommand\lift[1]{\lfloor#1\rfloor}
\hscommand\emdash{\text{---}}

\newcommand\inlinelambda[2]{\gslambda\ #1. #2}
\hscommand\inlinefor[2]{\for\ #1.\ #2}
\hscommand\inlinetuple[1]{\llangle #1 \rrangle}
\hscommand\inlinewhere[1]{\where\hsbody{\hsalign{#1}}}

\newcommand\blockanalyze[2]{\analyze\ #1.\hsbody{\hsalign{#2}}}
\newcommand\blocklambda[2]{\gslambda\ #1. \hsbody{\hsalign{#2}}}
\hscommand\blockfor[2]{\for\ (#1)\hsbody{\hsalign{#2}}}
\hscommand\blockwhere[1]{(\where\hsbody{\hsalign{#1}})}

\hscommand\structure[1]{\langle\hsbody{#1}\rangle}

\hscommand\pvar[1]{'\!#1}
\hscommand\pview[1]{\(\text{#1}\)}

\newcommand\qq[1]{qq\{\text{\texttt{#1}}\}}
\newcommand\str[1]{\(str\{\text{#1}\}\)}
\newcommand\omode[1]{\(o/\text{\texttt{#1}}/\)}
\hscommand\matchre[1]{\(m/\text{#1}/\)}

\hscommand\ifrom{<\!<}

\newcommand\defn[1]{\emph{#1}}

\newcommand\chapterref[1]{Chapter \ref{#1}}
\newcommand\sectionref[1]{Section \ref{#1}}

\newcommand\implicit{\hskwd{implicit}}

\newcommand\kwd[1]{\textbf{#1}}

\newcommand\sh[1]{\texttt{#1}}

\hscommand\diverges{\uparrow}
\hscommand\fails{\downarrow}
\hscommand\Den[1]{Den\ldbrack#1\rdbrack}
\hscommand\Pat[1]{\mathbb{P}\ldbrack#1\rdbrack}
\hscommand\Expr[1]{\mathbb{E}\ldbrack#1\rdbrack}
\hscommand\Type[1]{\mathbb{T}\ldbrack#1\rdbrack}
\hscommand\Kind[1]{\mathbb{K}\ldbrack#1\rdbrack}

\begin{document}

\maketitle

\tableofcontents

\chapter{Introduction and General Remarks}

This document specifies the \defn{Global Script Program Calculus}, a purely-functional, completely machine-independent program calculus designed to support the Global Script Type-Setting System.

\section{Excursus on the Term `Programming Language'}

The term `programming language' has an odd, and in the opinion of the developer of this system deleterious, definition in normal usage.
`Programming language' clearly derives from the verb `program', (rather than the noun);
it clearly means `language for the act of programming'.
But the verb `program' is a transitive verb: `program the i686 processor', `program the fuel injection system', `program the accounting system', etc.
To \defn{program} a machine is to make it do what the programmer wishes;
the act of programming makes no sense except in reference to a machine.
So `machine-independent programming language' is, properly speaking, a nonsensical concept.

Originally, this term simply meant `programming language which targets multiple machines'
(or, rather, usually, `family of programming languages indexed by multiple machines'),
which really means (if it means anything) `programming language which targets a family of machines sharing similar capabilities'.
Typically this class of machines encompases most of the machines typically encountered by programmers
(but not most programmable machines in use!),\footnote{Most software is actually embedded software, which lacks access to the familiar keyboard / screen / mouse facilities assumed by the typical definition of `general-purpose' language.}
so the myth has grown up that typical languages `support all computers';
and even that languages lacking I/O facilities are not Turing-complete!\footnote{The Intercal manual (implicitly) makes this claim.}

Meanwhile, `programming language' has come to mean something like `algorithmic language', i.e.,
methods for algorithmic computation, variable naming, function definition, program partitioning, etc.
I/O `isn't part of the language' or `shouldn't be part of the language' (!).\footnote{Thus excluding denotational semantics from `the language'\ldots.}
The problem with this position\footnote{Beyond the fact that you can't interpret I/O operations in an arbitrary model of a language that lacks them!}
is that it justifies the neglect of I/O that programming language designers have traditionally lavished on it.
Almost every language has genuinely wretched I/O facilities,
precisely because of the second-class status assigned to I/O by the modern concept of `programming language'.
Global Script thus includes I/O `in the language', not only because that is the only way to give a denotation for I/O,
but because I/O deserves the same careful design as any other aspect of the language.

The Global Script Program (not programming!) Calculus is a general syntax for writing programs,
together with rules for manipulating them ---
consisting of a static semantics (type system),
denotational semantics,\footnote{Meaningful meaning\ldots}
operational semantics (only for expression evaluation),
and formal semantics (equational theory).
The Global Script Program Calculus provides an `algorithmic language' in its expression syntax, data types, and operational semantics;
it also provides a module system, including support for abstract data types and for encapsulating business logic,
allowing for extensions, libraries, and allowing the large-scale structure of a program to be expressed within the language.
It thus provides everything a programming language needs, \emph{except} the environment-specific features.
In that sense, it is a genuinely environment-independent language.
But not a \emph{programming} language, because you can't program anything with it!

However, the Global Script Program Calculus can easily be extended with operations for programming a specific machine.
To allow libraries to be universal,
we use the classic pure-functional approach
of adding a new type for programs in each environment,
with operations that construct / return such programs,
including so-called \emph{combinators} that take parts of programs
and combine them into larger programs.
Then, the type system distinguishes between different environments,
allowing libraries to be used cross-environment,
but not allowing subprograms for one environment to be invoked incorrectly within another environment
which doesn't provide the operations they need.

The type of programs for each environment, together with its operations,
is called a `programming language' in Global Script,
and, in general, the term `language' is used freely for the API for any specific area.

Currently, the major programming languages provided include:
\begin{itemize}
    \item Global Script Log --- a logical markup language;
    \item Global Script Set --- a page description language;
    \item Global Script Type --- ditto, but for Unix terminals;
    \item IBIO --- a concurrent stream I/O language, suitable for writing Unix filters (and, although not designed for them, compilers);
    \item Cord --- a relational database language;
    \item Dance --- an FRP GUI language; and
    \item Guisen --- a procedural GUI language.
\end{itemize}

\section{Syntax}

This document contains no formal syntax for the language;
instead, the intention is that the mapping from the abstract syntax given here back to concrete syntax be simple enough to not need a repetitive specification.

Global Script has a handful of special symbols: \<, ; .\> and delimiters such as \<( ) [ ] \{ \} \langle \rangle \llangle \rrangle\>;
otherwise, most non-whitespace symbols are treated as being part of identifiers (or keywords).

An identifier consists of a sequence of one or more components separated by \<.\> characters (with no intervening whitespace);
the three types of components are
\begin{itemize}
  \item \defn{alphanumeric} components, which consist of a lower-case letter followed by 0 or more alphanumeric letters;
  \item \defn{numeric} components, which consist of a sequence of 1 or more decimal digits (two numeric components with the same value, e.g. \<01\> and \<1\>, are considered identical); and
  \item \defn{symbolic} components, which consist of a sequence of 1 or more symbols, other than \<, ; .\> or a delimiter.
\end{itemize}
A symbolic component may only be the final component in an identifier.

\section{Type System}

Global Script has a standard natural deduction-based type system, based on \defn{judgment}s of the form
\begin{displaymath}
    \Gamma \sequent \text{conclusion}
\end{displaymath}
The context \<\Gamma\> several classes of variables (type variables, object variables, views, etc.) to various sorts of meta-data (kinds, types, implicit arguments, macro properties, etc.).
Nevertheless, the context will generally be treated as a single object, except in the denotational semantics,
where it will be split into a kind context \<\Delta\> and a type context \<\Gamma\>.

\section{Models and Denotations}

Note: `semantics' means `meaning'; specifically, the kind of detailed meaning that might be found in a language specification.
`Denotation' means `meaning'; specifically, the kind of formal meaning that might be found in a language specification.
So `denotational semantics' is redundant.
End note.

A \defn{model} of Global Script is a (directed-)complete partial order-enriched category $\mathcal{C}$ with:
\begin{itemize}
    \item Finite products indexed by sets of Global Script identifiers (note that this implies in particular the existence of a terminal object \<\star\>);
    \item Finite coproducts indexed by sets of Global Script identifiers (note that this implies in particular the existence of an initial object \<\epsilon\>);
    \item Exponentials;
    \item An existential quantifier, which is a functor $\exists : \mathcal{C}^\kappa \to \mathcal{C}$, which is the left adjoint of the constant functor $K : \mathcal{C} \to \mathcal{C}^\kappa$, for $\kappa$ at least the denotations of the kind environments as defined below; and
    \item A universal quantifier, which is a functor $\forall : \mathcal{C}^\kappa \to \mathcal{C}$ which is the right adjoint of of the constant functor $K : \mathcal{C} \to \mathcal{C}^\kappa$, for $\kappa$ at least the denotations of the kind environments as defined below;
\end{itemize}
together with a designated \defn{lifting monad}, which is a monad \<\lift{\emdash}\> on $\mathcal{C}$ together with a natural transformation $\bot : K\star \to \lift{\emdash}$ so that $\bot_\alpha \circ \star_\beta$ is the least homomorphism $: \beta \to \lift{\alpha}$ for all objects $\alpha$, $\beta$.

Note: we need a couple of other things:
\begin{itemize}
    \item A `strength' $: \exists (K\alpha \times F) \to \alpha \times \exists F$;
    \item A way to `lift' $\exists$ and $\forall$ to functors with more than one argument (eliminating only the last one).
\end{itemize}
These seem like they should be definable in any category, though.
TODO: Will need to confirm / deny that.

For the purpose of the denotational semantics, contexts will be divided into two pieces:
a kind environment $\Delta$ and a type environment $\Gamma$.
The kind environment $\Delta$ can be thought of as a mapping from type variables to kinds;
the denotation of a kind is a category, and the denotation of a type environment $\Delta$, written $\Den{\Delta}$, is
\begin{displaymath}
    \prod_{t\in Dom\Delta}\Kind{\Delta(t)}
\end{displaymath}
The denotation of the type environment $\Gamma$, which will be written $\Den{\lambda\Delta.\Gamma}$, will be a functor $F : \Den{\Delta} \to \mathcal{C}$.

\section{Equational Theory}

The equational theory of Global Script, like the type system, consists of judgments of the form
\begin{equation}
    \Gamma \sequent P
\end{equation}
where, however, \<\Gamma\> is a sequence of type assignments and \emph{equational propositions} and \<P\> is an equational proposition.
If you like, you can read this as `\<P\> is deducible from \<\Gamma\>'.

An equational proposition is formed from the propositional connective \<\land\>,
universal quantifiers \<\forall\>
(over Global Script type assignments, so \<\forall \pvar{x} :: \tau\> where \<x\> is a Global Script variable and \<\tau\> its type),
and seven forms of atoms:
\begin{itemize}
    \item \defn{Equations} of the form \<e_0 = e_1\>, between two expressions of the same type;
    \item \defn{Pattern match success assertions} of the form \<p \match e\>, read `\<p\> \defn{matches} \<e\>';
    \item \defn{Pattern match failure  assertions} of the form \<p \match e\fails\>, read `\<p\> \defn{fails to match} \<e\>';
    \item \defn{Pattern match divergence assertions} of the form \<p \match e\diverges\>, read `the match of \<p\> against \<e\> \defn{diverges}';
    \item \defn{Generator success assertions} of the form \<g\>, read `\<g\> \defn{succeeds}';
    \item \defn{Generator failure assertions} of the form \<g\fails\>, read `\<g\> \defn{fails}'; and
    \item \defn{Generator divergence assertions} of the form \<g\diverges\>, read `\<g\> \defn{diverges}'.
\end{itemize}
There is a technical ambiguity wether the propositions \<p \match e\>, \<p \match e\fails\>, and \<p \match e\diverges\>
are about the pattern \<p\> and expression \<e\> or the generator \<p \match e\>,
but since the meaning is the same in either case the ambiguity does not matter,
and will be clarified in those cases where which is meant is not immediate.

\section{Operational Model}

\section{Implementations}

An \defn{implementation} of a Global Script program is a program or machine that stores the program internally.
On request, it will evaluate that program to WHNF and, if successful, reports the value;
if the value is a function it will further permit Global Script expressions of the correct type to be supplied as arguments,
and will calculate and report their values.
If the value is a data value, of sum or product type, it will allow the components to be evaluated in the same way.

Note that an implementation is necessarily interactive and works with a client;
implementations on general-purpose computers will generally be libraries rather than complete programs.
Nothing in this chapter is intended to disallow the creation of interpreters that take programs, evaluate them to normal form, and print the results;
however, such a program, because it attaches additional semantics beyond that of the pure calculus,
is properly an implementation of a language based on the calculus and not of the Global Script program calculus itself.
Similar considerations apply to an implementation that assigns semantics to Global Script expressions to encode
I/O, database access, web servers, GUIs, or type-setting
and allow those to be programmed in Global Script.

A \defn{correct} implementation of the Global Script program calculus is an implementation that, given a program or component thereof,
exhibits the following behavior:
\begin{itemize}
  \item Correctly reports that the expression has a WHNF if it has one, and provides correct access to its components or gives the value if it is a primitive;
  \item Correctly reports that the expression has no WHNF if it lacks one; or
  \item Runs forever if the expression has no WHNF.
\end{itemize}
Note that it is impossible to realize a correct implementation of the Global Script program calculus as a physical object,
or to implement one on a general-purpose computer.
We thus say that Global Script is \defn{un-implementable}.
Any two expressions of the same type that lack a WHNF are equivalent according to the calculus;
however, two such expressions may exhibit different behavior when run by such an implementation,
if it is able to determine that the one expression lacks a WHNF but is unable to make that determination for the other.

A \defn{partially correct} implementation of the Global Script program calculus is an implementation that, given a program or component thereof,
exhibits the following behavior:
\begin{itemize}
  \item Correctly reports that the expression has a WHNF if it has one, and provides partially correct access to its components or gives the value if it is a primitive;
  \item Correctly reports that the expression has no WHNF if it lacks one;
  \item Runs forever if the expression has no WHNF; or
  \item Reports that it is unable to find a WHNF for the given expression.
\end{itemize}
Note that two expressions that are equivalent according to the calculus may exhibit different behavior when run by such an implementation,
even if they have a WHNF,
because the implementation may be able to find a WHNF for one program but unable to do so for the other.

\chapter{Object Expressions}

The judgment form for an expression $e$ in context $\Gamma$ is
\begin{equation}
    \Gamma \sequent e :: \tau
\end{equation}
for some type $\tau$.

The denotation of an expression will be a natural transformation $\Expr{\Delta, \Gamma \sequent e :: \tau} : \Den{\lambda\Delta.\Gamma} \to \Type{\lambda\Delta.\tau}$.

\section{Variables}
\label{sec:variables}

The judgment form for a variable \<v\> in context \<\Gamma\> is
\begin{equation}\label{eqn:var-judgment}
    \Gamma \sequent v :: \overline{\tau_i :: \kappa_i}_{i=0}^{n-1}; \overline{a_j :: \tau_j}_{j=n}^{n+m-1}; \tau
\end{equation}.
\begin{itemize}
    \item $\overline{\tau_i :: \kappa_i}_{i=0}^{n-1}$ is a sequence of \defn{default type arguments} and their kinds,
    \item $\overline{a_j :: \tau_j}_{j=n}^{n+m-1}$ is a sequence of \defn{default arguments} and their types, and
    \item $\tau$ is the (monomorphic) type of the variable term.
\end{itemize}
The meta-variable \<v\> can stand for a simple identifier (this case will be written \<x\>, \<x_i\>, etc.), or for an application (see below).

A variable has no denotation, but see section \ref{subsec:var-exprs} below.

\subsection{Variables Without \kwd{implicit} Declarations}

\begin{prooftree}
    \AxiomC{$\Gamma \sequent \overline{\tau_i :: \kappa_i}$}
    \UnaryInfC{
        \<\Gamma, x :: \forall\;\overline{'\alpha_i :: \kappa_i}. \tau \sequent x :: \overline{\tau_i :: \kappa_i}; ; \tau'\>
    }
\end{prooftree}
\begin{itemize}
    \item $i \in [0, n)$;
    \item $\Gamma$ does not contain an \<\implicit\> declaration for $x$;
    \item $\tau'$ means $[\overline{\alpha_i\to\tau_i}]\tau$,
        the result of substituting the type arguments for the $\forall$-bound variables in $\tau$.
\end{itemize}

\subsection{Variables With \kwd{implicit} Declarations}

\begin{prooftree}
    \AxiomC{$\Gamma \sequent \overline{\tau_i :: \kappa_i}$}
    \AxiomC{$\Gamma \sequent \overline{e_j :: \tau'_j}$}
    \BinaryInfC{
        \<\Gamma, x :: \forall\;\overline{'\alpha_i :: \kappa_i}. \overline{\tau_j} \to \tau, \implicit\;x\;\overline{e_j} \sequent x :: \overline{\tau_i :: \kappa_i}; \overline{e_j :: \tau'_j}; \tau'\>
    }
\end{prooftree}
\begin{itemize}
    \item $i \in [0, n)$, $j \in [n, n + m)$;
    \item $\tau'_j$ means $[\overline{\alpha_i\to\tau_i}]\tau_j$,
        the result of substituting the type arguments for the $\forall$-bound variables in $\tau_j$;
    \item $\tau'$ means $[\overline{\alpha_i\to\tau_i}]\tau$,
        the result of substituting the type arguments for the $\forall$-bound variables in $\tau$.
\end{itemize}

\subsection{Explicit Type Applications}

\begin{prooftree}
    \AxiomC{$\Gamma \sequent v :: \tau_0 :: \kappa_0, \overline{\tau_i :: \kappa_i}; \overline{e_j :: \tau_j}; \tau$}
    \UnaryInfC{
        \<\Gamma \sequent v\;@(\type\;\tau_0) :: \overline{\tau_i :: \kappa_i}; \overline{e_j :: \tau_j}; \tau\>
    }
\end{prooftree}
($i \in [1, n)$, $j \in [n, n + m)$).

\subsection{Explicit Applications}

\begin{prooftree}
    \AxiomC{$\Gamma \sequent v :: \overline{\tau_i :: \kappa_i}; e_n :: \tau_n, \overline{e_j :: \tau_j}; \tau$}
    \AxiomC{$\Gamma \sequent e :: \tau_n$}
    \BinaryInfC{
        $\Gamma \sequent v\;@e :: \overline{\tau_i :: \kappa_i}; \overline{e_j :: \tau_j}; \tau$
    }
\end{prooftree}
($i \in [1, n)$, $j \in [n + 1, n + m)$).

\subsection{Variables Used as Expressions}
\label{subsec:var-exprs}

\begin{prooftree}
    \AxiomC{$\Gamma \sequent v :: \overline{\tau_i :: \kappa_i}; \overline{e_j :: \tau_j}; \tau$}
    \UnaryInfC{$\Gamma \sequent v :: \tau$}
\end{prooftree}
($i \in [1, n)$, $j \in [n, n + m)$).

\subsection{TODOs}

\begin{itemize}
    \item Really shouldn't require explicit arguments to be well-typed unless they end up being used.
\end{itemize}

\section{Functions}

\subsection{Function Literals}

Lambda terms have the rule:\footnote{See \chapterref{patterns}, Patterns}
\begin{prooftree}
    \AxiomC{$\Gamma \sequent p :: \tau_1 \provides \Gamma'$}
    \AxiomC{$\Gamma, \Gamma', \sequent e :: \tau_2$}
    \BinaryInfC{$\Gamma \sequent \lambda{} p. e :: \tau_1 \to \tau_2$}
\end{prooftree}
The pattern $p$ must be a lax or strict (not monoidal) pattern; see \sectionref{pattern-classes}, Classes of Patterns.
BUG: $\lambda$ takes \emph{multiple} patterns (0 or more).
End BUG.

\subsection{Applications}

Applications have the rule:
\begin{prooftree}
    \AxiomC{$\Gamma \sequent e_1 :: \tau_1 \to \tau_2$}
    \AxiomC{$\Gamma \sequent e_2 :: \tau_1$}
    \BinaryInfC{$\Gamma \sequent e_1\hsap e_2 :: \tau_2$}
\end{prooftree}

\section{\kwd{for} Expressions}

\<\for\> expressions are used to make local definitions within an expression.
The syntax is \<\inlinefor{\hsinf{generators}}{\hsinf{body expression}}\>.
The generators in a \<\for\> are non-recursive, but cannot shadow variables defined in the same \<\for\>.

In the simplest case, the generators in a \<\for\> are all let and (non-monoidal) match generators.
\begin{prooftree}
    \AxiomC{\<\Gamma \sequent \overline{g_i} \provides \Gamma'\>}
    \AxiomC{\<\Gamma, \Gamma', \sequent e :: \tau\>}
    \BinaryInfC{\<\Gamma \sequent (\inlinefor{\overline{g_i}}{e}) :: \tau\>}
\end{prooftree}

\<\for\> can also be used to name intermediate values inside a monad.
E.g. \<\inlinefor{'x \from e_0}{e_1}\>.
The type rule for this is
\begin{prooftree}
    \AxiomC{\<\Gamma \sequent \module\;monad.c\;m\>}
    \AxiomC{\<\Gamma \sequent \overline{g_i} \provides_m \Gamma'\>}
    \AxiomC{\<\Gamma, \Gamma', \sequent e :: m\;\tau\>}
    \TrinaryInfC{\<\Gamma \sequent \inlinefor{\overline{g_i}}{e} :: m\;\tau\>}
\end{prooftree}

As might be expected, the monad structure to use in de-sugaring this syntax can be over-ridden:
\begin{prooftree}
    \AxiomC{\<\Gamma \sequent mon :: monad.t\;m\>}
    \AxiomC{\<\Gamma \sequent \overline{g_i} \provides_m \Gamma'\>}
    \AxiomC{\<\Gamma, \Gamma', \sequent e :: m\;\tau\>}
    \TrinaryInfC{\<\Gamma \sequent \for\;@{}mon\;(\overline{g_i})\;e :: m\;\tau\>}
\end{prooftree}

The sequence of generators inside the \<()\> in a \<\for\> can either be a single generator or a sequence of 0 or more generators terminated by semi-colons.
In the special case of a single \<\rec\> generator, the syntax \<\for\;(\rec(\overline{g_i}))\> can be abreviated to \<\for\;\rec\;(\overline{g_i})\>.

\section{Branch Expressions}

An \<\analyze\> expression,
Syntactically, \<\analyze\ \overline{expr_i} \overline{\case\ \overline{p_{ji}}. body_j}\>,
takes a sequence of scrutinee expressions and matches them against the patterns in the cases,
top-to-bottom and left-to-right.
If matching a scrutinee against any pattern diverges or no case matches evaluation diverges;
otherwise the \<\analyze\> expression evaluates to the body of the first matching case.
Note: if a case matches and matching the scrutinees against the patterns in a previous case diverges,
evaluation diverges.
If a case matches and matching the scrutinees against a subsequent case diverges,
the evaluation proceeds with the body of the matching case.

This syntax has a `dangling else' problem when a \<\case\> ends with an \<\analyze\> expression;
this is resolved as usual by associating each \<\case\> to the nearest preceding \<\analyze\> expression.
This resolution can be over-ridden by putting parentheses around the inner \<\analyze\> expression or its enclosing \<\case\>.

\subsection{Cases}

The judgment form for \<\case\> terms is:
\begin{haskell}
    \Gamma;  \sequent \case\ \overline{p_i}. e :: \overline{\tau_i} \rightarrow \tau
\end{haskell}

Single cases type thus:

\begin{prooftree}
    \AxiomC{$\Gamma \sequent \tau :: *$}
    \AxiomC{$\Gamma \sequent e :: \tau$}
    \BinaryInfC{$\Gamma \sequent \case.\;e ::\;\rightarrow\ \tau$}
\end{prooftree}

\begin{prooftree}
    \AxiomC{$\Gamma \sequent \tau :: *$}
    \AxiomC{$\Gamma \sequent p_0 :: \tau_0 \rhd \Gamma'$}
    \AxiomC{$\Gamma, \Gamma', \sequent \case\;\overline{p_i}.\;e :: \overline{\tau_i} \rightarrow \tau$}
    \TrinaryInfC{$\Gamma \sequent \case\;p_0,\;\overline{p_i},.\;e :: \tau_0,\;\overline{\tau_i}, \rightarrow \tau$}
\end{prooftree}
NB: \<p_0, \overline{p_i}\> should define disjoint sets of variables.
This has implications.
The principle is --- hrm.
So we have a can-be-bound-by set for a pattern --- in a context --- and then an is-bound-by function for sequences/sets of patterns.
Usually these are the same.
However, certain patterns do \emph{not} bind variables that can be bound by other patterns (whether they are or not).
But that all goes in the Patterns chapter (Chapter \ref{patterns}).

\chapter{Patterns}
\label{patterns}

The judgment form for patterns is
\begin{equation}
    \Gamma \sequent \overline{p_i :: \tau_i} \provides \Gamma'
\end{equation}

\section{Concatenating Sequences of Patterns}

\begin{prooftree}
    \AxiomC{$\Gamma \sequent \overline{p_i :: \tau_i} \provides \Gamma'_1$}
    \AxiomC{$\Gamma \sequent \overline{p_j :: \tau_j} \provides \Gamma'_2$}
    \BinaryInfC{$\Gamma \sequent \overline{p_i :: \tau_i}, \overline{p_j :: \tau_j}, \provides \Gamma'_1, \Gamma'_2,$}
\end{prooftree}
($i \in [0, n)$, $j \in [n, n+m)$).
The bound variables of the patterns must all be distinct.
TODO: need a way to handle module patterns \<\module\;'m\>,
for which the bound variables are selected to be distinct from any other patterns in the same sequence.
The rule is basically: calculate the set of variables which \emph{could} be bound by any given pattern.
Then each \<\module\;'m\> pattern brings into scope those variables which could be bound by it,
and which cannot be bound by any other pattern.
This only applies to $\module$ patterns with no export list,
or whose export list contain $..$ .  See \chapterref{modules}, Modules.
End TODO.

\section{Classes of Patterns}
\label{pattern-classes}

\begin{itemize}
    \item \defn{Lax} patterns are precisely these:
        \begin{itemize}
            \item Pattern variables \<'x\>;
            \item Wildcard patterns \<\_\>;
            \item Module patterns where:
                \begin{itemize}
                    \item there is no export list, e.g. \<\module\;'m\>,
                    \item there is a simple export list, e.g. \<\module\;'m.(x, y, z,)\>,
                    \item there is a complex export list,
                        e.g. \<\module\;'m.\left(\hsalign[c]{x = p_0,\\y = p_1,\\z = p_2,}\right)\>,
                        where all of the patterns given for the members are themselves lax;
                    \end{itemize}
                \item Lazy patterns \<\sim{}\!p\>; and
                \item Parallel patterns \<\parallel\!p\>.
        \end{itemize}
    \item \defn{Strict} patterns are precisely those patterns of the form \<!p\>.
    \item \defn{Monoidal} patterns are precisely those patterns that are neither lax nor strict.
\end{itemize}

\section{Specific patterns}

\paragraph{Pattern variables}
Pattern variables have the syntactic form \<'x\>, the ASCII apostrophe followed by a variable name.
Pattern variables where the variable is an infix operator need to be enclosed in parentheses, e.g., \<('+)\>
\begin{prooftree}
    \AxiomC{$\Gamma \sequent \tau :: *$}
    \UnaryInfC{$\Gamma \sequent\; 'x :: \tau \provides x :: \tau$}
\end{prooftree}

\paragraph{Wildcard Patterns}
\begin{prooftree}
    \AxiomC{$\Gamma \sequent \tau :: *$}
    \UnaryInfC{$\Gamma \sequent \_ :: \tau \provides$}
\end{prooftree}

\paragraph{Views}
The typing judgment for views has the form $\Gamma \sequent \view\;v :: \overline{\tau_i}; \tau$, for $i \in [0, n)$.
This means:
\begin{itemize}
    \item $v$ is a view,
    \item $v$ has arrity $n$,
    \item $v$'s arguments have types $\tau_i$, respectively, and
    \item $v$'s result has type $\tau$.
\end{itemize}
Note that, if $v$ is both a view and a function, \emph{it need not have the same type in both cases}.
Nor, if it does have the same type, need its definition as a view and as a function have any specific relation.
Nevertheless giving them the same type and relating the definitions in some (documented) way is strongly recommended.
Global Script does not draw a distinction between constructors and views.
\begin{prooftree}
    \AxiomC{$\Gamma \sequent \view\;v :: \overline{\tau_i}; \tau$}
    \AxiomC{$\Gamma \sequent \overline{p_i :: \tau_i} \provides \Gamma'$}
    \BinaryInfC{$\Gamma \sequent v\;\overline{p_i} :: \tau \provides \Gamma'$}
\end{prooftree}
TODO: How do you declare views?  How do views and constructors interract, exactly? End TODO.

TODO: Existential types.  End TODO.

Language TODO: Expression arguments to views (e.g., \<n+m\> patterns).  End TODO.

\section{Reasoning at the Source Level}

Source-level reasoning about programs uses three predicates:
\begin{itemize}
    \item \<p \match e\diverges\>, read ``matching pattern \<p\> against expression \<e\> diverges''.
    \item \<p \match e\fails\>, read ``matching pattern \<p\> against expression \<e\> fails''.
    \item \<p \match e\>, read ``matching pattern \<p\> against expression \<e\> succeeds''.
\end{itemize}
Note that, for a given pattern \<p\> and expression \<e\>, precisely one of these predicates will hold.

If \<p \match e\>, the syntax \<\Pat{p \match e}\> will be used to denote the value environment induced by the pattern match;
\<\Pat{p \match e}e1\> will be used to denote \<e1\> with the values bound by \<p\>:
\begin{haskell}
    \Expr{\Pat{p \match e}e1}\eta = \Expr{e1}\{\eta;\Pat{p \match e}\}
\end{haskell}
If \<p \match e\diverges\> or \<p \match e\fails\>, \<\Pat{p \match e}\> and \<\Pat{p \match e}e1\> will be undefined.

We have a few basic cases:
\begin{prooftree}
    \AxiomC{}
    \UnaryInfC{\<'x \match e\>} 
\end{prooftree}

For a basic view pattern \<v \overline{p_i}\>, when matching against an expression \<e\>,
use a pattern matching algorithm as follows:
\begin{itemize}
    \item First consider the expression \<'d = match v bool.false (\inlinelambda{\overline{'x_i}}{bool.true}) e\>.
        \begin{itemize}
            \item If \<d = \bot\>, \<v \overline{p_i} \match e\diverges\>.
            \item If \<d = bool.false\>, \<v \overline{p_i} \match e\fails\>.
        \end{itemize}
        Otherwise, \<d = bool.true\>.
    \item Second, if \<d = bool.true\>, let \<t_0 = match v \error (\inlinelambda{\overline{'x_i}}{\inlinetuple{\overline{x_i,}}}) e\>.
        Let \<\overline{x_i = \#i t_0}\> be the components of \<t_0\>.
        \begin{itemize}
            \item If, for any $'k\in[0,n)$, \<\forall\ 'i\in[0,k). p_i \match x_i\> and \<p_k \match x_k\diverges\>,
                \<v \overline{p_i} \match e\diverges\>.
            \item If, for any $'k\in[0,n)$, \<\forall\ 'i\in[0,k). p_i \match x_i\> and \<p_k \match x_k\fails\>,
                \<v \overline{p_i} \match e\fails\>.
            \item Otherwise, for all $'i\in[0,n)$, \<p_i \match x_i\>.
                In this case, \<v \overline{p_i} \match e\>
                and \<\Pat{v \overline{p_i} \match e}\> is the concatenation of \<\overline{\Pat{p_i \match x_i}}\>.
        \end{itemize}
\end{itemize}

\chapter{Generators}

The judgment form for generators is:
\begin{haskell}
  \Gamma \sequent g \provides \Gamma'
\end{haskell}
\<g\> can be a single generator, or a sequence of (semicolon-terminated) generators.
This is read ``In type environment \<\Gamma\>,
the generator(s) \<g\> is (are) well-typed
and induce(s) the type environment \<\Gamma'\>.

\defn{Monoidal} generators can fail at run time, which is indicated by using a judgment of the form
\begin{haskell}
  \Gamma \sequent g \provides^? \Gamma'
\end{haskell}

\defn{Monadic} generators run in a particular monad, which is indicated by using a judgment of the form
\begin{haskell}
  \Gamma \sequent g \provides_m \Gamma'
\end{haskell}

And, finally, there are \defn{monadic monoidal} generators:
\begin{haskell}
  \Gamma \sequent g \provides_m^? \Gamma'
\end{haskell}

Some simple generators are:
\begin{prooftree}
  \AxiomC{\<\Gamma \sequent p :: \tau \provides \Gamma'\>}
  \AxiomC{\<\Gamma \sequent e :: \tau\>}
  \BinaryInfC{\<\Gamma \sequent p \propto e \provides \Gamma'\>}
\end{prooftree}
\begin{prooftree}
  \AxiomC{\<\Gamma \sequent p :: \tau \provides^? \Gamma'\>}
  \AxiomC{\<\Gamma \sequent e :: \tau\>}
  \BinaryInfC{\<\Gamma \sequent p \propto e \provides^? \Gamma'\>}
\end{prooftree}

\chapter{Types}

\chapter{Modules}
\label{modules}

\chapter{Overloading}

\chapter{IDMC}

IDMC is more complicated than other aspects of the language,
because each QLO can define its own syntax and type system for that syntax.

So the judgement form for QLO bits is:
\begin{haskell}
    \Gamma \sequent \hsinf{text} ::_{qlo} \tau
\end{haskell}
\<\hsinf{text}\> is a bit of marked-up text; \<qlo\> is a QLO.

The master inference rule for QLOs then is:
\begin{prooftree}
    \AxiomC{\<\Gamma \sequent \hsinf{text} ::_{qlo} \tau\>}
    \UnaryInfC{\<\Gamma \sequent qlo\{\hsinf{text}\} :: \tau\>}
\end{prooftree}
The curly braces \<\{\}\> can be replaced with any delimiters you want (only in this construct).

Expression interpolations:
\begin{prooftree}
    \AxiomC{\<\Gamma \sequent e :: \tau\>}
    \UnaryInfC{\<\Gamma \sequent \S(e) ::_{qlo} \tau\>}
\end{prooftree}

Text interpolations:
\begin{prooftree}
    \AxiomC{\<\Gamma \sequent \hsinf{text} ::_{qlo} \tau\>}
    \UnaryInfC{\<\Gamma \sequent \S\{\hsinf{text}\} ::_{qlo} \tau\>}
\end{prooftree}

\paragraph{Variable/macro interpolations}
Macro interpolations have the form
\begin{haskell}
    \S{}x@(\type{} \tau_0)\ldots@(\type{} \tau_{n-1})@arg_0\ldots@arg_{m-1}arg_m\ldots{}arg_{m+n-1}
\end{haskell}
where each \<arg\>,
whether optional or required,
has the form \<\{\hsinf{text}\}\> or \<(exp)\>.

The judgment form for a macro interpolation is
\begin{haskell}
    \Gamma \sequent v :: \overline{\tau_i :: \kappa_i}; \overline{a_j :: \tau_j}; \overline{qlo_k}; \tau
\end{haskell}
where each \<qlo_k\> is either a QLO name or \<\_\>.
The empty sequence at the end of the sequence \<\overline{qlo_k}\> is equivalent to an infinite sequence of \<\_\>s.

If \<\Gamma\> contains no \<\macro\> declaration for \<x\>:
\begin{prooftree}
    \AxiomC{\<\Gamma \sequent x :: \overline{\tau_i :: \kappa_i}; \overline{a_j :: \tau_j}; \tau\>}
    \AxiomC{\<\overline{\Gamma \sequent \tau_i :: \kappa_i}\>}
    \BinaryInfC{\<\Gamma \sequent \S{}x ::_{qlo} \overline{\tau_i :: \kappa_i}; \overline{a_j :: \tau_j}; \tau\>}
\end{prooftree}
Otherwise:
\begin{prooftree}
    \AxiomC{\<\macro\;x\;\overline{qlo_k} \in \Gamma\>}
    \AxiomC{\<\Gamma \sequent x :: \overline{\tau_i :: \kappa_i}; \overline{a_j :: \tau_j}; \tau\>}
    \AxiomC{\<\overline{\Gamma \sequent \tau_i :: \kappa_i}\>}
    \TrinaryInfC{\<\Gamma \sequent \S{}x ::_{qlo} \overline{\tau_i :: \kappa_i}; \overline{a_j :: \tau_j}; \overline{qlo_k}; \tau\>}
\end{prooftree}

\chapter{Programs}

The judgment form for whole programs is
\begin{haskell}
    \sequent\;\langle\overline{g_i}; d\rangle:: \langle\Gamma; \tau\rangle
\end{haskell}
The type environment must be empty because whole programs include the entire library and so can have no free variables.

A program consists of a sequence of generators and a §defn{document};
ideally, Global Script implementations should assemble programs from separately maintained components,
including the §defn{standard library} (see \chapterref{stdlib}).\footnote{So including multiple components in the program isn't really optional.}
A program's value is the value of its document.

TODO: The standard library and the standard libraries of languages like IBIO and CORD are quite magic in bringing things into scope there's no way to define in the language.  End TODO.

The generators in a program (at the top level) must be:
\begin{itemize}
    \item Match generators \<p \match e\> where \<p\> is lax;
    \item Let generators \<'f \overline{p_i} = e\>;
    \item Type signatures \<x :: \sigma\>; and
    \item Recursive groups \<\rec\;(\overline{g_i})\> where all the \<g_i\> are otherwise legal at the top level.
\end{itemize}

Implementations may and are likely to further restrict accepted top-level generators;
they must support these cases:
\begin{itemize}
    \item Match generators \<p \match e\> defining variables in a single module.
        (When defining multiple variables,
        the best way to ensure this is to use a generator of the form
        \<module 'm.(\hsinf{export list}) \match e\>).

    \item Functions defined by a single let equation \<'f \overline{p_i} = e\>.
        Note that using monoidal patterns in such an equation must be legal,
        but is sub-optimal programming practice as it must be an error for any pattern in the head to fail.
\end{itemize}

The inference rule from programs is
\begin{prooftree}
    \AxiomC{\<\sequent\;\overline{g_i} \provides \Gamma\>}
    \AxiomC{\<\Gamma\sequent d :: \tau\>}
    \BinaryInfC{\<\sequent\;\langle \overline{g_i}; d\rangle :: \langle \Gamma; \tau\rangle\>}
\end{prooftree}

\chapter{Documents}

\begin{prooftree}
    \AxiomC{\<\Gamma\sequent e :: \tau\>}
    \UnaryInfC{\<\Gamma\sequent e :: \tau\>}
\end{prooftree}

\begin{prooftree}
    \AxiomC{\<\Gamma, \Gamma' \sequent \overline{g_i} \provides \Gamma'\>}
    \AxiomC{\<\Gamma, \Gamma' \sequent e :: \tau\>}
    \BinaryInfC{\<\Gamma \sequent e\;(\where\;\overline{g_i}) :: \tau\>}
\end{prooftree}
The parentheses around the \<\where\> clause can be omitted when there is only one generator,
in which case that generator must not have a trailing \<;\>, as usual.
The standard limits on the generators legal in a \<\where\> clause apply

TODO: Have we said what the `standard limits' on \<\where\> clauses are yet?  End TODO.

A §defn{document} is an expression together with an optional \<\where\> clause.
The document \<e\;(\where\;\overline{g_i})\> is equivalent to the expression \<\for\;\rec\;(\overline{g_i})\;e\>,
as might be expected.
(Except that more generators are legal in a \<\for\> than in a \<\where\>.)

\chapter{Standard Library}
\label{stdlib}

\chapter{Examples}

\section{Fibionacci Numbers}

\begin{haskell}
    \pvar{fibs} \propto 0 : 1 : map_2 @by.zip (+) fibs (drop 1 fibs);
\end{haskell}

\section{Prime Numbers}

\begin{haskell}
    \pvar{primes} = w 2 (repeat true) \blockwhere{
        \pvar{w} !\pvar{n} (\pview{false} : \pvar{bs}) &\reduceto w (n + 1) bs; \\
        \pvar{w} !\pvar{p} (\pview{true} : \pvar{bs}) &\reduceto p : w (p + 1) (set (chunksof p \circ elems \circ last) false bs);
    };
\end{haskell}

\section{\sh{gstype} Hello, World}

\begin{haskell}
    \qq{Hello, world!$\backslash$n}
\end{haskell}

\section{\sh{gsdraw} Hello, World}

\begin{haskell}
    text \str{Hello, world!}
\end{haskell}

\section{Dance Hello, World}

\begin{haskell}
    text \str{Hello, world!}
\end{haskell}

\section{IBIO \sh{echo}}

\begin{haskell}
    \inlinefor{\pvar{as} \leftarrow getM env.args}{send \$ concat (intersperse \qq{\ } as) <> \qq{$\backslash$n}}
\end{haskell}

\section{IBIO \sh{cat}}

\begin{haskell}
    \inlinefor{\pvar{as} \leftarrow getM env.args}{\blockanalyze{as}{%
        \case\ \pview{nil}. cat \\
        (\case\ \_. foreachM \$ \blocklambda{\pvar{a}}{
            \inlinefor{\pvar{eif} \leftarrow file.open \omode{r} \$ file.name.in a}{\blockanalyze{eif}{
                \case\ \pview{left} \pvar{e}. abend e \\
                \case\ \pview{right} \pvar{if}. cat \ifrom{} if
            }}
        })
    }} \inlinewhere{
        \pvar{cat} = \inlinefor{\pvar{s} \leftarrow receive (many symbol)}{send s}
    }
\end{haskell}

\section{IBIO \sh{wc}}

\begin{haskell}
    \pvar{wc} = \inlinefor{\pvar{ls} \leftarrow receive (many line)}{unit !(foldl.! accum init ls)} \blockwhere{
        \pvar{init} \propto \structure{
            \pvar{lines} \propto 0; \\
            \pvar{words} \propto 0; \\
            \pvar{runes} \propto 0;
        }; \\
        \pvar{accum} \pvar{as} (\pvar{l} :: vector.t rune.t) = \structure{
            !\pvar{lines} \propto as \#lines + 1; \\
            !\pvar{words} \propto as \#words + (l =\sim split \matchre{$\backslash${}s+}) \#length; \\
            !\pvar{runes} \propto as \#runes + l \#length;
        };
    };
\end{haskell}

\end{document}
