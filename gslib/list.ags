	.prefix

	.data

list.nil	.closure	_list.nil.c
list.:	.closure	_list.:.c

list.null	.closure	_list.null_c

list.foldr	.closure	_list.foldr_c	_list.foldr_ty
list.foldr1	.closure	_list.foldr1_code	_list.foldr1_ty
list.map	.closure	_list.map_c	_list.map_ty
list.filter	.closure	_list.filter_c	_list.filter_ty

list.foldl	.closure	_list.foldl_c	_list.foldl_ty
list.reverse	.closure	_list.reverse_c

list.singleton	.closure	_list.singleton_c
list.<>	.closure	_list.<>.code	_list.<>.ty

list.≡	.closure	_list.≡.code	_list.≡.ty
list.compare	.closure	_list.compare_c	_list.compare_ty

list.elem	.closure	_list.elem_c	_list.elem_ty

list.fmtgs	.closure	_list.fmtgs_c
list.fmtgs.byDefault	.closure	_list.fmtgs.byDefault_c	_list.fmtgs.byDefault_ty
_list.fmtgs.byDefault_nil.s	.string	[]

	.code

# §section Constructors

_list.nil.c	.expr
list.prim.u	.tygvar
α	.tyarg	*
t	.tylet	list.prim.u	α
list.t.in	.cogvar
c	.constr	t	nil
	.coerce	list.t.in	α
	.lift
	.yield	c

_list.:.c	.expr
list.t	.tygvar
list.prim.u	.tygvar
α	.tyarg	*
t	.tylet	list.prim.u	α
list.t.in	.cogvar
x	.larg	α
xn	.larg	list.t	α
c	.constr	t	:	0	x	1	xn
	.coerce	list.t.in	α
	.lift
	.yield	c

# §section §gs{list.null}

_list.null_c	.expr
list.t	.tygvar
bool.t	.tygvar
α	.tyarg	*
_list.null_k	.subcode
list.t.out	.cogvar
xn	.larg	list.t	α
	.force	_list.null_k
	.coerce	list.t.out	α
	.enter	xn

_list.null_k	.forcecont
list.prim.u	.tygvar
list.t	.tygvar
bool.t	.tygvar
α	.tyfv	*
bool.false	.gvar
bool.true	.gvar
xn0	.karg	list.prim.u	α
	.analyze	xn0	:	nil
		.case	:
x0		.fkarg	0	α
xn1		.fkarg	1	list.t	α
			.enter	bool.false
		.case	nil
			.enter	bool.true

# §section §gs{list.foldr}

_list.foldr_c	.expr
_list.foldr_f_ty	.tygvar
list.t	.tygvar
α	.tyarg	*
β	.tyarg	*
_list.foldr_k0	.subcode
list.t.out	.cogvar
f	.larg	_list.foldr_f_ty	α	β
z	.larg	β
xn	.larg	list.t	α
	.force	_list.foldr_k0
	.coerce	list.t.out	α
	.enter	xn

_list.foldr_k0	.forcecont
_list.foldr_f_ty	.tygvar
list.prim.u	.tygvar
list.t	.tygvar
α	.tyfv	*
β	.tyfv	*
list.foldr	.gvar
f	.fv	_list.foldr_f_ty	α	β
z	.fv	β
xn0	.karg	list.prim.u	α
	.analyze	xn0	:	nil
		.case	:
x0		.fkarg	0	α
xn1		.fkarg	1	list.t	α
z1			.apply	list.foldr	α	β	|	f	z	xn1
			.app	x0	z1
			.enter	f
		.case	nil
			.enter	z

# §section §gs{list.foldr1}

_list.foldr1_code	.expr
list.t	.tygvar
_list.foldr1_ft	.tygvar
α	.tyarg	*
ft	.tylet	_list.foldr1_ft	α
_list.foldr1_k1	.subcode
list.t.out	.cogvar
f	.larg	ft
xn	.larg	list.t	α
	.force	_list.foldr1_k1
	.coerce	list.t.out	α
	.enter	xn

_list.foldr1_k1	.forcecont
list.t	.tygvar
list.prim.u	.tygvar
_list.foldr1_ft	.tygvar
α	.tyfv	*
t	.tylet	list.prim.u	α
ft	.tylet	_list.foldr1_ft	α
_list.foldr1_k2	.subcode
list.t.out	.cogvar
f	.fv	ft
xn0	.karg	t
	.analyze	xn0	:	nil
		.case	:
x0		.fkarg	0	α
xn1		.fkarg	1	list.t	α
			.force	_list.foldr1_k2
			.coerce	list.t.out	α
			.enter	xn1
		.case	nil
			.undef	α

_list.foldr1_k2	.forcecont
list.t	.tygvar
list.prim.u	.tygvar
_list.foldr1_ft	.tygvar
α	.tyfv	*
t	.tylet	list.prim.u	α
ft	.tylet	_list.foldr1_ft	α
_list.foldr1_rec	.subcode
f	.fv	ft
x0	.fv	α
xn1	.fv	list.t	α
xn1_0	.karg	t
	.analyze	xn1_0	:	nil
		.case	:
x1		.fkarg	0	α
xn2		.fkarg	1	list.t	 α
y			.alloc	_list.foldr1_rec
			.app	x0	y
			.enter	f
		.case	nil
			.enter	x0

_list.foldr1_rec	.expr
list.t	.tygvar
_list.foldr1_ft	.tygvar
α	.tyfv	*
ft	.tylet	_list.foldr1_ft	α
list.foldr1	.gvar
f	.fv	ft
xn1	.fv	list.t	α
	.app	f	xn1
	.enter	list.foldr1	α

# §section §gs{list.map}

_list.map_c	.expr
_list.map_f_ty	.tygvar
list.t	.tygvar
α	.tyarg	*
β	.tyarg	*
_list.map_k	.subcode
list.t.out	.cogvar
f	.larg	_list.map_f_ty	α	β
xn	.larg	list.t	α
	.force	_list.map_k
	.coerce	list.t.out	α
	.enter	xn

_list.map_k	.forcecont
_list.map_f_ty	.tygvar
list.prim.u	.tygvar
list.t	.tygvar
α	.tyfv	*
β	.tyfv	*
_list.map_y0_c	.subcode
_list.map_ys1_c	.subcode
list.:	.gvar
list.nil	.gvar
f	.fv	_list.map_f_ty	α	β
xn0	.karg	list.prim.u	α
	.analyze	xn0	:	nil
		.case	:
x0		.fkarg	0	α
xn1		.fkarg	1	list.t	α
y0			.alloc	_list.map_y0_c
ys1			.alloc	_list.map_ys1_c
			.app	y0	ys1
			.enter	list.:	β
		.case	nil
			.enter	list.nil	β

_list.map_y0_c	.expr
_list.map_f_ty	.tygvar
α	.tyfv	*
β	.tyfv	*
f	.fv	_list.map_f_ty	α	β
x0	.fv	α
	.app	x0
	.enter	f

_list.map_ys1_c	.expr
_list.map_f_ty	.tygvar
list.t	.tygvar
α	.tyfv	*
β	.tyfv	*
list.map	.gvar
f	.fv	_list.map_f_ty	α	β
xn1	.fv	list.t	α
	.app	f	xn1
	.enter	list.map	α	β

# §section §gs{list.filter}

_list.filter_c	.expr
_list.filter_pred_ty	.tygvar
list.t	.tygvar
α	.tyarg	*
_list.filter_k	.subcode
list.t.out	.cogvar
pred	.larg	_list.filter_pred_ty	α
xn	.larg	list.t	α
	.force	_list.filter_k
	.coerce	list.t.out	α
	.enter	xn

_list.filter_k	.forcecont
_list.filter_pred_ty	.tygvar
list.prim.u	.tygvar
list.t	.tygvar
α	.tyfv	*
_list.filter_:_k	.subcode
bool.t.out	.cogvar
list.nil	.gvar
pred	.fv	_list.filter_pred_ty	α
xn0	.karg	list.prim.u	α
	.analyze	xn0	:	nil
		.case	:
x0		.fkarg	0	α
xn1		.fkarg	1	list.t	α
			.force	_list.filter_:_k
			.coerce	bool.t.out
			.app	x0
			.enter	pred
		.case	nil
			.enter	list.nil	α

_list.filter_:_k	.forcecont
_list.filter_pred_ty	.tygvar
list.t	.tygvar
bool.prim.u	.tygvar
α	.tyfv	*
list.:	.gvar
list.filter	.gvar
pred	.fv	_list.filter_pred_ty	α
x0	.fv	α
xn1	.fv	list.t	α
b0	.karg	bool.prim.u
ys1	.apply	list.filter	α	|	pred	xn1
	.analyze	b0	false	true
		.case	false
			.enter	ys1
		.case	true
			.app	x0	ys1
			.enter	list.:	α

# §section §gs{list.foldl}

# > list.foldl 'f 'z = list.foldr (flip $ strict f) z ∘ list.reverse;

# > list.foldr 'f 'z (list.<> 'xn.0 'xn.1) = list.foldr f (list.foldr f z xn.1) xn.0;

# > list.foldl 'f 'z nil = list.foldr (flip $ strict f) z (list.reverse nil)
# >   = list.foldr (flip $ strict f) z nil
# >   = z
# > ;
# > list.foldl 'f 'z (list.: 'x 'xn) = list.foldr (flip $ strict f) z (list.reverse (list.: x xn))
# >   = list.foldr (flip $ strict f) z (list.reverse (list.<> (list.singleton x) xn))
# >   = list.foldr (flip $ strict f) z (list.<> (list.reverse xn) (list.reverse (list.singleton x)))
# >   = list.foldr (flip $ strict f) (list.foldr (flip $ strict f) z (list.reverse (list.singleton x))) (list.reverse xn)
# >   = list.foldl f (list.foldr (flip $ strict f) z (list.reverse (list.singleton x))) xn
# >   = list.foldl f (list.foldr (flip $ strict f) z (list.singleton x)) xn
# >   = list.foldl f (list.foldr (flip $ strict f) z (list.: x nil)) xn
# >   = list.foldl f (flip (strict f) x (list.foldr (flip $ strict f) z nil)) xn
# >   = list.foldl f (flip (strict f) x z) xn
# >   = list.foldl f ((strict f z) x) xn
# >   = list.foldl f ((for (!'z0 ∝ z) f z0) x) xn
# >   = list.foldl f (for (!'z0 ∝ z) f z0 x) xn
# >   = for (!'z0 ∝ z) list.foldl f (f z0 x) xn -- Since §gs{list.fold} is strict in §gs{z}
# > ;

_list.foldl_c	.expr
_list.foldl_f_ty	.tygvar
list.t	.tygvar
α	.tyarg	*
β	.tyarg	*
_list.foldl_k0	.subcode
f	.larg	_list.foldl_f_ty	α	β
z	.larg	β
xn	.larg	list.t	α
	.strict	_list.foldl_k0
	.enter	z

_list.foldl_k0	.strictcont
_list.foldl_f_ty	.tygvar
list.t	.tygvar
α	.tyfv	*
β	.tyfv	*
_list.foldl_k1	.subcode
list.t.out	.cogvar
f	.fv	_list.foldl_f_ty	α	β
xn	.fv	list.t	α
z	.karg	β
	.force	_list.foldl_k1
	.coerce	list.t.out	α
	.enter	xn

_list.foldl_k1	.forcecont
_list.foldl_f_ty	.tygvar
list.prim.u	.tygvar
list.t	.tygvar
α	.tyfv	*
β	.tyfv	*
_list.foldl_k1_z1_c	.subcode
list.foldl	.gvar
f	.fv	_list.foldl_f_ty	α	β
z	.fv	β
xn0	.karg	list.prim.u	α
	.analyze	xn0	:	nil
		.case	:
x0		.fkarg	0	α
xn1		.fkarg	1	list.t	α
z1			.alloc	_list.foldl_k1_z1_c
			.app	f	z1	xn1
			.enter	list.foldl	α	β
		.case	nil
			.enter	z

_list.foldl_k1_z1_c	.expr
_list.foldl_f_ty	.tygvar
α	.tyfv	*
β	.tyfv	*
f	.fv	_list.foldl_f_ty	α	β
z	.fv	β
x0	.fv	α
	.app	z	x0
	.enter	f

# §section §gs{list.reverse}

# > list.reverse nil = nil;
# > list.reverse (list.singleton 'x) = list.singleton x;
# > list.reverse (list.<> 'xn.0 'xn.1) = list.<> (list.reverse xn.1) (list.reverse xn.0);

# > list.reverse = id ∘ list.reverse
# >   = list.foldr list.: list.nil ∘ list.reverse
# >   = list.foldr (flip (flip list.:)) list.nil ∘ list.reverse
# >   = list.foldr (flip (strict (flip list.:))) list.nil ∘ list.reverse -- Since the accumulator is defined whenever it's used
# >   = list.foldl (flip list.:) list.nil
# > ;

_list.reverse_c	.expr
list.t	.tygvar
α	.tyarg	*
list.α	.tylet	list.t	α
_list.reverse_fcons_c	.subcode
list.foldl	.gvar
list.nil	.gvar
fcons	.alloc	_list.reverse_fcons_c
nil	.apply	list.nil	α
	.app	fcons	nil
	.enter	list.foldl	α	list.α

_list.reverse_fcons_c	.expr
list.t	.tygvar
α	.tyfv	*
list.:	.gvar
xn	.larg	list.t	α
x	.larg	α
	.app	x	xn
	.enter	list.:	α

# §section §gs{list.singleton}

_list.singleton_c	.expr
α	.tyarg	*
_list.singleton_n_c	.subcode
list.:	.gvar
x	.larg	α
n	.alloc	_list.singleton_n_c
	.app	x	n
	.enter	list.:	α

_list.singleton_n_c	.expr
list.t	.tygvar
α	.tyfv	*
list.nil	.gvar
	.enter	list.nil	α

# §section §gs{list.<>}

_list.<>.code	.expr
list.t	.tygvar
α	.tyarg	*
_list.<>.code.cont	.subcode
list.t.out	.cogvar
xn	.larg	list.t	α
ys	.larg	list.t	α
	.force	_list.<>.code.cont
	.coerce	list.t.out	α
	.enter	xn

_list.<>.code.cont	.forcecont
list.t	.tygvar
list.prim.u	.tygvar
α	.tyfv	*
t	.tylet	list.prim.u	α
_list.<>.code.rec	.subcode
list.t.in	.cogvar
ys	.fv	list.t	α
xn0	.karg	t
	.analyze	xn0	:	nil
	.case	:
x0	.fkarg	0	α
xn1	.fkarg	1	list.t	α
ys1	.alloc	_list.<>.code.rec
ys2	.constr	t	:	0	x0	1	ys1
	.coerce	list.t.in	α
	.lift
	.yield	ys2
	.case	nil
	.enter	ys

_list.<>.code.rec	.expr
list.t	.tygvar
α	.tyfv	*
list.<>	.gvar
xn1	.fv	list.t	α
ys	.fv	list.t	α
	.app	xn1	ys
	.enter	list.<>	α

# §section §gs{list.≡}

_list.≡.code	.expr
bool.t	.tygvar
list.t	.tygvar
_list.≡.arg.ty	.tygvar
α	.tyarg	*
at	.tylet	_list.≡.arg.ty	α
_list.≡.k0	.subcode
list.t.out	.cogvar
c	.larg	at
xn	.larg	list.t	α
ys	.larg	list.t	α
	.force	_list.≡.k0
	.coerce	list.t.out	α
	.enter	xn

_list.≡.k0	.forcecont
bool.t	.tygvar
list.prim.u	.tygvar
list.t	.tygvar
_list.≡.arg.ty	.tygvar
α	.tyfv	*
t	.tylet	list.prim.u	α
at	.tylet	_list.≡.arg.ty	α
_list.≡.k1	.subcode
list.t.out	.cogvar
c	.fv	at
ys	.fv	list.t	α
xn0	.karg	t
	.force	_list.≡.k1
	.coerce	list.t.out	α
	.enter	ys

_list.≡.k1	.forcecont
list.prim.u	.tygvar
list.t	.tygvar
_list.≡.arg.ty	.tygvar
α	.tyfv	*
t	.tylet	list.prim.u	α
at	.tylet	_list.≡.arg.ty	α
_list.≡.cmp	.subcode
_list.≡.rec	.subcode
bool.true	.gvar
bool.false	.gvar
bool.∧	.gvar
c	.fv	at
xn0	.fv	t
ys0	.karg	t
	.analyze	xn0	:	nil
		.case	:
x		.fkarg	0	α
xn1		.fkarg	1	list.t	α
			.analyze	ys0	:	nil
				.case	:
y				.fkarg	0	α
ys1				.fkarg	1	list.t	α
b0					.alloc	_list.≡.cmp
b1					.alloc	_list.≡.rec
					.app	b0	b1
					.enter	bool.∧
				.case	nil
					.enter	bool.false
		.case	nil
			.analyze	ys0	:	nil
				.case	:
y				.fkarg	0	α
ys1				.fkarg	1	list.t	α
					.enter	bool.false
				.case	nil
					.enter	bool.true

_list.≡.cmp	.expr
_list.≡.arg.ty	.tygvar
α	.tyfv	*
at	.tylet	_list.≡.arg.ty	α
c	.fv	at
x	.fv	α
y	.fv	α
	.app	x	y
	.enter	c

_list.≡.rec	.expr
list.t	.tygvar
_list.≡.arg.ty	.tygvar
α	.tyfv	*
at	.tylet	_list.≡.arg.ty	α
list.≡	.gvar
c	.fv	at
xn1	.fv	list.t	α
ys1	.fv	list.t	α
	.app	c	xn1	ys1
	.enter	list.≡	α

# §section §gs{list.compare}

_list.compare_c	.expr
order.total.t	.tygvar
list.t	.tygvar
α	.tyarg	*
_list.compare_k0	.subcode
list.t.out	.cogvar
cmp	.larg	order.total.t	α
xn0	.larg	list.t	α
xn1	.larg	list.t	α
	.force	_list.compare_k0
	.coerce	list.t.out	α
	.enter	xn0

_list.compare_k0	.forcecont
order.total.t	.tygvar
list.t	.tygvar
list.prim.u	.tygvar
α	.tyfv	*
_list.compare_k1	.subcode
list.t.out	.cogvar
cmp	.fv	order.total.t	α
xn1	.fv	list.t	α
xn0.0	.karg	list.prim.u	α
	.force	_list.compare_k1
	.coerce	list.t.out	α
	.enter	xn1

_list.compare_k1	.forcecont
order.total.t	.tygvar
list.prim.u	.tygvar
list.t	.tygvar
order.total.ord.t	.tygvar
α	.tyfv	*
_list.compare_:_:_k	.subcode
order.total.ord.t.out	.cogvar
order.total.ord.eq	.gvar
cmp	.fv	order.total.t	α
xn0.0	.fv	list.prim.u	α
xn1.0	.karg	list.prim.u	α
	.analyze	xn0.0	:	nil
		.case	:
x0		.fkarg	0	α
xn0.1		.fkarg	1	list.t	α
			.analyze	xn1.0	:	nil
				.case	:
x1				.fkarg	0	α
xn1.1				.fkarg	1	list.t	α
					.force	_list.compare_:_:_k
					.coerce	order.total.ord.t.out
					.app	x0	x1
					.enter	cmp
				.case	nil
					.undef	order.total.ord.t
		.case	nil
			.analyze	xn1.0	:	nil
				.case	:
x1				.fkarg	0	α
xn1.1				.fkarg	1	list.t	α
					.undef	order.total.ord.t
				.case	nil
					.enter	order.total.ord.eq

_list.compare_:_:_k	.forcecont
order.total.t	.tygvar
list.t	.tygvar
order.total.ord.prim.u	.tygvar
order.total.ord.t	.tygvar
α	.tyfv	*
list.compare	.gvar
order.total.ord.gt	.gvar
order.total.ord.lt	.gvar
cmp	.fv	order.total.t	α
xn0.1	.fv	list.t	α
xn1.1	.fv	list.t	α
o0	.karg	order.total.ord.prim.u
	.analyze	o0	eq	gt	lt
		.case	eq
			.app	cmp	xn0.1	xn1.1
			.enter	list.compare	α
		.case	gt
			.enter	order.total.ord.gt
		.case	lt
			.enter	order.total.ord.lt

# §section §gs{list.elem}

_list.elem_c	.expr
eq.t	.tygvar
list.t	.tygvar
α	.tyarg	*
_list.elem_k	.subcode
list.t.out	.cogvar
eq	.larg	eq.t	α
x	.larg	α
xn	.larg	list.t	α
	.force	_list.elem_k
	.coerce	list.t.out	α
	.enter	xn

_list.elem_k	.forcecont
eq.t	.tygvar
list.prim.u	.tygvar
list.t	.tygvar
α	.tyfv	*
_list.elem_:_k	.subcode
bool.t.out	.cogvar
bool.false	.gvar
eq	.fv	eq.t	α
x	.fv	α
xn0	.karg	list.prim.u	α
	.analyze	xn0	:	nil
		.case	:
x0		.fkarg	0	α
xn1		.fkarg	1	list.t	α
			.force	_list.elem_:_k
			.coerce	bool.t.out
			.app	x	x0
			.enter	eq
		.case	nil
			.enter	bool.false

_list.elem_:_k	.forcecont
eq.t	.tygvar
list.t	.tygvar
bool.prim.u	.tygvar
bool.t	.tygvar	# Temp
α	.tyfv	*
list.elem	.gvar
eq	.fv	eq.t	α
x	.fv	α
xn1	.fv	list.t	α
b0	.karg	bool.prim.u
	.analyze	b0	false	true
		.case	false
			.app	eq	x	xn1
			.enter	list.elem	α
		.case	true
			.undef	bool.t

# §section §gs{list.fmtgs}

_list.fmtgs_c	.expr
list.fmtgs.list.t	.tygvar
list.t	.tygvar
rune.t	.tygvar
α	.tyarg	*
p0	.larg	list.fmtgs.list.t	α
xn	.larg	list.t	α
	.app	xn
	.enter	p0

_list.fmtgs.byDefault_c	.expr
fmtgs.t	.tygvar
list.t	.tygvar
rune.t	.tygvar
α	.tyarg	*
_list.fmtgs.byDefault_k	.subcode
list.t.out	.cogvar
p	.larg	fmtgs.t	α
xn	.larg	list.t	α
	.force	_list.fmtgs.byDefault_k
	.coerce	list.t.out	α
	.enter	xn

_list.fmtgs.byDefault_k	.forcecont
list.prim.u	.tygvar
list.t	.tygvar
fmtgs.printer.t	.tygvar
rune.t	.tygvar
α	.tyfv	*
fmtgs.prec	.gvar
fmtgs.prec.arg	.gvar
diff.list.fromlist	.gvar
_list.fmtgs.byDefault_nil.s	.gvar
xn0	.karg	list.prim.u	α
	.analyze	xn0	:	nil
		.case	:
x0		.fkarg	0	α
xn1		.fkarg	1	list.t	α
			.undef	fmtgs.printer.t
		.case	nil
ds			.apply	diff.list.fromlist	rune.t	|	_list.fmtgs.byDefault_nil.s
			.app	fmtgs.prec.arg	ds
			.enter	fmtgs.prec

	.type

# §section §gs{list.t}

list.t	.tyabstract	**^
list.prim.u	.tygvar
α	.tylambda	*
_body	.tylet	list.prim.u	α
	.tylift
	.tyref	_body

list.prim.u	.tyexpr
_cons_type	.tygvar
_nil_type	.tygvar
α	.tylambda	*
_cons_type_α	.tylet	_cons_type	α
_nil_type_α	.tylet	_nil_type	α
	.tysum	:	_cons_type_α	nil	_nil_type_α

_cons_type	.tyexpr
_tail_type	.tygvar
α	.tylambda	*
_list_α	.tylet	_tail_type	α
	.tyubproduct	0	α	1	_list_α

_tail_type	.tyexpr
list.t	.tygvar
α	.tylambda	*
	.tyref	list.t	α

_nil_type	.tyexpr
α	.tylambda	*
	.tyubproduct

# §section §gs{list.foldr}

_list.foldr_ty	.tyexpr
_list.foldr_f_ty	.tygvar
list.t	.tygvar
α	.tyforall	*
β	.tyforall	*
	.tylift
	.tyfun	_list.foldr_f_ty	α	β
	.tylift
	.tyfun	β
	.tylift
	.tyfun	list.t	α
	.tyref	β

_list.foldr_f_ty	.tyexpr
α	.tylambda	*
β	.tylambda	*
	.tylift
	.tyfun	α
	.tylift
	.tyfun	β
	.tyref	β

# §section §gs{list.foldr1}

_list.foldr1_ty	.tyexpr
_list.foldr1_ft	.tygvar
list.t	.tygvar
α	.tyforall	*
at	.tylet	_list.foldr1_ft	α
	.tylift
	.tyfun	at
	.tylift
	.tyfun	list.t	α
	.tyref	α

_list.foldr1_ft	.tyexpr
α	.tylambda	*
	.tylift
	.tyfun	α
	.tylift
	.tyfun	α
	.tyref	α

# §section §gs{list.map}

_list.map_ty	.tyexpr
_list.map_f_ty	.tygvar
list.t	.tygvar
α	.tyforall	*
β	.tyforall	*
	.tylift
	.tyfun	_list.map_f_ty	α	β
	.tylift
	.tyfun	list.t	α
	.tyref	list.t	β

_list.map_f_ty	.tyexpr
α	.tylambda	*
β	.tylambda	*
	.tylift
	.tyfun	α
	.tyref	β

# §section §gs{list.filter}

_list.filter_ty	.tyexpr
_list.filter_pred_ty	.tygvar
list.t	.tygvar
α	.tyforall	*
	.tylift
	.tyfun	_list.filter_pred_ty	α
	.tylift
	.tyfun	list.t	α
	.tyref	list.t	α

_list.filter_pred_ty	.tyexpr
bool.t	.tygvar
α	.tylambda	*
	.tylift
	.tyfun	α
	.tyref	bool.t

# §section §gs{list.foldl}

_list.foldl_ty	.tyexpr
_list.foldl_f_ty	.tygvar
list.t	.tygvar
α	.tyforall	*
β	.tyforall	*
	.tylift
	.tyfun	_list.foldl_f_ty	α	β
	.tylift
	.tyfun	β
	.tylift
	.tyfun	list.t	α
	.tyref	β

_list.foldl_f_ty	.tyexpr
α	.tylambda	*
β	.tylambda	*
	.tylift
	.tyfun	β
	.tylift
	.tyfun	α
	.tyref	β

# §section §gs{list.<>}

_list.<>.ty	.tyexpr
list.t	.tygvar
α	.tyforall	*
	.tylift
	.tyfun	list.t	α
	.tylift
	.tyfun	list.t	α
	.tyref	list.t	α

# §section §gs{list.≡}

_list.≡.ty	.tyexpr
bool.t	.tygvar
list.t	.tygvar
_list.≡.arg.ty	.tygvar
α	.tyforall	*
at	.tylet	_list.≡.arg.ty	α
	.tylift
	.tyfun	at
	.tylift
	.tyfun	list.t	α
	.tylift
	.tyfun	list.t	α
	.tyref	bool.t

_list.≡.arg.ty	.tyexpr
bool.t	.tygvar
α	.tylambda	*
	.tylift
	.tyfun	α
	.tylift
	.tyfun	α
	.tyref	bool.t

# §section §gs{list.compare}

_list.compare_ty	.tyexpr
order.total.t	.tygvar
list.t	.tygvar
α	.tyforall	*
arg.ty	.tylet	list.t	α
	.tylift
	.tyfun	order.total.t	α
	.tyref	order.total.t	arg.ty

# §section §gs{list.elem}

_list.elem_ty	.tyexpr
eq.t	.tygvar
list.t	.tygvar
bool.t	.tygvar
α	.tyforall	*
	.tylift
	.tyfun	eq.t	α
	.tylift
	.tyfun	α
	.tylift
	.tyfun	list.t	α
	.tyref	bool.t

# §section §gs{list.fmtgs}

list.fmtgs.list.t	.tyexpr
fmtgs.t	.tygvar
list.t	.tygvar
α	.tylambda	*
list.α	.tylet	list.t	α
	.tyref	fmtgs.t	list.α

_list.fmtgs.byDefault_ty	.tyexpr
fmtgs.t	.tygvar
list.fmtgs.list.t	.tygvar
α	.tyforall	*
	.tylift
	.tyfun	fmtgs.t	α
	.tyref	list.fmtgs.list.t	α

	.coercion

list.t.out	.tycoercion
list.t	.tygvar
α	.tylambda	*
	.tyinvert
	.tydefinition	list.t	α

list.t.in	.tycoercion
list.t	.tygvar
α	.tylambda	*
	.tydefinition	list.t	α
