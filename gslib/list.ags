	.prefix

	.data

list.nil	.closure	_list.nil.c
list.:	.closure	_list.:.c

list.foldr	.closure	_list.foldr_c	_list.foldr_ty
list.foldr1	.closure	_list.foldr1_code	_list.foldr1_ty
list.map	.closure	_list.map_c	_list.map_ty

list.foldl	.closure	_list.foldl_c	_list.foldl_ty
list.reverse	.closure	_list.reverse_c

list.singleton	.closure	_list.singleton_c
list.<>	.closure	_list.<>.code	_list.<>.ty

list.≡	.closure	_list.≡.code	_list.≡.ty
list.compare	.closure	_list.compare_c	_list.compare_ty

list.print	.closure	_list.print_c
list.print.byDefault	.closure	_list.print.byDefault_c	_list.print.byDefault_ty
_list.print.byDefault_nil.s	.string	[]

	.code

# §section Constructors

_list.nil.c	.expr
list.prim.u	.tygvar
α	.tyarg	*
t	.tylet	list.prim.u	α
list.t.in	.cogvar
c	.constr	t	nil
	.coerce	list.t.in	α
	.lift
	.yield	c

_list.:.c	.expr
list.t	.tygvar
list.prim.u	.tygvar
α	.tyarg	*
t	.tylet	list.prim.u	α
list.t.in	.cogvar
x	.larg	α
xn	.larg	list.t	α
c	.constr	t	:	0	x	1	xn
	.coerce	list.t.in	α
	.lift
	.yield	c

# §section §gs{list.foldr}

_list.foldr_c	.expr
_list.foldr_f_ty	.tygvar
list.t	.tygvar
α	.tyarg	*
β	.tyarg	*
_list.foldr_k0	.subcode
list.t.out	.cogvar
f	.larg	_list.foldr_f_ty	α	β
z	.larg	β
xn	.larg	list.t	α
	.force	_list.foldr_k0	α	β	|	f	z
	.coerce	list.t.out	α
	.enter	xn

_list.foldr_k0	.forcecont
_list.foldr_f_ty	.tygvar
list.prim.u	.tygvar
list.t	.tygvar
α	.tyfv	*
β	.tyfv	*
list.foldr	.gvar
f	.fv	_list.foldr_f_ty	α	β
z	.fv	β
xn0	.karg	list.prim.u	α
	.analyze	xn0	:	nil
		.case	:
x0		.fkarg	0	α
xn1		.fkarg	1	list.t	α
z1			.apply	list.foldr	α	β	|	f	z	xn1
			.app	x0	z1
			.enter	f
		.case	nil
			.enter	z

# §section §gs{list.foldr1}

_list.foldr1_code	.expr
list.t	.tygvar
_list.foldr1_ft	.tygvar
α	.tyarg	*
ft	.tylet	_list.foldr1_ft	α
_list.foldr1_k1	.subcode
list.t.out	.cogvar
f	.larg	ft
xn	.larg	list.t	α
	.force	_list.foldr1_k1	α	|	f
	.coerce	list.t.out	α
	.enter	xn

_list.foldr1_k1	.forcecont
list.t	.tygvar
list.prim.u	.tygvar
_list.foldr1_ft	.tygvar
α	.tyfv	*
t	.tylet	list.prim.u	α
ft	.tylet	_list.foldr1_ft	α
_list.foldr1_k2	.subcode
list.t.out	.cogvar
f	.fv	ft
xn0	.karg	t
	.analyze	xn0	:	nil
		.case	:
x0		.fkarg	0	α
xn1		.fkarg	1	list.t	α
			.force	_list.foldr1_k2	α	|	f	x0	xn1
			.coerce	list.t.out	α
			.enter	xn1
		.case	nil
			.undef	α

_list.foldr1_k2	.forcecont
list.t	.tygvar
list.prim.u	.tygvar
_list.foldr1_ft	.tygvar
α	.tyfv	*
t	.tylet	list.prim.u	α
ft	.tylet	_list.foldr1_ft	α
_list.foldr1_rec	.subcode
f	.fv	ft
x	.fv	α
xn1	.fv	list.t	α
xn1_0	.karg	t
	.analyze	xn1_0	:	nil
		.case	:
x1		.fkarg	0	α
xn2		.fkarg	1	list.t	 α
y			.alloc	_list.foldr1_rec	α	|	f	xn1
			.app	x	y
			.enter	f
		.case	nil
			.enter	x

_list.foldr1_rec	.expr
list.t	.tygvar
_list.foldr1_ft	.tygvar
α	.tyfv	*
ft	.tylet	_list.foldr1_ft	α
list.foldr1	.gvar
f	.fv	ft
xn1	.fv	list.t	α
	.app	f	xn1
	.enter	list.foldr1	α

# §section §gs{list.map}

_list.map_c	.expr
_list.map_f_ty	.tygvar
list.t	.tygvar
α	.tyarg	*
β	.tyarg	*
_list.map_k	.subcode
list.t.out	.cogvar
f	.larg	_list.map_f_ty	α	β
xn	.larg	list.t	α
	.force	_list.map_k	α	β	|	f
	.coerce	list.t.out	α
	.enter	xn

_list.map_k	.forcecont
_list.map_f_ty	.tygvar
list.prim.u	.tygvar
list.t	.tygvar
α	.tyfv	*
β	.tyfv	*
_list.map_y0_c	.subcode
_list.map_ys1_c	.subcode
list.:	.gvar
list.nil	.gvar
f	.fv	_list.map_f_ty	α	β
xn0	.karg	list.prim.u	α
	.analyze	xn0	:	nil
		.case	:
x0		.fkarg	0	α
xn1		.fkarg	1	list.t	α
y0			.alloc	_list.map_y0_c	α	β	|	f	x0
ys1			.alloc	_list.map_ys1_c	α	β	|	f	xn1
			.app	y0	ys1
			.enter	list.:	β
		.case	nil
			.enter	list.nil	β

_list.map_y0_c	.expr
_list.map_f_ty	.tygvar
α	.tyfv	*
β	.tyfv	*
f	.fv	_list.map_f_ty	α	β
x0	.fv	α
	.app	x0
	.enter	f

_list.map_ys1_c	.expr
_list.map_f_ty	.tygvar
list.t	.tygvar
α	.tyfv	*
β	.tyfv	*
list.map	.gvar
f	.fv	_list.map_f_ty	α	β
xn1	.fv	list.t	α
	.app	f	xn1
	.enter	list.map	α	β

# §section §gs{list.foldl}

# > list.foldl 'f 'z = list.foldr (flip $ strict f) z ∘ list.reverse;

# > list.foldr 'f 'z (list.<> 'xn.0 'xn.1) = list.foldr f (list.foldr f z xn.1) xn.0;

# > list.foldl 'f 'z nil = list.foldr (flip $ strict f) z (list.reverse nil)
# >   = list.foldr (flip $ strict f) z nil
# >   = z
# > ;
# > list.foldl 'f 'z (list.: 'x 'xn) = list.foldr (flip $ strict f) z (list.reverse (list.: x xn))
# >   = list.foldr (flip $ strict f) z (list.reverse (list.<> (list.singleton x) xn))
# >   = list.foldr (flip $ strict f) z (list.<> (list.reverse xn) (list.reverse (list.singleton x)))
# >   = list.foldr (flip $ strict f) (list.foldr (flip $ strict f) z (list.reverse (list.singleton x))) (list.reverse xn)
# >   = list.foldl f (list.foldr (flip $ strict f) z (list.reverse (list.singleton x))) xn
# >   = list.foldl f (list.foldr (flip $ strict f) z (list.singleton x)) xn
# >   = list.foldl f (list.foldr (flip $ strict f) z (list.: x nil)) xn
# >   = list.foldl f (flip (strict f) x (list.foldr (flip $ strict f) z nil)) xn
# >   = list.foldl f (flip (strict f) x z) xn
# >   = list.foldl f ((strict f z) x) xn
# >   = list.foldl f ((for (!'z0 ∝ z) f z0) x) xn
# >   = list.foldl f (for (!'z0 ∝ z) f z0 x) xn
# >   = for (!'z0 ∝ z) list.foldl f (f z0 x) xn -- Since §gs{list.fold} is strict in §gs{z}
# > ;

_list.foldl_c	.expr
_list.foldl_f_ty	.tygvar
list.t	.tygvar
α	.tyarg	*
β	.tyarg	*
_list.foldl_k0	.subcode
f	.larg	_list.foldl_f_ty	α	β
z	.larg	β
xn	.larg	list.t	α
	.strict	_list.foldl_k0	α	β	|	f	xn
	.enter	z

_list.foldl_k0	.strictcont
_list.foldl_f_ty	.tygvar
list.t	.tygvar
α	.tyfv	*
β	.tyfv	*
_list.foldl_k1	.subcode
list.t.out	.cogvar
f	.fv	_list.foldl_f_ty	α	β
xn	.fv	list.t	α
z	.karg	β
	.force	_list.foldl_k1	α	β	|	f	z
	.coerce	list.t.out	α
	.enter	xn

_list.foldl_k1	.forcecont
_list.foldl_f_ty	.tygvar
list.prim.u	.tygvar
list.t	.tygvar
α	.tyfv	*
β	.tyfv	*
_list.foldl_k1_z1_c	.subcode
list.foldl	.gvar
f	.fv	_list.foldl_f_ty	α	β
z	.fv	β
xn0	.karg	list.prim.u	α
	.analyze	xn0	:	nil
		.case	:
x0		.fkarg	0	α
xn1		.fkarg	1	list.t	α
z1			.alloc	_list.foldl_k1_z1_c	α	β	|	f	z	x0
			.app	f	z1	xn1
			.enter	list.foldl	α	β
		.case	nil
			.enter	z

_list.foldl_k1_z1_c	.expr
_list.foldl_f_ty	.tygvar
α	.tyfv	*
β	.tyfv	*
f	.fv	_list.foldl_f_ty	α	β
z	.fv	β
x0	.fv	α
	.app	z	x0
	.enter	f

# §section §gs{list.reverse}

# > list.reverse nil = nil;
# > list.reverse (list.singleton 'x) = list.singleton x;
# > list.reverse (list.<> 'xn.0 'xn.1) = list.<> (list.reverse xn.1) (list.reverse xn.0);

# > list.reverse = id ∘ list.reverse
# >   = list.foldr list.: list.nil ∘ list.reverse
# >   = list.foldr (flip (flip list.:)) list.nil ∘ list.reverse
# >   = list.foldr (flip (strict (flip list.:))) list.nil ∘ list.reverse -- Since the accumulator is defined whenever it's used
# >   = list.foldl (flip list.:) list.nil
# > ;

_list.reverse_c	.expr
list.t	.tygvar
α	.tyarg	*
list.α	.tylet	list.t	α
_list.reverse_fcons_c	.subcode
list.foldl	.gvar
list.nil	.gvar
fcons	.alloc	_list.reverse_fcons_c	α
nil	.apply	list.nil	α
	.app	fcons	nil
	.enter	list.foldl	α	list.α

_list.reverse_fcons_c	.expr
list.t	.tygvar
α	.tyfv	*
list.:	.gvar
xn	.larg	list.t	α
x	.larg	α
	.app	x	xn
	.enter	list.:	α

# §section §gs{list.singleton}

_list.singleton_c	.expr
α	.tyarg	*
_list.singleton_n_c	.subcode
list.:	.gvar
x	.larg	α
n	.alloc	_list.singleton_n_c	α
	.app	x	n
	.enter	list.:	α

_list.singleton_n_c	.expr
list.t	.tygvar
α	.tyfv	*
list.nil	.gvar
	.enter	list.nil	α

# §section §gs{list.<>}

_list.<>.code	.expr
list.t	.tygvar
α	.tyarg	*
_list.<>.code.cont	.subcode
list.t.out	.cogvar
xn	.larg	list.t	α
ys	.larg	list.t	α
	.force	_list.<>.code.cont	α	|	ys
	.coerce	list.t.out	α
	.enter	xn

_list.<>.code.cont	.forcecont
list.t	.tygvar
list.prim.u	.tygvar
α	.tyfv	*
t	.tylet	list.prim.u	α
_list.<>.code.rec	.subcode
list.t.in	.cogvar
ys	.fv	list.t	α
xn0	.karg	t
	.analyze	xn0	:	nil
	.case	:
x0	.fkarg	0	α
xn1	.fkarg	1	list.t	α
ys1	.alloc	_list.<>.code.rec	α	|	xn1	ys
ys2	.constr	t	:	0	x0	1	ys1
	.coerce	list.t.in	α
	.lift
	.yield	ys2
	.case	nil
	.enter	ys

_list.<>.code.rec	.expr
list.t	.tygvar
α	.tyfv	*
list.<>	.gvar
xn	.fv	list.t	α
ys	.fv	list.t	α
	.app	xn	ys
	.enter	list.<>	α

# §section §gs{list.≡}

_list.≡.code	.expr
bool.t	.tygvar
list.t	.tygvar
_list.≡.arg.ty	.tygvar
α	.tyarg	*
at	.tylet	_list.≡.arg.ty	α
_list.≡.k0	.subcode
list.t.out	.cogvar
c	.larg	at
xn	.larg	list.t	α
ys	.larg	list.t	α
	.force	_list.≡.k0	α	|	c	ys
	.coerce	list.t.out	α
	.enter	xn

_list.≡.k0	.forcecont
bool.t	.tygvar
list.prim.u	.tygvar
list.t	.tygvar
_list.≡.arg.ty	.tygvar
α	.tyfv	*
t	.tylet	list.prim.u	α
at	.tylet	_list.≡.arg.ty	α
_list.≡.k1	.subcode
list.t.out	.cogvar
c	.fv	at
ys	.fv	list.t	α
xn0	.karg	t
	.force	_list.≡.k1	α	|	c	xn0
	.coerce	list.t.out	α
	.enter	ys

_list.≡.k1	.forcecont
list.prim.u	.tygvar
list.t	.tygvar
_list.≡.arg.ty	.tygvar
α	.tyfv	*
t	.tylet	list.prim.u	α
at	.tylet	_list.≡.arg.ty	α
_list.≡.cmp	.subcode
_list.≡.rec	.subcode
bool.true	.gvar
bool.false	.gvar
bool.∧	.gvar
c	.fv	at
xn0	.fv	t
ys0	.karg	t
	.analyze	xn0	:	nil
		.case	:
x		.fkarg	0	α
xn1		.fkarg	1	list.t	α
			.analyze	ys0	:	nil
				.case	:
y				.fkarg	0	α
ys1				.fkarg	1	list.t	α
b0					.alloc	_list.≡.cmp	α	|	c	x	y
b1					.alloc	_list.≡.rec	α	|	c	xn1	ys1
					.app	b0	b1
					.enter	bool.∧
				.case	nil
					.enter	bool.false
		.case	nil
			.analyze	ys0	:	nil
				.case	:
y				.fkarg	0	α
ys1				.fkarg	1	list.t	α
					.enter	bool.false
				.case	nil
					.enter	bool.true

_list.≡.cmp	.expr
_list.≡.arg.ty	.tygvar
α	.tyfv	*
at	.tylet	_list.≡.arg.ty	α
c	.fv	at
x	.fv	α
y	.fv	α
	.app	x	y
	.enter	c

_list.≡.rec	.expr
list.t	.tygvar
_list.≡.arg.ty	.tygvar
α	.tyfv	*
at	.tylet	_list.≡.arg.ty	α
list.≡	.gvar
c	.fv	at
xn1	.fv	list.t	α
ys1	.fv	list.t	α
	.app	c	xn1	ys1
	.enter	list.≡	α

# §section §gs{list.compare}

_list.compare_c	.expr
order.total.t	.tygvar
list.t	.tygvar
α	.tyarg	*
arg.ty	.tylet	list.t	α
cmp	.larg	order.total.t	α
	.undef	order.total.t	arg.ty

# §section §gs{list.print}

_list.print_c	.expr
list.print.list.t	.tygvar
list.t	.tygvar
rune.t	.tygvar
α	.tyarg	*
p0	.larg	list.print.list.t	α
xn	.larg	list.t	α
	.app	xn
	.enter	p0

_list.print.byDefault_c	.expr
print.t	.tygvar
list.t	.tygvar
rune.t	.tygvar
α	.tyarg	*
_list.print.byDefault_k	.subcode
list.t.out	.cogvar
p	.larg	print.t	α
xn	.larg	list.t	α
	.force	_list.print.byDefault_k	α
	.coerce	list.t.out	α
	.enter	xn

_list.print.byDefault_k	.forcecont
list.prim.u	.tygvar
list.t	.tygvar
rune.t	.tygvar
α	.tyfv	*
_list.print.byDefault_nil.s	.gvar
xn0	.karg	list.prim.u	α
	.analyze	xn0	:	nil
		.case	:
x0		.fkarg	0	α
xn1		.fkarg	1	list.t	α
			.undef	list.t	rune.t
		.case	nil
			.enter	_list.print.byDefault_nil.s

	.type

# §section §gs{list.t}

list.t	.tyabstract	**^
list.prim.u	.tygvar
α	.tylambda	*
_body	.tylet	list.prim.u	α
	.tylift
	.tyref	_body

list.prim.u	.tyexpr
_cons_type	.tygvar
_nil_type	.tygvar
α	.tylambda	*
_cons_type_α	.tylet	_cons_type	α
_nil_type_α	.tylet	_nil_type	α
	.tysum	:	_cons_type_α	nil	_nil_type_α

_cons_type	.tyexpr
_tail_type	.tygvar
α	.tylambda	*
_list_α	.tylet	_tail_type	α
	.tyubproduct	0	α	1	_list_α

_tail_type	.tyexpr
list.t	.tygvar
α	.tylambda	*
	.tyref	list.t	α

_nil_type	.tyexpr
α	.tylambda	*
	.tyubproduct

# §section §gs{list.foldr}

_list.foldr_ty	.tyexpr
_list.foldr_f_ty	.tygvar
list.t	.tygvar
α	.tyforall	*
β	.tyforall	*
	.tylift
	.tyfun	_list.foldr_f_ty	α	β
	.tylift
	.tyfun	β
	.tylift
	.tyfun	list.t	α
	.tyref	β

_list.foldr_f_ty	.tyexpr
α	.tylambda	*
β	.tylambda	*
	.tylift
	.tyfun	α
	.tylift
	.tyfun	β
	.tyref	β

# §section §gs{list.foldr1}

_list.foldr1_ty	.tyexpr
_list.foldr1_ft	.tygvar
list.t	.tygvar
α	.tyforall	*
at	.tylet	_list.foldr1_ft	α
	.tylift
	.tyfun	at
	.tylift
	.tyfun	list.t	α
	.tyref	α

_list.foldr1_ft	.tyexpr
α	.tylambda	*
	.tylift
	.tyfun	α
	.tylift
	.tyfun	α
	.tyref	α

# §section §gs{list.map}

_list.map_ty	.tyexpr
_list.map_f_ty	.tygvar
list.t	.tygvar
α	.tyforall	*
β	.tyforall	*
	.tylift
	.tyfun	_list.map_f_ty	α	β
	.tylift
	.tyfun	list.t	α
	.tyref	list.t	β

_list.map_f_ty	.tyexpr
α	.tylambda	*
β	.tylambda	*
	.tylift
	.tyfun	α
	.tyref	β

# §section §gs{list.foldl}

_list.foldl_ty	.tyexpr
_list.foldl_f_ty	.tygvar
list.t	.tygvar
α	.tyforall	*
β	.tyforall	*
	.tylift
	.tyfun	_list.foldl_f_ty	α	β
	.tylift
	.tyfun	β
	.tylift
	.tyfun	list.t	α
	.tyref	β

_list.foldl_f_ty	.tyexpr
α	.tylambda	*
β	.tylambda	*
	.tylift
	.tyfun	β
	.tylift
	.tyfun	α
	.tyref	β

# §section §gs{list.<>}

_list.<>.ty	.tyexpr
list.t	.tygvar
α	.tyforall	*
	.tylift
	.tyfun	list.t	α
	.tylift
	.tyfun	list.t	α
	.tyref	list.t	α

# §section §gs{list.≡}

_list.≡.ty	.tyexpr
bool.t	.tygvar
list.t	.tygvar
_list.≡.arg.ty	.tygvar
α	.tyforall	*
at	.tylet	_list.≡.arg.ty	α
	.tylift
	.tyfun	at
	.tylift
	.tyfun	list.t	α
	.tylift
	.tyfun	list.t	α
	.tyref	bool.t

_list.≡.arg.ty	.tyexpr
bool.t	.tygvar
α	.tylambda	*
	.tylift
	.tyfun	α
	.tylift
	.tyfun	α
	.tyref	bool.t

# §section §gs{list.compare}

_list.compare_ty	.tyexpr
order.total.t	.tygvar
list.t	.tygvar
α	.tyforall	*
arg.ty	.tylet	list.t	α
	.tylift
	.tyfun	order.total.t	α
	.tyref	order.total.t	arg.ty

# §section §gs{list.print}

list.print.list.t	.tyexpr
list.t	.tygvar
rune.t	.tygvar
α	.tylambda	*
	.tylift
	.tyfun	list.t	α
	.tyref	list.t	rune.t

_list.print.byDefault_ty	.tyexpr
print.t	.tygvar
list.print.list.t	.tygvar
α	.tyforall	*
	.tylift
	.tyfun	print.t	α
	.tyref	list.print.list.t	α

	.coercion

list.t.out	.tycoercion
list.t	.tygvar
α	.tylambda	*
	.tyinvert
	.tydefinition	list.t	α

list.t.in	.tycoercion
list.t	.tygvar
α	.tylambda	*
	.tydefinition	list.t	α
