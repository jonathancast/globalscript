#type: prefix
module _ibio.prim = 〈
    module _unwrapped = 〈
        abstype m = "apitype ibio.prim.basic;
        read :: (∀ 's. iport.u s → acceptor.u s "Π〈〉 → m (iptr.u s)) = "apiprim ibio.prim.basic read;
        write :: (∀ 's. oport.u s → list.t s → m "Π〈〉) = "apiprim ibio.prim.basic write;
        abort :: (∀ 'α. list.t rune → m α) = "apiprim ibio.prim.basic abort;
    〉;
    type unwrapped.m = #type m _unwrapped;
    read = #read _unwrapped;
    write = #write _unwrapped;
    abort = #abort _unwrapped;
    module _wrapped = 〈
        abstype t ι ο α = iport.u ι → oport.u ο → oport.u rune → unwrapped.m α;
        in = λ (type ι). λ (type ο). λ (type α). λ (i :: iport.u ι → oport.u ο → oport.u rune → unwrapped.m α).
            i :: t ι ο α
        ;
        match in = λ (type ι). λ (type ο). λ (type α). λ (type β).
            λ (k :: (iport.u ι → oport.u ο → oport.u rune → unwrapped.m α) → β). λ (e :: β). λ (x :: t ι ο α).
                k x
        ;
        out = λ (type ι). λ (type ο). λ (type α). λ (i :: t ι ο α).
            i :: iport.u ι → oport.u ο → oport.u rune → unwrapped.m α
        ;
        match out = λ (type ι). λ (type ο). λ (type α). λ (type β).
            λ (k :: t ι ο α → β). λ (e :: β). λ (x :: iport.u ι → oport.u ο → oport.u rune → unwrapped.m α).
                k x
        ;
    〉;
    type wrapped.t = #type t _wrapped;
    wrapped.in = #in _wrapped;
    match wrapped.in = #match in _wrapped;
    wrapped.out = #out _wrapped;
    match wrapped.out = #match out _wrapped;
    -- etc.
〉;
