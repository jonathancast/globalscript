	.document

	.data

	.closure	_epcode

_tests	.list	test.property.t	_test.fail.nil	_test.fail.msg.nil	_test.unit.nil	_test.symbol.nil	_test.match.empty.nil	_test.err.fmt.simple.failure	_test.err.≡.simple.failure.simple.failure	_test.err.print.simple.failure	_test.pos.fmt.not.eof	_test.pos.eq.x.x	_test.pos.eq.diff.file	_test.pos.eq.diff.col	_test.pos.print

_test.fail.nil	.closure	_test.fail.nil_c
_test.fail.nil_label	.string	parse\sfail\sqq{}

_test.fail.msg.nil	.closure	_test.fail.msg.nil_c
_test.fail.msg.nil_label	.string	parse\sfail.msg\sqq{}
_test.fail.msg.nil_sample.msg	.string	User-supplied\serror
_test.fail.msg.nil_err.fmt.expected	.string	./parse-data:\sUser-supplied\serror

_test.unit.nil	.closure	_test.unit.nil_c
_test.unit.nil_label	.string	parse\s(unit\strue)\sqq{}

_test.symbol.nil	.closure	_test.symbol.nil_c
_test.symbol.nil_label	.string	parse\ssymbol\sqq{}
_test.symbol.nil_expected	.string	./parse-data:\sUn-expected\sEOF;\sexpected\ssymbol

_test.match.empty.nil	.closure	_test.match.empty.nil_c
_test.match.empty.nil_label	.string	parse\sm//\sqq{}

_test.err.fmt.simple.failure	.closure	_test.err.fmt.simple.failure_c
_test.err.fmt.simple.failure_label	.string	parser.err.fmt\ssimple.failure
_test.err.fmt.simple.failure_expected	.string	./parse-data:\sParse\sfailure

_test.err.≡.simple.failure.simple.failure	.closure	_test.err.≡.simple.failure.simple.failure_c
_test.err.≡.simple.failure.simple.failure_label	.string	simple.failure\s≡\ssimple.failure
_test.err.≡.simple.failure.simple.failure_fail.msg	.string	simple.failure\s≠\ssimple.failure
_test.err.≡.simple.failure.simple.failure_succ.msg	.string	simple.failure\s≡\ssimple.failure

_test.err.print.simple.failure	.closure	_test.err.print.simple.failure_c
_test.err.print.simple.failure_label	.string	err.print\ssimple.failure\strue
_test.err.print.simple.failure_expected	.string	simple.failure\strue\s〈〉

_test.pos.fmt.not.eof	.closure	_test.pos.fmt.not.eof_c
_test.pos.fmt.not.eof_label	.string	pos.fmt\sfalse\sinitial.pos
_test.pos.fmt.not.eof_expected	.string	./parse-data:1:1

_test.pos.eq.x.x	.closure	_test.pos.eq.x.x_c
_test.pos.eq.x.x_label	.string	parser.pos.≡\sx\sx
_test.pos.eq.x.x_fail.msg	.string	pos.initial\sfn\s≠\spos.initial\sfn
_test.pos.eq.x.x_succ.msg	.string	pos.initial\sfn\s≡\spos.initial\sfn

_test.pos.eq.diff.file	.closure	_test.pos.eq.diff.file_c
_test.pos.eq.diff.file_label	.string	parser.pos.≡\s(pos.initial\sfn<./foo>)\s(pos.initial\sfn<./bar>)
_test.pos.eq.diff.file_false.msg	.string	pos.initial\sfn<./foo>\s≠\spos.initial\sfn<./bar>
_test.pos.eq.diff.file_true.msg	.string	pos.initial\sfn<./foo>\s≡\spos.initial\sfn<./bar>
_test.pos.eq.diff.file_foo.s	.string	./foo
_test.pos.eq.diff.file_bar.s	.string	./bar

_test.pos.eq.diff.col	.closure	_test.pos.eq.diff.col_c
_test.pos.eq.diff.col_label	.string	parser.pos.≡\s(pos.next.col\sx)\sx
_test.pos.eq.diff.col_false.msg	.string	pos.next.col\sx\s≠\sx
_test.pos.eq.diff.col_true.msg	.string	pos.next.col\sx\s≡\sx
_test.pos.eq.diff.col_foo.s	.string	./foo

_test.pos.print	.closure	_test.pos.print_c
_test.pos.print_label	.string	pos.print\spos.initial
_test.pos.print_expected	.string	〈〉

	.code

_epcode	.expr
test.all	.gvar
_tests	.gvar
	.app	_tests
	.enter	test.all

# §section §gs{parse fail qq{}}

_test.fail.nil_c	.expr
rune.t	.tygvar
record.empty	.tygvar
_test.fail.nil_k_c	.subcode
test.property.label	.gvar
_test.fail.nil_label	.gvar
parser.test.assert.fails	.gvar
record.empty.print	.gvar
parser.fail	.gvar
list.nil	.gvar
fail	.apply	parser.fail	rune.t	record.empty
nil	.apply	list.nil	rune.t
k	.alloc	_test.fail.nil_k_c
test	.apply	parser.test.assert.fails	rune.t	record.empty	|	record.empty.print	fail	nil	k
	.app	_test.fail.nil_label	test
	.enter	test.property.label

_test.fail.nil_k_c	.expr
parser.err.t	.tygvar
test.assert.eq	.gvar
parser.err.≡	.gvar
parser.err.print	.gvar
parser.err.simple.failure	.gvar
bool.true	.gvar
parser.pos.initial	.gvar
parser.test.assert.fixtures.sample.file.name	.gvar
err	.larg	parser.err.t
pos	.apply	parser.pos.initial	|	parser.test.assert.fixtures.sample.file.name
expected	.apply	parser.err.simple.failure	|	pos	bool.true
	.app	parser.err.≡	parser.err.print	err	expected
	.enter	test.assert.eq	parser.err.t

# §section §gs{parse fail.msg qq{}}

_test.fail.msg.nil_c	.expr
rune.t	.tygvar
record.empty	.tygvar
_test.fail.msg.nil_k_c	.subcode
test.property.label	.gvar
_test.fail.msg.nil_label	.gvar
parser.test.assert.fails	.gvar
record.empty.print	.gvar
parser.fail.msg	.gvar
_test.fail.msg.nil_sample.msg	.gvar
list.nil	.gvar
parser	.apply	parser.fail.msg	rune.t	record.empty	|	_test.fail.msg.nil_sample.msg
nil	.apply	list.nil	rune.t
k	.alloc	_test.fail.msg.nil_k_c
test	.apply	parser.test.assert.fails	rune.t	record.empty	|	record.empty.print	parser	nil	k
	.app	_test.fail.msg.nil_label	test
	.enter	test.property.label

_test.fail.msg.nil_k_c	.expr
parser.err.t	.tygvar
list.t	.tygvar
rune.t	.tygvar
string.ty	.tylet	list.t	rune.t
test.assert.eq	.gvar
list.≡	.gvar
rune.≡	.gvar
list.print	.gvar
rune.print.list	.gvar
parser.err.fmt	.gvar
_test.fail.msg.nil_err.fmt.expected	.gvar
err	.larg	parser.err.t
string.≡	.apply	list.≡	rune.t	|	rune.≡
string.print	.apply	list.print	rune.t	|	rune.print.list
err.fmt	.apply	parser.err.fmt	|	err
	.app	string.≡	string.print	err.fmt	_test.fail.msg.nil_err.fmt.expected
	.enter	test.assert.eq	string.ty

# §section §gs{parse unit qq{}}

_test.unit.nil_c	.expr
rune.t	.tygvar
bool.t	.tygvar
_test.unit.nil_k_c	.subcode
test.property.label	.gvar
_test.unit.nil_label	.gvar
parser.test.assert.passes	.gvar
parser.unit	.gvar
bool.true	.gvar
list.nil	.gvar
parser	.apply	parser.unit	rune.t	bool.t	|	bool.true
nil	.apply	list.nil	rune.t
k	.alloc	_test.unit.nil_k_c
test	.apply	parser.test.assert.passes	rune.t	bool.t	|	parser	nil	k
	.app	_test.unit.nil_label	test
	.enter	test.property.label

_test.unit.nil_k_c	.expr
bool.t	.tygvar
test.assert.eq	.gvar
bool.≡	.gvar
bool.print	.gvar
bool.true	.gvar
x	.larg	bool.t
	.app	bool.≡	bool.print	x	bool.true
	.enter	test.assert.eq	bool.t

# §section §gs{parse symbol qq{}}

_test.symbol.nil_c	.expr
rune.t	.tygvar
_test.symbol.nil_k_c	.subcode
test.property.label	.gvar
_test.symbol.nil_label	.gvar
parser.test.assert.fails	.gvar
rune.print	.gvar
parser.symbol	.gvar
list.nil	.gvar
sym	.apply	parser.symbol	rune.t
nil	.apply	list.nil	rune.t
k	.alloc	_test.symbol.nil_k_c
test	.apply	parser.test.assert.fails	rune.t	rune.t	|	rune.print	sym	nil	k
	.app	_test.symbol.nil_label	test
	.enter	test.property.label

_test.symbol.nil_k_c	.expr
parser.err.t	.tygvar
list.t	.tygvar
rune.t	.tygvar
string.ty	.tylet	list.t	rune.t
test.assert.eq	.gvar
list.≡	.gvar
rune.≡	.gvar
list.print	.gvar
rune.print.list	.gvar
parser.err.fmt	.gvar
_test.symbol.nil_expected	.gvar
err	.larg	parser.err.t
string.≡	.apply	list.≡	rune.t	|	rune.≡
string.print	.apply	list.print	rune.t	|	rune.print.list
err.s	.apply	parser.err.fmt	|	err
	.app	string.≡	string.print	err.s	_test.symbol.nil_expected
	.enter	test.assert.eq	string.ty

# §section §gs{parse m// qq{}}

_test.match.empty.nil_c	.expr
rune.t	.tygvar
list.t	.tygvar
string.ty	.tylet	list.t	rune.t
_test.match.empty.nil_k_c	.subcode
test.property.label	.gvar
_test.match.empty.nil_label	.gvar
parser.test.assert.passes	.gvar
parser.match	.gvar
regex.empty	.gvar
list.nil	.gvar
empty	.apply	regex.empty	rune.t
parser	.apply	parser.match	rune.t	|	empty
nil	.apply	list.nil	rune.t
k	.alloc	_test.match.empty.nil_k_c
test	.apply	parser.test.assert.passes	rune.t	string.ty	|	parser	nil	k
	.app	_test.match.empty.nil_label	test
	.enter	test.property.label

_test.match.empty.nil_k_c	.expr
list.t	.tygvar
rune.t	.tygvar
string.ty	.tylet	list.t	rune.t
test.assert.eq	.gvar
list.≡	.gvar
rune.≡	.gvar
list.print	.gvar
rune.print.list	.gvar
list.nil	.gvar
s	.larg	list.t	rune.t
string.≡	.apply	list.≡	rune.t	|	rune.≡
string.print	.apply	list.print	rune.t	|	rune.print.list
nil	.apply	list.nil	rune.t
	.app	string.≡	string.print	s	nil
	.enter	test.assert.eq	string.ty

# §section §gs{parser.err.fmt simple.failure}

_test.err.fmt.simple.failure_c	.expr
list.t	.tygvar
rune.t	.tygvar
string.ty	.tylet	list.t	rune.t
test.property.label	.gvar
_test.err.fmt.simple.failure_label	.gvar
test.assert.eq	.gvar
list.≡	.gvar
rune.≡	.gvar
list.print	.gvar
rune.print.list	.gvar
parser.err.fmt	.gvar
parser.err.simple.failure	.gvar
bool.true	.gvar
parser.pos.initial	.gvar
parser.test.assert.fixtures.sample.file.name	.gvar
_test.err.fmt.simple.failure_expected	.gvar
string.≡	.apply	list.≡	rune.t	|	rune.≡
string.print	.apply	list.print	rune.t	|	rune.print.list
pos	.apply	parser.pos.initial	|	parser.test.assert.fixtures.sample.file.name
sf	.apply	parser.err.simple.failure	|	pos	bool.true
actual	.apply	parser.err.fmt	|	sf
test	.apply	test.assert.eq	string.ty	|	string.≡	string.print	actual	_test.err.fmt.simple.failure_expected
	.app	_test.err.fmt.simple.failure_label	test
	.enter	test.property.label

# §section §gs{simple.failure ≡ simple.failure}

_test.err.≡.simple.failure.simple.failure_c	.expr
test.property.label	.gvar
_test.err.≡.simple.failure.simple.failure_label	.gvar
test.assert	.gvar
_test.err.≡.simple.failure.simple.failure_fail.msg	.gvar
_test.err.≡.simple.failure.simple.failure_succ.msg	.gvar
parser.err.≡	.gvar
parser.err.simple.failure	.gvar
bool.true	.gvar
parser.pos.initial	.gvar
parser.test.assert.fixtures.sample.file.name	.gvar
pos	.apply	parser.pos.initial	|	parser.test.assert.fixtures.sample.file.name
sf	.apply	parser.err.simple.failure	|	pos	bool.true
b	.apply	parser.err.≡	|	sf	sf
test	.apply	test.assert	|	_test.err.≡.simple.failure.simple.failure_fail.msg	_test.err.≡.simple.failure.simple.failure_succ.msg	b
	.app	_test.err.≡.simple.failure.simple.failure_label	test
	.enter	test.property.label

# > test.property.label qq{...} $
# >     test.assert qq{...} qq{...} $
# >         parser.err.≡ sf sf
# > where
# >     'sf ∝ parser.err.simple.failure (parser.pos.initial parser.test.assert.fixtures.sample.file.name)

# §section §gs{parser.err.print simple.failure}

_test.err.print.simple.failure_c	.expr
list.t	.tygvar
rune.t	.tygvar
string.ty	.tylet	list.t	rune.t
test.property.label	.gvar
_test.err.print.simple.failure_label	.gvar
test.assert.eq	.gvar
list.≡	.gvar
rune.≡	.gvar
list.print	.gvar
rune.print.list	.gvar
parser.err.print	.gvar
parser.err.simple.failure	.gvar
bool.true	.gvar
parser.pos.initial	.gvar
parser.test.assert.fixtures.sample.file.name	.gvar
_test.err.print.simple.failure_expected	.gvar
string.≡	.apply	list.≡	rune.t	|	rune.≡
string.print	.apply	list.print	rune.t	|	rune.print.list
pos	.apply	parser.pos.initial	|	parser.test.assert.fixtures.sample.file.name
sf	.apply	parser.err.simple.failure	|	pos	bool.true
sf.s	.apply	parser.err.print	|	sf
test	.apply	test.assert.eq	string.ty	|	string.≡	string.print	sf.s	_test.err.print.simple.failure_expected
	.app	_test.err.print.simple.failure_label	test
	.enter	test.property.label

# §section §gs{parser.pos.fmt false initial.pos}

_test.pos.fmt.not.eof_c	.expr
list.t	.tygvar
rune.t	.tygvar
string.ty	.tylet	list.t	rune.t
test.property.label	.gvar
_test.pos.fmt.not.eof_label	.gvar
test.assert.eq	.gvar
list.≡	.gvar
rune.≡	.gvar
list.print	.gvar
rune.print.list	.gvar
parser.pos.fmt	.gvar
bool.false	.gvar
parser.pos.initial	.gvar
parser.test.assert.fixtures.sample.file.name	.gvar
_test.pos.fmt.not.eof_expected	.gvar
string.≡	.apply	list.≡	rune.t	|	rune.≡
string.print	.apply	list.print	rune.t	|	rune.print.list
pos	.apply	parser.pos.initial	|	parser.test.assert.fixtures.sample.file.name
actual	.apply	parser.pos.fmt	|	bool.false	pos
test	.apply	test.assert.eq	string.ty	|	string.≡	string.print	actual	_test.pos.fmt.not.eof_expected
	.app	_test.pos.fmt.not.eof_label	test
	.enter	test.property.label

# §section §gs{parser.pos.≡ x x}

_test.pos.eq.x.x_c	.expr
test.property.label	.gvar
_test.pos.eq.x.x_label	.gvar
test.assert	.gvar
_test.pos.eq.x.x_fail.msg	.gvar
_test.pos.eq.x.x_succ.msg	.gvar
parser.pos.≡	.gvar
parser.pos.initial	.gvar
parser.test.assert.fixtures.sample.file.name	.gvar
pos	.apply	parser.pos.initial	|	parser.test.assert.fixtures.sample.file.name
b	.apply	parser.pos.≡	|	pos	pos
test	.apply	test.assert	|	_test.pos.eq.x.x_fail.msg	_test.pos.eq.x.x_succ.msg	b
	.app	_test.pos.eq.x.x_label	test
	.enter	test.property.label

# §section §gs{parser.pos.≡ (pos.initial fn<./foo>) (pos.initial fn<./bar>)}

_test.pos.eq.diff.file_c	.expr
test.property.label	.gvar
_test.pos.eq.diff.file_label	.gvar
test.deny	.gvar
_test.pos.eq.diff.file_false.msg	.gvar
_test.pos.eq.diff.file_true.msg	.gvar
parser.pos.≡	.gvar
parser.pos.initial	.gvar
ibio.file.name.read	.gvar
_test.pos.eq.diff.file_foo.s	.gvar
_test.pos.eq.diff.file_bar.s	.gvar
foo.fn	.apply	ibio.file.name.read	|	_test.pos.eq.diff.file_foo.s
foo.pos	.apply	parser.pos.initial	|	foo.fn
bar.fn	.apply	ibio.file.name.read	|	_test.pos.eq.diff.file_bar.s
bar.pos	.apply	parser.pos.initial	|	bar.fn
b	.apply	parser.pos.≡	|	foo.pos	bar.pos
test	.apply	test.deny	|	_test.pos.eq.diff.file_false.msg	_test.pos.eq.diff.file_true.msg	b
	.app	_test.pos.eq.diff.file_label	test
	.enter	test.property.label

# §section §gs{parser.pos.≡ (pos.next.col x) x}

_test.pos.eq.diff.col_c	.expr
test.property.label	.gvar
_test.pos.eq.diff.col_label	.gvar
test.deny	.gvar
_test.pos.eq.diff.col_false.msg	.gvar
_test.pos.eq.diff.col_true.msg	.gvar
parser.pos.≡	.gvar
parser.pos.next.col	.gvar
parser.pos.initial	.gvar
ibio.file.name.read	.gvar
_test.pos.eq.diff.col_foo.s	.gvar
foo.fn	.apply	ibio.file.name.read	|	_test.pos.eq.diff.col_foo.s
foo.pos	.apply	parser.pos.initial	|	foo.fn
foo.pos.1	.apply	parser.pos.next.col	|	foo.pos
b	.apply	parser.pos.≡	|	foo.pos.1	foo.pos
test	.apply	test.deny	|	_test.pos.eq.diff.col_false.msg	_test.pos.eq.diff.col_true.msg	b
	.app	_test.pos.eq.diff.col_label	test
	.enter	test.property.label

# §section §gs{parser.pos.print simple.failure}

_test.pos.print_c	.expr
list.t	.tygvar
rune.t	.tygvar
string.ty	.tylet	list.t	rune.t
test.property.label	.gvar
_test.pos.print_label	.gvar
test.assert.eq	.gvar
list.≡	.gvar
rune.≡	.gvar
list.print	.gvar
rune.print.list	.gvar
parser.pos.print	.gvar
parser.pos.initial	.gvar
parser.test.assert.fixtures.sample.file.name	.gvar
_test.pos.print_expected	.gvar
string.≡	.apply	list.≡	rune.t	|	rune.≡
string.print	.apply	list.print	rune.t	|	rune.print.list
pos	.apply	parser.pos.initial	|	parser.test.assert.fixtures.sample.file.name
pos.s	.apply	parser.pos.print	|	pos
test	.apply	test.assert.eq	string.ty	|	string.≡	string.print	pos.s	_test.pos.print_expected
	.app	_test.pos.print_label	test
	.enter	test.property.label
