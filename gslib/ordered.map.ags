	.prefix

# Note: this library doesn't balance its binary trees;
# that will need to be fixed but I want to see what the performance looks like directly first.

	.data

ordered.map.empty	.closure	_ordered.map.empty_c
ordered.map.insert	.closure	_ordered.map.insert_c	_ordered.map.insert_ty
ordered.map.get	.closure	_ordered.map.get_c	_ordered.map.get_ty
ordered.map.∪	.closure	_ordered.map.∪_c	_ordered.map.∪_ty

ordered.map.values	.closure	_ordered.map.values_c
_ordered.map.values_w	.closure	_ordered.map.values_w_c	_ordered.map.values_w_ty

ordered.map.≡	.closure	_ordered.map.≡_c	_ordered.map.≡_ty

ordered.map.prim.branch	.closure	_ordered.map.prim.branch_c

	.code

# §section §gs{ordered.map.empty}

_ordered.map.empty_c	.expr
ordered.map.prim.u	.tygvar
ordered.map.t.in	.cogvar
k	.tyarg	*
v	.tyarg	*
res.u	.tylet	ordered.map.prim.u	k	v
e	.constr	res.u	empty
	.coerce	ordered.map.t.in	k	v
	.lift
	.yield	e

# §section §gs{ordered.map.insert}

_ordered.map.insert_c	.expr
order.total.t	.tygvar
ordered.map.t	.tygvar
_ordered.map.insert_k	.subcode
ordered.map.t.out	.cogvar
k	.tyarg	*
v	.tyarg	*
cmp	.larg	order.total.t	k
k	.larg	k
v	.larg	v
map	.larg	ordered.map.t	k	v
	.force	_ordered.map.insert_k
	.coerce	ordered.map.t.out	k	v
	.enter	map

_ordered.map.insert_k	.forcecont
order.total.t	.tygvar
ordered.map.prim.u	.tygvar
ordered.map.t	.tygvar
_ordered.map.insert_branch_k	.subcode
order.total.ord.t.out	.cogvar
ordered.map.prim.branch	.gvar
ordered.map.empty	.gvar
k	.tyfv	*
v	.tyfv	*
cmp	.fv	order.total.t	k
k	.fv	k
v	.fv	v
map.0	.karg	ordered.map.prim.u	k	v
	.analyze	map.0	branch	empty
		.case	branch
k1		.fkarg	0	k
v1		.fkarg	1	v
map.l		.fkarg	2	ordered.map.t	k	v
map.r		.fkarg	3	ordered.map.t	k	v
			.force	_ordered.map.insert_branch_k
			.coerce	order.total.ord.t.out
			.app	k	k1
			.enter	cmp
		.case	empty
empty			.apply	ordered.map.empty	k	v
			.app	k	v	empty	empty
			.enter	ordered.map.prim.branch	k	v
	# > ordered.map.t	k	v

_ordered.map.insert_branch_k	.forcecont
order.total.t	.tygvar
ordered.map.t	.tygvar
order.total.ord.prim.u	.tygvar
ordered.map.prim.branch	.gvar
ordered.map.insert	.gvar
k	.tyfv	*
v	.tyfv	*
cmp	.fv	order.total.t	k
k	.fv	k
v	.fv	v
k1	.fv	k
v1	.fv	v
map.l	.fv	ordered.map.t	k	v
map.r	.fv	ordered.map.t	k	v
o0	.karg	order.total.ord.prim.u
	.analyze	o0	eq	gt	lt
		.case	eq
			.undef	ordered.map.t	k	v
		.case	gt
map.r1			.apply	ordered.map.insert	k	v	|	cmp	k	v	map.r
			.app	k1	v1	map.l	map.r1
			.enter	ordered.map.prim.branch	k	v
		.case	lt
			.undef	ordered.map.t	k	v

# §section §gs{ordered.map.get}

_ordered.map.get_c	.expr
order.total.t	.tygvar
ordered.map.t	.tygvar
_ordered.map.get_k0	.subcode
ordered.map.t.out	.cogvar
k	.tyarg	*
v	.tyarg	*
ord	.larg	order.total.t	k
key	.larg	k
map	.larg	ordered.map.t	k	v
	.force	_ordered.map.get_k0
	.coerce	ordered.map.t.out	k	v
	.enter	map

_ordered.map.get_k0	.forcecont
order.total.t	.tygvar
ordered.map.prim.u	.tygvar
ordered.map.t	.tygvar
_ordered.map.get_branch_k	.subcode
order.total.ord.t.out	.cogvar
maybe.nothing	.gvar
k	.tyfv	*
v	.tyfv	*
ord	.fv	order.total.t	k
key	.fv	k
map.0	.karg	ordered.map.prim.u	k	v
	.analyze	map.0	branch	empty
		.case	branch
key1		.fkarg	0	k
v		.fkarg	1	v
map.l		.fkarg	2	ordered.map.t	k	v
map.r		.fkarg	3	ordered.map.t	k	v
			.force	_ordered.map.get_branch_k
			.coerce	order.total.ord.t.out
			.app	key	key1
			.enter	ord
		.case	empty
			.enter	maybe.nothing	v
	# > :: maybe.t	v

_ordered.map.get_branch_k	.forcecont
order.total.t	.tygvar
ordered.map.t	.tygvar
order.total.ord.prim.u	.tygvar
maybe.t	.tygvar
maybe.just	.gvar
ordered.map.get	.gvar
k	.tyfv	*
v	.tyfv	*
ord	.fv	order.total.t	k
key	.fv	k
v	.fv	v
map.l	.fv	ordered.map.t	k	v
map.r	.fv	ordered.map.t	k	v
o0	.karg	order.total.ord.prim.u
	.analyze	o0	eq	gt	lt
		.case	eq
			.app	v
			.yield	maybe.just	v
		.case	gt
			.app	ord	key	map.r
			.enter	ordered.map.get	k	v
		.case	lt
			.app	ord	key	map.l
			.enter	ordered.map.get	k	v

# §section §gs{ordered.map.∪}

_ordered.map.∪_c	.expr
order.total.t	.tygvar
ordered.map.t	.tygvar
_ordered.map.∪_k0	.subcode
ordered.map.t.out	.cogvar
k	.tyarg	*
v	.tyarg	*
cmp	.larg	order.total.t	k
map0	.larg	ordered.map.t	k	v
map1	.larg	ordered.map.t	k	v
	.force	_ordered.map.∪_k0
	.coerce	ordered.map.t.out	k	v
	.enter	map0

_ordered.map.∪_k0	.forcecont
ordered.map.t	.tygvar
ordered.map.prim.u	.tygvar
_ordered.map.∪_k1	.subcode
ordered.map.t.out	.cogvar
k	.tyfv	*
v	.tyfv	*
map1	.fv	ordered.map.t	k	v
map0.0	.karg	ordered.map.prim.u	k	v
	.force	_ordered.map.∪_k1
	.coerce	ordered.map.t.out	k	v
	.enter	map1

_ordered.map.∪_k1	.forcecont
ordered.map.prim.u	.tygvar
ordered.map.t	.tygvar
ordered.map.t.in	.cogvar
ordered.map.empty	.gvar
k	.tyfv	*
v	.tyfv	*
map0.0	.fv	ordered.map.prim.u	k	v
map1.0	.karg	ordered.map.prim.u	k	v
	.analyze	map0.0	branch	empty
		.case	branch
k0		.fkarg	0	k
v0		.fkarg	1	v
l0		.fkarg	2	ordered.map.t	k	v
r0		.fkarg	3	ordered.map.t	k	v
			.analyze	map1.0	branch	empty
				.case	branch
k1				.fkarg	0	k
v1				.fkarg	1	v
l1				.fkarg	2	ordered.map.t	k	v
r1				.fkarg	3	ordered.map.t	k	v
					.undef	ordered.map.t	k	v
				.case	empty
					.coerce	ordered.map.t.in	k	v
					.lift
					.yield	map0.0
		.case	empty
			.analyze	map1.0	branch	empty
				.case	branch
k1				.fkarg	0	k
v1				.fkarg	1	v
l1				.fkarg	2	ordered.map.t	k	v
r1				.fkarg	3	ordered.map.t	k	v
					.coerce	ordered.map.t.in	k	v
					.lift
					.yield	map1.0
				.case	empty
					.enter	ordered.map.empty	k	v

# §section §gs{ordered.map.values}

_ordered.map.values_c	.expr
ordered.map.t	.tygvar
_ordered.map.values_w	.gvar
list.nil	.gvar
k	.tyarg	*
v	.tyarg	*
map	.larg	ordered.map.t	k	v
nil	.apply	list.nil	v
	.app	map	nil
	.enter	_ordered.map.values_w	k	v

_ordered.map.values_w_c	.expr
ordered.map.t	.tygvar
list.t	.tygvar
_ordered.map.values_w_k	.subcode
ordered.map.t.out	.cogvar
k	.tyarg	*
v	.tyarg	*
map	.larg	ordered.map.t	k	v
vs	.larg	list.t	v
	.force	_ordered.map.values_w_k
	.coerce	ordered.map.t.out	k	v
	.enter	map

_ordered.map.values_w_k	.forcecont
list.t	.tygvar
ordered.map.prim.u	.tygvar
ordered.map.t	.tygvar
_ordered.map.values_w	.gvar
list.:	.gvar
k	.tyfv	*
v	.tyfv	*
vs	.fv	list.t	v
map0	.karg	ordered.map.prim.u	k	v
	.analyze	map0	branch	empty
		.case	branch
k0		.fkarg	0	k
v0		.fkarg	1	v
l		.fkarg	2	ordered.map.t	k	v
r		.fkarg	3	ordered.map.t	k	v
vs1			.apply	_ordered.map.values_w	k	v	|	r	vs
vs2			.apply	list.:	v	|	v0	vs1
			.app	l	vs2
			.enter	_ordered.map.values_w	k	v
		.case	empty
			.enter	vs

# §section §gs{ordered.map.≡}

_ordered.map.≡_c	.expr
order.total.t	.tygvar
eq.t	.tygvar
ordered.map.t	.tygvar
_ordered.map.≡_k0	.subcode
ordered.map.t.out	.cogvar
k	.tyarg	*
v	.tyarg	*
cmp	.larg	order.total.t	k
eq	.larg	eq.t	v
map0	.larg	ordered.map.t	k	v
map1	.larg	ordered.map.t	k	v
	.force	_ordered.map.≡_k0
	.coerce	ordered.map.t.out	k	v
	.enter	map0

_ordered.map.≡_k0	.forcecont
ordered.map.t	.tygvar
ordered.map.prim.u	.tygvar
_ordered.map.≡_k1	.subcode
ordered.map.t.out	.cogvar
k	.tyfv	*
v	.tyfv	*
map1	.fv	ordered.map.t	k	v
map0.0	.karg	ordered.map.prim.u	k	v
	.force	_ordered.map.≡_k1
	.coerce	ordered.map.t.out	k	v
	.enter	map1

_ordered.map.≡_k1	.forcecont
ordered.map.prim.u	.tygvar
ordered.map.t	.tygvar
bool.t	.tygvar	# Temp
bool.false	.gvar
bool.true	.gvar
k	.tyfv	*
v	.tyfv	*
map0.0	.fv	ordered.map.prim.u	k	v
map1.0	.karg	ordered.map.prim.u	k	v
	.analyze	map0.0	branch	empty
		.case	branch
k0		.fkarg	0	k
v0		.fkarg	1	v
l0		.fkarg	2	ordered.map.t	k	v
r0		.fkarg	3	ordered.map.t	k	v
			.undef	bool.t
		.case	empty
			.analyze	map1.0	branch	empty
				.case	branch
k1				.fkarg	0	k
v1				.fkarg	1	v
l1				.fkarg	2	ordered.map.t	k	v
r1				.fkarg	3	ordered.map.t	k	v
					.enter	bool.false
				.case	empty
					.enter	bool.true

# §section Constructors

_ordered.map.prim.branch_c	.expr
ordered.map.prim.u	.tygvar
ordered.map.t	.tygvar
ordered.map.t.in	.cogvar
k	.tyarg	*
v	.tyarg	*
res.u	.tylet	ordered.map.prim.u	k	v
k	.larg	k
v	.larg	v
map0	.larg	ordered.map.t	k	v
map1	.larg	ordered.map.t	k	v
e	.constr	res.u	branch	0	k	1	v	2	map0	3	map1
	.coerce	ordered.map.t.in	k	v
	.lift
	.yield	e

	.type

ordered.map.t	.tyabstract	**^*^
ordered.map.prim.u	.tygvar
k	.tylambda	*
v	.tylambda	*
	.tylift
	.tyref	ordered.map.prim.u	k	v

ordered.map.prim.u	.tyexpr
_ordered.map.prim.u_branch_ty	.tygvar
_ordered.map.prim.u_empty_ty	.tygvar
k	.tylambda	*
v	.tylambda	*
branch_ty	.tylet	_ordered.map.prim.u_branch_ty	k	v
	.tysum	branch	branch_ty	empty	_ordered.map.prim.u_empty_ty

_ordered.map.prim.u_branch_ty	.tyexpr
ordered.map.t	.tygvar
k	.tylambda	*
v	.tylambda	*
map_ty	.tylet	ordered.map.t	k	v
	.tyubproduct	0	k	1	v	2	map_ty	3	map_ty

_ordered.map.prim.u_empty_ty	.tyexpr
	.tyubproduct

# §section §gs{ordered.map.insert}

_ordered.map.insert_ty	.tyexpr
order.total.t	.tygvar
ordered.map.t	.tygvar
k	.tyforall	*
v	.tyforall	*
	.tylift
	.tyfun	order.total.t	k
	.tylift
	.tyfun	k
	.tylift
	.tyfun	v
	.tylift
	.tyfun	ordered.map.t	k	v
	.tyref	ordered.map.t	k	v

# §section §gs{ordered.map.get}

_ordered.map.get_ty	.tyexpr
order.total.t	.tygvar
ordered.map.t	.tygvar
maybe.t	.tygvar
k	.tyforall	*
v	.tyforall	*
	.tylift
	.tyfun	order.total.t	k
	.tylift
	.tyfun	k
	.tylift
	.tyfun	ordered.map.t	k	v
	.tyref	maybe.t	v

# §section §gs{ordered.map.∪}

_ordered.map.∪_ty	.tyexpr
order.total.t	.tygvar
ordered.map.t	.tygvar
k	.tyforall	*
v	.tyforall	*
	.tylift
	.tyfun	order.total.t	k
	.tylift
	.tyfun	ordered.map.t	k	v
	.tylift
	.tyfun	ordered.map.t	k	v
	.tyref	ordered.map.t	k	v

# §section §gs{ordered.map.values}

_ordered.map.values_w_ty	.tyexpr
ordered.map.t	.tygvar
list.t	.tygvar
k	.tyforall	*
v	.tyforall	*
	.tylift
	.tyfun	ordered.map.t	k	v
	.tylift
	.tyfun	list.t	v
	.tyref	list.t	v

# §section §gs{ordered.map.≡}

_ordered.map.≡_ty	.tyexpr
order.total.t	.tygvar
eq.t	.tygvar
ordered.map.t	.tygvar
bool.t	.tygvar
k	.tyforall	*
v	.tyforall	*
	.tylift
	.tyfun	order.total.t	k
	.tylift
	.tyfun	eq.t	v
	.tylift
	.tyfun	ordered.map.t	k	v
	.tylift
	.tyfun	ordered.map.t	k	v
	.tyref	bool.t

	.coercion

ordered.map.t.in	.tycoercion
ordered.map.t	.tygvar
k	.tylambda	*
v	.tylambda	*
	.tydefinition	ordered.map.t	k	v

ordered.map.t.out	.tycoercion
ordered.map.t	.tygvar
k	.tylambda	*
v	.tylambda	*
	.tyinvert
	.tydefinition	ordered.map.t	k	v
