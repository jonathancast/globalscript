	.document

	.data

	.closure	_epcode

_tests	.list	test.property.t	_test_get.empty	_test.get.k.insert.k.empty	_test.eq.empty.insert.k.empty	_test.empty.union.empty

_test_get.empty	.closure	_test_get.empty_c
_test_get.empty_label	.string	get\sx\sempty

_test.get.k.insert.k.empty	.closure	_test.get.k.insert.k.empty_c
_test.get.k.insert.k.empty_label	.string	get\s3\sinsert\s3\sempty

_test.eq.empty.insert.k.empty	.closure	_test.eq.empty.insert.k.empty_c
_test.eq.empty.insert.k.empty_label	.string	empty\s≡\sinsert\s3\sempty
_test.eq.empty.insert.k.empty_false	.string	empty\s≠\sinsert\s3\sempty
_test.eq.empty.insert.k.empty_true	.string	empty\s≡\sinsert\s3\sempty

_test.empty.union.empty	.closure	_test.empty.union.empty_c
_test.empty.union.empty_label	.string	empty\s∪\sempty

	.code

_epcode	.expr
test.all	.gvar
_tests	.gvar
	.app	_tests
	.enter	test.all

# §section §gs{get empty}

_test_get.empty_c	.expr
maybe.t	.tygvar
bool.t	.tygvar
natural.t	.tygvar
mb.t	.tylet	maybe.t	bool.t
test.property.label	.gvar
_test_get.empty_label	.gvar
test.assert.eq	.gvar
maybe.≡	.gvar
bool.≡	.gvar
maybe.fmtgs	.gvar
bool.fmtgs	.gvar
ordered.map.get	.gvar
natural.3	.gvar
ordered.map.empty	.gvar
natural.compare	.gvar
maybe.nothing	.gvar
mb.≡	.apply	maybe.≡	bool.t	|	bool.≡
mb.fmtgs	.apply	maybe.fmtgs	bool.t	|	bool.fmtgs
empty	.apply	ordered.map.empty	natural.t	bool.t
actual	.apply	ordered.map.get	natural.t	bool.t	|	natural.compare	natural.3	empty
nothing	.apply	maybe.nothing	bool.t
test	.apply	test.assert.eq	mb.t	|	mb.≡	mb.fmtgs	actual	nothing
	.app	_test_get.empty_label	test
	.enter	test.property.label

# §section §gs{get 3 (insert 3 empty)}

_test.get.k.insert.k.empty_c	.expr
maybe.t	.tygvar
bool.t	.tygvar
natural.t	.tygvar
mb.t	.tylet	maybe.t	bool.t
test.property.label	.gvar
_test.get.k.insert.k.empty_label	.gvar
test.assert.eq	.gvar
maybe.≡	.gvar
bool.≡	.gvar
maybe.fmtgs	.gvar
bool.fmtgs	.gvar
ordered.map.get	.gvar
natural.compare	.gvar
natural.3	.gvar
ordered.map.insert	.gvar
bool.false	.gvar
ordered.map.empty	.gvar
maybe.just	.gvar
mb.≡	.apply	maybe.≡	bool.t	|	bool.≡
mb.fmtgs	.apply	maybe.fmtgs	bool.t	|	bool.fmtgs
empty	.apply	ordered.map.empty	natural.t	bool.t
map	.apply	ordered.map.insert	natural.t	bool.t	|	natural.compare	natural.3	bool.false	empty
actual	.apply	ordered.map.get	natural.t	bool.t	|	natural.compare	natural.3	map
just.false	.apply	maybe.just	bool.t	|	bool.false
test	.apply	test.assert.eq	mb.t	|	mb.≡	mb.fmtgs	actual	just.false
	.app	_test.get.k.insert.k.empty_label	test
	.enter	test.property.label

# §section §gs{empty ≡ insert 3 empty}

_test.eq.empty.insert.k.empty_c	.expr
natural.t	.tygvar
bool.t	.tygvar
test.property.label	.gvar
_test.eq.empty.insert.k.empty_label	.gvar
test.deny	.gvar
_test.eq.empty.insert.k.empty_false	.gvar
_test.eq.empty.insert.k.empty_true	.gvar
ordered.map.≡	.gvar
natural.compare	.gvar
bool.≡	.gvar
ordered.map.empty	.gvar
ordered.map.insert	.gvar
natural.3	.gvar
bool.false	.gvar
empty	.apply	ordered.map.empty	natural.t	bool.t
map	.apply	ordered.map.insert	natural.t	bool.t	|	natural.compare	natural.3	bool.false	empty
eq	.apply	ordered.map.≡	natural.t	bool.t	|	natural.compare	bool.≡	empty	map
test	.apply	test.deny	|	_test.eq.empty.insert.k.empty_false	_test.eq.empty.insert.k.empty_true	eq
	.app	_test.eq.empty.insert.k.empty_label	test
	.enter	test.property.label

# §section §gs{empty ∪ empty}

_test.empty.union.empty_c	.expr
ordered.map.t	.tygvar
natural.t	.tygvar
bool.t	.tygvar
fmtgs.t	.tygvar	# Temp
map.ty	.tylet	ordered.map.t	natural.t	bool.t
test.property.label	.gvar
_test.empty.union.empty_label	.gvar
test.assert.eq	.gvar
ordered.map.≡	.gvar
natural.compare	.gvar
bool.≡	.gvar
ordered.map.∪	.gvar
ordered.map.empty	.gvar
map.eq	.apply	ordered.map.≡	natural.t	bool.t	|	natural.compare	bool.≡
map.fmtgs	.undefined	fmtgs.t	map.ty
empty	.apply	ordered.map.empty	natural.t	bool.t
actual	.apply	ordered.map.∪	natural.t	bool.t	|	natural.compare	empty	empty
test	.apply	test.assert.eq	map.ty	|	map.eq	map.fmtgs	actual	empty
	.app	_test.empty.union.empty_label	test
	.enter	test.property.label
