	.document

	.data

	.cast	_real.entry	_ep.in
_real.entry	.closure	_real.entry_c

_args.parse	.closure	_args.parse_c	_args.parse_ty
_args.parsed.empty	.closure	_args.parsed.empty_c	_args.parsed.t
_flag.l	.string	-l

_prefix.init	.closure	_prefix.init_c	_prefix.init_ty

_prefix.load	.closure	_prefix.load_c	_prefix.load_ty

_prefix.typecheck	.closure	_prefix.typecheck_c	_prefix.typecheck_ty

	.code

_real.entry_c	.impprog	ibio.prim	ibio
ibio.prim.iport	.tygvar
ibio.prim.oport	.tygvar
rune.t	.tygvar
_real.entry_args_c	.subcode
_real.entry_parsed.args_c	.subcode
_real.entry_prefix.files_c	.subcode
_real.entry_cut.files_c	.subcode
_real.entry_cut_c	.subcode
_real.entry_cut.fvs_c	.subcode
_real.entry_prefix.loaded_c	.subcode
_real.entry_env_c	.subcode
_real.entry_output_c	.subcode
_real.entry_send.output_c	.subcode
i	.larg	ibio.prim.iport	rune.t
o	.larg	ibio.prim.oport	rune.t
eo	.larg	ibio.prim.oport	rune.t
args	.bind	_real.entry_args_c
parsed.args	.bind	_real.entry_parsed.args_c	# §gs{《 §gsinf{List of prefix arguments}, §gsinf{List of CUT arguments}, 》}
prefix.files	.alloc	_real.entry_prefix.files_c
cut.files	.alloc	_real.entry_cut.files_c
cut	.bind	_real.entry_cut_c
cut.fvs	.alloc	_real.entry_cut.fvs_c
prefix.loaded	.bind	_real.entry_prefix.loaded_c
env	.bind	_real.entry_env_c
output	.bind	_real.entry_output_c
	.body	_real.entry_send.output_c

_real.entry_args_c	.expr
ibio.prim.env.args.get	.gvar
	.yield	ibio.prim.env.args.get

# §section Split §gs{as} into (prefix arguments, component under test)

_real.entry_parsed.args_c	.expr
list.t	.tygvar
string.t	.tygvar
_args.parsed.t	.tygvar
_args.parse	.gvar
ibio.from.either.prim	.gvar
args	.fv	list.t	string.t
pa	.apply	_args.parse	|	args
	.app	pa
	.enter	ibio.from.either.prim	_args.parsed.t

# §section §gs{_args.parse}

_args.parse_c	.expr
list.t	.tygvar
string.t	.tygvar
_args.parse_k0	.subcode
list.t.out	.cogvar
as	.larg	list.t	string.t
	.force	_args.parse_k0
	.coerce	list.t.out	string.t
	.enter	as

_args.parse_k0	.forcecont
list.prim.u	.tygvar
string.t	.tygvar
list.t	.tygvar
rune.t	.tygvar
either.t	.tygvar
_args.parsed.t	.tygvar
_args.parse_k1	.subcode
bool.t.out	.cogvar
list.≡	.gvar
rune.≡	.gvar
_flag.l	.gvar
either.unit	.gvar
_args.parsed.empty	.gvar
as0	.karg	list.prim.u	string.t
	.analyze	as0	:	nil
		.case	:
a0		.fkarg	0	string.t
as1		.fkarg	1	list.t	string.t
			.force	_args.parse_k1
			.coerce	bool.t.out
			.app	rune.≡	a0	_flag.l
			.enter	list.≡	rune.t
		.case	nil
			.app	_args.parsed.empty
			.enter	either.unit	string.t	_args.parsed.t

_args.parse_k1	.forcecont
list.t	.tygvar
string.t	.tygvar
bool.prim.u	.tygvar
_args.parsed.t	.tygvar
_args.parse_file_pre_c	.subcode
_args.parse_l.option_k	.subcode
list.t.out	.cogvar
either.map	.gvar
_args.parse	.gvar
a0	.fv	string.t
as1	.fv	list.t	string.t
is.l0	.karg	bool.prim.u
	.analyze	is.l0	false	true
		.case	false
pre			.alloc	_args.parse_file_pre_c
ap0			.apply	_args.parse	|	as1
			.app	pre	ap0
			.enter	either.map	string.t	_args.parsed.t	_args.parsed.t
		.case	true
			.force	_args.parse_l.option_k
			.coerce	list.t.out	string.t
			.enter	as1

_args.parse_file_pre_c	.expr
string.t	.tygvar
_args.parsed.t	.tygvar
_args.parse_file_pre_k	.subcode
a0	.fv	string.t
ap0	.larg	_args.parsed.t
	.force	_args.parse_file_pre_k
	.enter	ap0

_args.parse_file_pre_k	.forcecont
string.t	.tygvar
_args.parsed.u	.tygvar
ibio.file.name.t	.tygvar
list.t	.tygvar	# Temp
list.:	.gvar
ibio.file.name.in	.gvar
a0	.fv	string.t
ap00	.karg	_args.parsed.u
ps	.field	0	ap00
cut1	.field	1	ap00
cut0	.apply	ibio.file.name.in	|	a0
cut	.apply	list.:	ibio.file.name.t	|	cut0	cut1
ap1	.record	0	ps	1	cut
	.lift
	.yield	ap1

# paragraph{§gs{a0} is §sh{-l} flag}
_args.parse_l.option_k	.forcecont
list.prim.u	.tygvar
string.t	.tygvar
list.t	.tygvar
either.t	.tygvar
_args.parsed.t	.tygvar
_args.parse_l.option_pre_c	.subcode
either.map	.gvar
_args.parse	.gvar
as1.0	.karg	list.prim.u	string.t
	.analyze	as1.0	:	nil
		.case	:
a1		.fkarg	0	string.t
as2		.fkarg	1	list.t	string.t
pre			.alloc	_args.parse_l.option_pre_c
ap0			.apply	_args.parse	|	as2
			.app	pre	ap0
			.enter	either.map	string.t	_args.parsed.t	_args.parsed.t
		.case	nil
			.undef	either.t	string.t	_args.parsed.t

# §paragraph{Prepend §gs{a1} to the list}
_args.parse_l.option_pre_c	.expr
string.t	.tygvar
_args.parsed.t	.tygvar
_args.parse_l.option_pre_k	.subcode
a1	.fv	string.t
ap0	.larg	_args.parsed.t
	.force	_args.parse_l.option_pre_k
	.enter	ap0

_args.parse_l.option_pre_k	.forcecont
string.t	.tygvar
_args.parsed.u	.tygvar
_args.parsed.t	.tygvar
list.t	.tygvar
ibio.file.name.t	.tygvar
list.:	.gvar
ibio.file.name.in	.gvar
a1	.fv	string.t
ap00	.karg	_args.parsed.u
ps	.field	0	ap00
cut	.field	1	ap00
fn	.apply	ibio.file.name.in	|	a1
ps1	.apply	list.:	ibio.file.name.t	|	fn	ps
ap1	.record	0	ps1	1	cut
	.lift
	.yield	ap1

_args.parsed.empty_c	.expr
ibio.file.name.t	.tygvar
list.nil	.gvar
ps	.apply	list.nil	ibio.file.name.t
cut	.apply	list.nil	ibio.file.name.t
r	.record	0	ps	1	cut
	.lift
	.yield	r

# §section Read files from §gs{parsed.args} as needed

_real.entry_prefix.files_c	.expr
_args.parsed.t	.tygvar
parsed.args	.fv	_args.parsed.t
fs	.lfield	0	parsed.args
	.enter	fs

_real.entry_cut.files_c	.expr
_args.parsed.t	.tygvar
parsed.args	.fv	_args.parsed.t
fs	.lfield	1	parsed.args
	.enter	fs

_real.entry_cut_c	.expr
ibio.prim.oport	.tygvar
rune.t	.tygvar
list.t	.tygvar
ibio.file.name.t	.tygvar
gsdl.cgs.file.t	.tygvar
ibio.mapM.prim	.gvar
gsdl.cgs.file.read	.gvar
eo	.fv	ibio.prim.oport	rune.t
cut.files	.fv	list.t	ibio.file.name.t
f	.apply	gsdl.cgs.file.read	|	eo
	.app	f	cut.files
	.enter	ibio.mapM.prim	ibio.file.name.t	gsdl.cgs.file.t

_real.entry_cut.fvs_c	.expr
list.t	.tygvar
gsdl.cgs.file.t	.tygvar
gsdl.cgs.symbol.t	.tygvar
ordered.set.t	.tygvar
set.symbol.ty	.tylet	ordered.set.t	gsdl.cgs.symbol.t
ordered.set.tolist	.gvar
gsdl.cgs.symbol.compare	.gvar
list.foldr	.gvar
ordered.set.union	.gvar
ordered.set.empty	.gvar
list.map	.gvar
gsdl.cgs.file.freevars	.gvar
cut	.fv	list.t	gsdl.cgs.file.t
fvs1	.apply	list.map	gsdl.cgs.file.t	set.symbol.ty	|	gsdl.cgs.file.freevars	cut
union	.apply	ordered.set.union	gsdl.cgs.symbol.t	|	gsdl.cgs.symbol.compare
empty	.apply	ordered.set.empty	gsdl.cgs.symbol.t
fvs	.apply	list.foldr	set.symbol.ty	set.symbol.ty	|	union	empty	fvs1
	.app	gsdl.cgs.symbol.compare	fvs
	.enter	ordered.set.tolist	gsdl.cgs.symbol.t

# ‘CUT’ = ‘component under translation’; ‘component’ = ‘strongly-connected component of the dependency graph’

#_real.entry_read.arguments_prefix.files_c	.expr
#_args.parsed.t	.tygvar
#_real.entry_read.arguments_prefix.files_k	.subcode
#parsed.args	.fv	_args.parsed.t
#	.force	_real.entry_read.arguments_prefix.files_k
#	.enter	parsed.args

#_real.entry_read.arguments_prefix_c	.expr
#ibio.prim.oport	.tygvar
#rune.t	.tygvar
#ibio.prim.t	.tygvar
#list.t	.tygvar
#gsac.input.prefix.t	.tygvar
#ibio.file.name.t	.tygvar
#ibio.mapM.prim	.gvar
#gsac.input.prefix.load	.gvar
#eo	.fv	ibio.prim.oport	rune.t
#prefix.files	.fv	list.t	ibio.file.name.t
#load	.apply	gsac.input.prefix.load	|	eo
#	.app	load	prefix.files
#	.enter	ibio.mapM.prim	ibio.file.name.t	gsac.input.prefix.t

#_real.entry_read.arguments_body_c	.expr
#list.t	.tygvar
#gsdl.cgs.file.t	.tygvar
#_real.entry_read.arguments_ty	.tygvar
#ibio.prim.unit	.gvar
#cut	.fv	list.t	gsdl.cgs.file.t
#res	.lrecord	cut	cut
#	.lift
#	.app	res
#	.yield	ibio.prim.unit	_real.entry_read.arguments_ty

# §section Load those files depended on by the CUT

_real.entry_prefix.loaded_c	.expr
list.t	.tygvar
gsdl.cgs.symbol.t	.tygvar
ibio.file.name.t	.tygvar
_real.entry_prefix_ty	.tygvar
ibio.prim.t	.tygvar	# Temp
_prefix.load	.gvar
_prefix.init	.gvar
list.nil	.gvar
prefix.files	.fv	list.t	ibio.file.name.t
cut.fvs	.fv	list.t	gsdl.cgs.symbol.t
init1	.apply	list.nil	_real.entry_prefix_ty
init	.apply	_prefix.init	|	init1	prefix.files
	.app	cut.fvs	init
	.enter	_prefix.load

# §gs{_prefix.init 'prn 'files} takes a list of files (as on the command line) §gs{files} and translates to a (reversed) initial prefix, prepended to §gs{prn}.
# We are tail-recursive because we §emph{want} to reverse §gs{files} as we work.
_prefix.init_c	.expr
list.t	.tygvar
_real.entry_prefix_ty	.tygvar
ibio.file.name.t	.tygvar
_prefix.init_k	.subcode
list.t.out	.cogvar
prn	.larg	list.t	_real.entry_prefix_ty
fns	.larg	list.t	ibio.file.name.t
	.force	_prefix.init_k
	.coerce	list.t.out	ibio.file.name.t
	.enter	fns

_prefix.init_k	.forcecont
list.t	.tygvar
_real.entry_prefix_ty	.tygvar
list.prim.u	.tygvar
ibio.file.name.t	.tygvar
_prefix.init	.gvar
list.:	.gvar
prn	.fv	list.t	_real.entry_prefix_ty
fns0	.karg	list.prim.u	ibio.file.name.t
	.analyze	fns0	:	nil
		.case	:
fn0		.fkarg	0	ibio.file.name.t
fns1		.fkarg	1	list.t	ibio.file.name.t
pr0			.undefined	_real.entry_prefix_ty
prn1			.apply	list.:	_real.entry_prefix_ty	|	pr0	prn
			.app	prn1	fns1
			.enter	_prefix.init
		.case	nil
			.enter	prn

_prefix.load_c	.expr
list.t	.tygvar
gsdl.cgs.symbol.t	.tygvar
_real.entry_prefix_ty	.tygvar
_prefix.load_k	.subcode
list.t.out	.cogvar
vs	.larg	list.t	gsdl.cgs.symbol.t
prn	.larg	list.t	_real.entry_prefix_ty
	.force	_prefix.load_k
	.coerce	list.t.out	gsdl.cgs.symbol.t
	.enter	vs

_prefix.load_k	.forcecont
list.t	.tygvar
_real.entry_prefix_ty	.tygvar
list.prim.u	.tygvar
gsdl.cgs.symbol.t	.tygvar
ibio.prim.t	.tygvar	# Temp
list.prefix.ty	.tylet	list.t	_real.entry_prefix_ty
ibio.prim.unit	.gvar
prn	.fv	list.t	_real.entry_prefix_ty
vs0	.karg	list.prim.u	gsdl.cgs.symbol.t
	.analyze	vs0	:	nil
		.case	:
v0		.fkarg	0	gsdl.cgs.symbol.t
vs1		.fkarg	1	list.t	gsdl.cgs.symbol.t
			.undef	ibio.prim.t	list.prefix.ty
		.case	nil
			.lift
			.app	prn
			.yield	ibio.prim.unit	list.prefix.ty

# §section Calculate type of the prefixen and build a type environment from them

_real.entry_env_c	.expr
list.t	.tygvar
_real.entry_prefix_ty	.tygvar
gsdl.cgs.typeenv.t	.tygvar
either.t	.tygvar	# Temp
string.t	.tygvar	# Temp
ibio.from.either.prim	.gvar
_prefix.typecheck	.gvar
prefix.loaded	.fv	list.t	_real.entry_prefix_ty
e	.apply	_prefix.typecheck	|	prefix.loaded
	.app	e
	.enter	ibio.from.either.prim	gsdl.cgs.typeenv.t

_prefix.typecheck_c	.expr
list.t	.tygvar
_real.entry_prefix_ty	.tygvar
_prefix.typecheck_k	.subcode
list.t.out	.cogvar
prn	.larg	list.t	_real.entry_prefix_ty
	.force	_prefix.typecheck_k
	.coerce	list.t.out	_real.entry_prefix_ty
	.enter	prn

_prefix.typecheck_k	.forcecont
list.prim.u	.tygvar
_real.entry_prefix_ty	.tygvar
list.t	.tygvar
string.t	.tygvar
gsdl.cgs.typeenv.t	.tygvar
_prefix.typecheck_:_k	.subcode
either.t.out	.cogvar
_prefix.typecheck	.gvar
either.right	.gvar
prn0	.karg	list.prim.u	_real.entry_prefix_ty
	.analyze	prn0	:	nil
		.case	:
pr0		.fkarg	0	_real.entry_prefix_ty
prn1		.fkarg	1	list.t	_real.entry_prefix_ty
			.force	_prefix.typecheck_:_k
			.coerce	either.t.out	string.t	gsdl.cgs.typeenv.t
			.app	prn1
			.enter	_prefix.typecheck
		.case	nil
env			.undefined	gsdl.cgs.typeenv.t
			.app	env
			.enter	either.right	string.t	gsdl.cgs.typeenv.t

_prefix.typecheck_:_k	.forcecont
either.prim.u	.tygvar
string.t	.tygvar
gsdl.cgs.typeenv.t	.tygvar
gsac.prefix.t	.tygvar
either.t	.tygvar	# Temp
_prefix.typecheck_:_right_k	.subcode
either.t.out	.cogvar
gsac.prefix.typecheck	.gvar
eenv0	.karg	either.prim.u	string.t	gsdl.cgs.typeenv.t
	.analyze	eenv0	left	right
		.case	left
err		.fkarg	0	string.t
			.undef	either.t	string.t	gsdl.cgs.typeenv.t
		.case	right
env		.fkarg	0	gsdl.cgs.typeenv.t
pr0.prefix			.undefined	gsac.prefix.t
			.force	_prefix.typecheck_:_right_k
			.coerce	either.t.out	string.t	gsdl.cgs.typeenv.t
			.app	env	pr0.prefix
			.enter	gsac.prefix.typecheck	# > :: gsdl.cgs.typeenv.t → gsac.prefix.t → either.t	string.t	gsdl.cgs.typeenv.t

_prefix.typecheck_:_right_k	.forcecont
gsdl.cgs.typeenv.t	.tygvar
either.prim.u	.tygvar
string.t	.tygvar
either.t	.tygvar	# Temp
gsdl.cgs.typeenv.overlay	.gvar
either.right	.gvar
env	.fv	gsdl.cgs.typeenv.t
eenv0	.karg	either.prim.u	string.t	gsdl.cgs.typeenv.t
	.analyze	eenv0	left	right
		.case	left
err		.fkarg	0	string.t
			.undef	either.t	string.t	gsdl.cgs.typeenv.t
		.case	right
env1		.fkarg	0	gsdl.cgs.typeenv.t
env2			.apply	gsdl.cgs.typeenv.overlay	|	env1	env
			.app	env2
			.enter	either.right	string.t	gsdl.cgs.typeenv.t

# §section Process §gs{sccs} to get (symtable, output)

# NB: We will need to read in §gs{.gsac} files --- those that we need --- §emph{before} this step;
# that can be deferred until a later stage.

_real.entry_output_c	.expr
gsdl.cgs.typeenv.t	.tygvar
gsdl.cgs.file.t	.tygvar
list.t	.tygvar	# Temp
_real.entry_output_k	.subcode
list.t.out	.cogvar
cut	.fv	list.t	gsdl.cgs.file.t
env	.fv	gsdl.cgs.typeenv.t
	.force	_real.entry_output_k
	.coerce	list.t.out	gsdl.cgs.file.t
	.enter	cut

_real.entry_output_k	.forcecont
gsdl.cgs.typeenv.t	.tygvar
list.prim.u	.tygvar
gsdl.cgs.file.t	.tygvar
list.t	.tygvar
ibio.prim.t	.tygvar	# Temp
gsdl.ags.file.t	.tygvar	# Temp
_real.entry_output_k1	.subcode
list.t.out	.cogvar
env	.fv	gsdl.cgs.typeenv.t
cut0	.karg	list.prim.u	gsdl.cgs.file.t
	.analyze	cut0	:	nil
		.case	:
cut0.0		.fkarg	0	gsdl.cgs.file.t
cut1		.fkarg	1	list.t	gsdl.cgs.file.t
			.force	_real.entry_output_k1
			.coerce	list.t.out	gsdl.cgs.file.t
			.enter	cut1
		.case	nil
			.undef	ibio.prim.t	gsdl.ags.file.t

_real.entry_output_k1	.forcecont
gsdl.cgs.typeenv.t	.tygvar
gsdl.cgs.file.t	.tygvar
list.prim.u	.tygvar
list.t	.tygvar
gsdl.ags.file.t	.tygvar	# Temp
_real.entry_output_k1_nil_k	.subcode
ibio.prim.unit	.gvar
gsdl.cgs.file.t.out	.cogvar
env	.fv	gsdl.cgs.typeenv.t
cut0.0	.fv	gsdl.cgs.file.t
cut1.0	.karg	list.prim.u	gsdl.cgs.file.t
	.analyze	cut1.0	:	nil
		.case	:
cut1.0.0		.fkarg	0	gsdl.cgs.file.t
cut2		.fkarg	1	list.t	gsdl.cgs.file.t
res			.undefined	gsdl.ags.file.t
			.lift
			.app	res
			.yield	ibio.prim.unit	gsdl.ags.file.t
		.case	nil
			.force	_real.entry_output_k1_nil_k
			.coerce	gsdl.cgs.file.t.out
			.enter	cut0.0

_real.entry_output_k1_nil_k	.forcecont
gsdl.cgs.typeenv.t	.tygvar
gsdl.cgs.file.prim.u	.tygvar
gsdl.cgs.document.t	.tygvar
string.t	.tygvar
gsdl.ags.file.t	.tygvar
either.t	.tygvar	# Temp
_real.entry_output_k1_nil_doc_k	.subcode
either.t.out	.cogvar
gsac.document.compile	.gvar
env	.fv	gsdl.cgs.typeenv.t
f0	.karg	gsdl.cgs.file.prim.u
	.analyze	f0	document
		.case	document
doc		.fkarg	0	gsdl.cgs.document.t
			.force	_real.entry_output_k1_nil_doc_k
			.coerce	either.t.out	string.t	gsdl.ags.file.t
			.app	env	doc
			.enter	gsac.document.compile
	# > :: ibio.prim.t	gsdl.ags.file.t

_real.entry_output_k1_nil_doc_k	.forcecont
either.prim.u	.tygvar
string.t	.tygvar
gsdl.ags.file.t	.tygvar
ibio.prim.t	.tygvar	# Temp
ibio.prim.unit	.gvar
res0	.karg	either.prim.u	string.t	gsdl.ags.file.t
	.analyze	res0	left	right
		.case	left
err		.fkarg	0	string.t
			.undef	ibio.prim.t	gsdl.ags.file.t
		.case	right
res		.fkarg	0	gsdl.ags.file.t
			.lift
			.app	res
			.yield	ibio.prim.unit	gsdl.ags.file.t

# §section Write out §gs{output} on stdout

_real.entry_send.output_c	.expr
ibio.prim.oport	.tygvar
rune.t	.tygvar
gsdl.ags.file.t	.tygvar
ibio.prim.write	.gvar
gsdl.ags.file.print	.gvar
o	.fv	ibio.prim.oport	rune.t
output	.fv	gsdl.ags.file.t
out.s	.apply	gsdl.ags.file.print	|	output
	.lift
	.app	o	out.s
	.yield	ibio.prim.write	rune.t

	.type

_epbodytype	.tyexpr
ibio.prim.m	.tygvar
record.empty	.tygvar
	.tylift
	.tyref	ibio.prim.m	record.empty

_args.parsed.t	.tyexpr
_args.parsed.u	.tygvar
	.tylift
	.tyref	_args.parsed.u

_args.parsed.u	.tyexpr
list.t	.tygvar
ibio.file.name.t	.tygvar
0.ty	.tylet	list.t	ibio.file.name.t
1.ty	.tylet	list.t	ibio.file.name.t
	.typroduct	0	0.ty	1	1.ty

_args.parse_ty	.tyexpr
list.t	.tygvar
string.t	.tygvar
either.t	.tygvar
_args.parsed.t	.tygvar
	.tylift
	.tyfun	list.t	string.t
	.tyref	either.t	string.t	_args.parsed.t

_real.entry_prefix_ty	.tyexpr
_real.entry_prefix_u	.tygvar
	.tylift
	.tyref	_real.entry_prefix_u

_real.entry_prefix_u	.tyexpr
ordered.set.t	.tygvar
gsdl.cgs.symbol.t	.tygvar
bvs_ty	.tylet	ordered.set.t	gsdl.cgs.symbol.t
	.typroduct	bvs	bvs_ty	# 〈 name :: file.name.t; isdir :: bool.t; bvars :: set.t symbol.t; loaded :: set.t file.name.t; prefix :: prefix.t; 〉

_prefix.init_ty	.tyexpr
list.t	.tygvar
_real.entry_prefix_ty	.tygvar
ibio.file.name.t	.tygvar
	.tylift
	.tyfun	list.t	_real.entry_prefix_ty
	.tylift
	.tyfun	list.t	ibio.file.name.t
	.tyref	list.t	_real.entry_prefix_ty

_prefix.load_ty	.tyexpr
list.t	.tygvar
gsdl.cgs.symbol.t	.tygvar
_real.entry_prefix_ty	.tygvar
ibio.prim.t	.tygvar
list.prefix.ty	.tylet	list.t	_real.entry_prefix_ty
	.tylift
	.tyfun	list.t	gsdl.cgs.symbol.t
	.tylift
	.tyfun	list.t	_real.entry_prefix_ty
	.tyref	ibio.prim.t	list.prefix.ty

_prefix.typecheck_ty	.tyexpr
list.t	.tygvar
_real.entry_prefix_ty	.tygvar
either.t	.tygvar
string.t	.tygvar
gsdl.cgs.typeenv.t	.tygvar
	.tylift
	.tyfun	list.t	_real.entry_prefix_ty
	.tyref	either.t	string.t	gsdl.cgs.typeenv.t

	.coercion

_ep.in	.tycoercion
ibio.m	.tygvar
rune.t	.tygvar
record.empty	.tygvar
	.tydefinition ibio.m	rune.t	rune.t	record.empty
