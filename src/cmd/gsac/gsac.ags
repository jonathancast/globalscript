	.document

	.data

	.cast	_real.entry	_ep.in
_real.entry	.closure	_real.entry_c

_args.parse	.closure	_args.parse_c	_args.parse_ty
_args.parsed.empty	.closure	_args.parsed.empty_c	_args.parsed.t
_flag.l	.string	-l

_prefix.init	.closure	_prefix.init_c	_prefix.init_ty

_prefix.load	.closure	_prefix.load_c	_prefix.load_ty

_prefix.load.var	.closure	_prefix.load.var_c	_prefix.load.var_ty

_prefix.load.var_w	.closure	_prefix.load.var_w_c	_prefix.load.var_w_ty
_prefix.load.var_w_false_:_false_false_cgs.scheme.s	.string	cgs-scheme
_prefix.load.var_w_false_:_false_false_ags.s	.string	ags

_bad.file.name	.closure	_bad.file.name_c
_bad.file.name_err_col.sp.s	.string	:\s

_prefix.load.file	.closure	_prefix.load.file_c

_prefix.load.var_w_false_:_true_res_body_files0.f_true_w	.closure	_prefix.load.var_w_false_:_true_res_body_files0.f_true_w_c	_prefix.load.var_w_false_:_true_res_body_files0.f_true_w_ty

_prefix.typecheck	.closure	_prefix.typecheck_c	_prefix.typecheck_ty

	.code

_real.entry_c	.impprog	ibio.prim	ibio
ibio.prim.iport	.tygvar
ibio.prim.oport	.tygvar
rune.t	.tygvar
_real.entry_args_c	.subcode
_real.entry_parsed.args_c	.subcode
_real.entry_prefix.files_c	.subcode
_real.entry_cut.files_c	.subcode
_real.entry_cut_c	.subcode
_real.entry_cut.fvs_c	.subcode
_real.entry_prefix.loaded_c	.subcode
_real.entry_env_c	.subcode
_real.entry_output_c	.subcode
_real.entry_send.output_c	.subcode
i	.larg	ibio.prim.iport	rune.t
o	.larg	ibio.prim.oport	rune.t
eo	.larg	ibio.prim.oport	rune.t
args	.bind	_real.entry_args_c
parsed.args	.bind	_real.entry_parsed.args_c	# §gs{《 §gsinf{List of prefix arguments}, §gsinf{List of CUT arguments}, 》}
prefix.files	.alloc	_real.entry_prefix.files_c
cut.files	.alloc	_real.entry_cut.files_c
cut	.bind	_real.entry_cut_c
cut.fvs	.alloc	_real.entry_cut.fvs_c
prefix.loaded	.bind	_real.entry_prefix.loaded_c
env	.bind	_real.entry_env_c
output	.bind	_real.entry_output_c
	.body	_real.entry_send.output_c

_real.entry_args_c	.expr
ibio.prim.env.args.get	.gvar
	.yield	ibio.prim.env.args.get

# §section Split §gs{as} into (prefix arguments, component under test)

_real.entry_parsed.args_c	.expr
list.t	.tygvar
string.t	.tygvar
_args.parsed.t	.tygvar
_args.parse	.gvar
ibio.from.either.prim	.gvar
args	.fv	list.t	string.t
pa	.apply	_args.parse	|	args
	.app	pa
	.enter	ibio.from.either.prim	_args.parsed.t

# §section §gs{_args.parse}

_args.parse_c	.expr
list.t	.tygvar
string.t	.tygvar
_args.parse_k0	.subcode
list.t.out	.cogvar
as	.larg	list.t	string.t
	.force	_args.parse_k0
	.coerce	list.t.out	string.t
	.enter	as

_args.parse_k0	.forcecont
list.prim.u	.tygvar
string.t	.tygvar
list.t	.tygvar
rune.t	.tygvar
either.t	.tygvar
_args.parsed.t	.tygvar
_args.parse_k1	.subcode
bool.t.out	.cogvar
list.≡	.gvar
rune.≡	.gvar
_flag.l	.gvar
either.unit	.gvar
_args.parsed.empty	.gvar
as0	.karg	list.prim.u	string.t
	.analyze	as0	:	nil
		.case	:
a0		.fkarg	0	string.t
as1		.fkarg	1	list.t	string.t
			.force	_args.parse_k1
			.coerce	bool.t.out
			.app	rune.≡	a0	_flag.l
			.enter	list.≡	rune.t
		.case	nil
			.app	_args.parsed.empty
			.enter	either.unit	string.t	_args.parsed.t

_args.parse_k1	.forcecont
list.t	.tygvar
string.t	.tygvar
bool.prim.u	.tygvar
_args.parsed.t	.tygvar
_args.parse_file_pre_c	.subcode
_args.parse_l.option_k	.subcode
list.t.out	.cogvar
either.map	.gvar
_args.parse	.gvar
a0	.fv	string.t
as1	.fv	list.t	string.t
is.l0	.karg	bool.prim.u
	.analyze	is.l0	false	true
		.case	false
pre			.alloc	_args.parse_file_pre_c
ap0			.apply	_args.parse	|	as1
			.app	pre	ap0
			.enter	either.map	string.t	_args.parsed.t	_args.parsed.t
		.case	true
			.force	_args.parse_l.option_k
			.coerce	list.t.out	string.t
			.enter	as1

_args.parse_file_pre_c	.expr
string.t	.tygvar
_args.parsed.t	.tygvar
_args.parse_file_pre_k	.subcode
a0	.fv	string.t
ap0	.larg	_args.parsed.t
	.force	_args.parse_file_pre_k
	.enter	ap0

_args.parse_file_pre_k	.forcecont
string.t	.tygvar
_args.parsed.u	.tygvar
ibio.file.name.t	.tygvar
list.t	.tygvar	# Temp
list.:	.gvar
ibio.file.name.in	.gvar
a0	.fv	string.t
ap00	.karg	_args.parsed.u
ps	.field	0	ap00
cut1	.field	1	ap00
cut0	.apply	ibio.file.name.in	|	a0
cut	.apply	list.:	ibio.file.name.t	|	cut0	cut1
ap1	.record	0	ps	1	cut
	.lift
	.yield	ap1

# paragraph{§gs{a0} is §sh{-l} flag}
_args.parse_l.option_k	.forcecont
list.prim.u	.tygvar
string.t	.tygvar
list.t	.tygvar
either.t	.tygvar
_args.parsed.t	.tygvar
_args.parse_l.option_pre_c	.subcode
either.map	.gvar
_args.parse	.gvar
as1.0	.karg	list.prim.u	string.t
	.analyze	as1.0	:	nil
		.case	:
a1		.fkarg	0	string.t
as2		.fkarg	1	list.t	string.t
pre			.alloc	_args.parse_l.option_pre_c
ap0			.apply	_args.parse	|	as2
			.app	pre	ap0
			.enter	either.map	string.t	_args.parsed.t	_args.parsed.t
		.case	nil
			.undef	either.t	string.t	_args.parsed.t

# §paragraph{Prepend §gs{a1} to the list}
_args.parse_l.option_pre_c	.expr
string.t	.tygvar
_args.parsed.t	.tygvar
_args.parse_l.option_pre_k	.subcode
a1	.fv	string.t
ap0	.larg	_args.parsed.t
	.force	_args.parse_l.option_pre_k
	.enter	ap0

_args.parse_l.option_pre_k	.forcecont
string.t	.tygvar
_args.parsed.u	.tygvar
_args.parsed.t	.tygvar
list.t	.tygvar
ibio.file.name.t	.tygvar
list.:	.gvar
ibio.file.name.in	.gvar
a1	.fv	string.t
ap00	.karg	_args.parsed.u
ps	.field	0	ap00
cut	.field	1	ap00
fn	.apply	ibio.file.name.in	|	a1
ps1	.apply	list.:	ibio.file.name.t	|	fn	ps
ap1	.record	0	ps1	1	cut
	.lift
	.yield	ap1

_args.parsed.empty_c	.expr
ibio.file.name.t	.tygvar
list.nil	.gvar
ps	.apply	list.nil	ibio.file.name.t
cut	.apply	list.nil	ibio.file.name.t
r	.record	0	ps	1	cut
	.lift
	.yield	r

# §section Read files from §gs{parsed.args} as needed

_real.entry_prefix.files_c	.expr
_args.parsed.t	.tygvar
parsed.args	.fv	_args.parsed.t
fs	.lfield	0	parsed.args
	.enter	fs

_real.entry_cut.files_c	.expr
_args.parsed.t	.tygvar
parsed.args	.fv	_args.parsed.t
fs	.lfield	1	parsed.args
	.enter	fs

_real.entry_cut_c	.expr
ibio.prim.oport	.tygvar
rune.t	.tygvar
list.t	.tygvar
ibio.file.name.t	.tygvar
gsdl.cgs.file.t	.tygvar
ibio.mapM.prim	.gvar
gsdl.cgs.file.read	.gvar
eo	.fv	ibio.prim.oport	rune.t
cut.files	.fv	list.t	ibio.file.name.t
f	.apply	gsdl.cgs.file.read	|	eo
	.app	f	cut.files
	.enter	ibio.mapM.prim	ibio.file.name.t	gsdl.cgs.file.t

_real.entry_cut.fvs_c	.expr
list.t	.tygvar
gsdl.cgs.file.t	.tygvar
gsdl.cgs.symbol.t	.tygvar
ordered.set.t	.tygvar
set.symbol.ty	.tylet	ordered.set.t	gsdl.cgs.symbol.t
ordered.set.tolist	.gvar
gsdl.cgs.symbol.compare	.gvar
list.foldr	.gvar
ordered.set.union	.gvar
ordered.set.empty	.gvar
list.map	.gvar
gsdl.cgs.file.freevars	.gvar
cut	.fv	list.t	gsdl.cgs.file.t
fvs1	.apply	list.map	gsdl.cgs.file.t	set.symbol.ty	|	gsdl.cgs.file.freevars	cut
union	.apply	ordered.set.union	gsdl.cgs.symbol.t	|	gsdl.cgs.symbol.compare
empty	.apply	ordered.set.empty	gsdl.cgs.symbol.t
fvs	.apply	list.foldr	set.symbol.ty	set.symbol.ty	|	union	empty	fvs1
	.app	gsdl.cgs.symbol.compare	fvs
	.enter	ordered.set.tolist	gsdl.cgs.symbol.t

# §section Load those files depended on by the CUT

# ‘CUT’ = ‘component under translation’; ‘component’ = ‘strongly-connected component of the dependency graph’

_real.entry_prefix.loaded_c	.impprog	ibio.prim	ibio
ibio.prim.oport	.tygvar
rune.t	.tygvar
list.t	.tygvar
gsdl.cgs.symbol.t	.tygvar
ibio.file.name.t	.tygvar
_real.entry_prefix.loaded_init_c	.subcode
_real.entry_prefix.loaded_body_c	.subcode
eo	.fv	ibio.prim.oport	rune.t
prefix.files	.fv	list.t	ibio.file.name.t
cut.fvs	.fv	list.t	gsdl.cgs.symbol.t
init	.bind	_real.entry_prefix.loaded_init_c
	.body	_real.entry_prefix.loaded_body_c

_real.entry_prefix.loaded_init_c	.expr
list.t	.tygvar
ibio.file.name.t	.tygvar
_real.entry_prefix_ty	.tygvar
_prefix.init	.gvar
list.nil	.gvar
prefix.files	.fv	list.t	ibio.file.name.t
init1	.apply	list.nil	_real.entry_prefix_ty
	.app	init1	prefix.files
	.enter	_prefix.init

_real.entry_prefix.loaded_body_c	.expr
ibio.prim.oport	.tygvar
rune.t	.tygvar
list.t	.tygvar
gsdl.cgs.symbol.t	.tygvar
_real.entry_prefix_ty	.tygvar
_prefix.load	.gvar
eo	.fv	ibio.prim.oport	rune.t
cut.fvs	.fv	list.t	gsdl.cgs.symbol.t
init	.fv	list.t	_real.entry_prefix_ty
	.app	eo	cut.fvs	init
	.enter	_prefix.load

# §gs{_prefix.init 'prn 'files} takes a list of files (as on the command line) §gs{files} and translates to a (reversed) initial prefix, prepended to §gs{prn}.
# We are tail-recursive because we §emph{want} to reverse §gs{files} as we work.
_prefix.init_c	.expr
list.t	.tygvar
_real.entry_prefix_ty	.tygvar
ibio.file.name.t	.tygvar
_prefix.init_k	.subcode
list.t.out	.cogvar
prn	.larg	list.t	_real.entry_prefix_ty
fns	.larg	list.t	ibio.file.name.t
	.force	_prefix.init_k
	.coerce	list.t.out	ibio.file.name.t
	.enter	fns

_prefix.init_k	.forcecont
list.t	.tygvar
_real.entry_prefix_ty	.tygvar
list.prim.u	.tygvar
ibio.file.name.t	.tygvar
list.prefix.ty	.tylet	list.t	_real.entry_prefix_ty
_prefix.init_:_body_c	.subcode
ibio.prim.unit	.gvar
prn	.fv	list.t	_real.entry_prefix_ty
fns0	.karg	list.prim.u	ibio.file.name.t
	.analyze	fns0	:	nil
		.case	:
fn0		.fkarg	0	ibio.file.name.t
fns1		.fkarg	1	list.t	ibio.file.name.t
body			.alloc	_prefix.init_:_body_c
			.enter	body
		.case	nil
			.lift
			.app	prn
			.yield	ibio.prim.unit	list.prefix.ty

_prefix.init_:_body_c	.impprog	ibio.prim	ibio
list.t	.tygvar
_real.entry_prefix_ty	.tygvar
ibio.file.name.t	.tygvar
gsdl.cgs.symbol.t	.tygvar
_prefix.init_:_body_isd_c	.subcode
_prefix.init_:_body_body_c	.subcode
prn	.fv	list.t	_real.entry_prefix_ty
fn0	.fv	ibio.file.name.t
fns1	.fv	list.t	ibio.file.name.t
isd	.bind	_prefix.init_:_body_isd_c
	.body	_prefix.init_:_body_body_c

_prefix.init_:_body_isd_c	.expr
ibio.file.name.t	.tygvar
ibio.file.isdir	.gvar
fn0	.fv	ibio.file.name.t
	.app	fn0
	.enter	ibio.file.isdir

_prefix.init_:_body_body_c	.expr
list.t	.tygvar
_real.entry_prefix_ty	.tygvar
ibio.file.name.t	.tygvar
bool.t	.tygvar
gsdl.cgs.symbol.t	.tygvar
_prefix.init	.gvar
list.:	.gvar
ordered.set.empty	.gvar
prn	.fv	list.t	_real.entry_prefix_ty
fn0	.fv	ibio.file.name.t
fns1	.fv	list.t	ibio.file.name.t
isd	.fv	bool.t
empty.syms	.apply	ordered.set.empty	gsdl.cgs.symbol.t
empty.files	.apply	ordered.set.empty	ibio.file.name.t
pr0	.lrecord	bvs	empty.syms	filename	fn0	files.loaded	empty.files	isdir	isd
prn1	.apply	list.:	_real.entry_prefix_ty	|	pr0	prn
	.app	prn1	fns1
	.enter	_prefix.init

_prefix.load_c	.expr
ibio.prim.oport	.tygvar
rune.t	.tygvar
list.t	.tygvar
gsdl.cgs.symbol.t	.tygvar
_real.entry_prefix_ty	.tygvar
_prefix.load_k	.subcode
list.t.out	.cogvar
eo	.larg	ibio.prim.oport	rune.t
vs	.larg	list.t	gsdl.cgs.symbol.t
prn	.larg	list.t	_real.entry_prefix_ty
	.force	_prefix.load_k
	.coerce	list.t.out	gsdl.cgs.symbol.t
	.enter	vs

_prefix.load_k	.forcecont
ibio.prim.oport	.tygvar
rune.t	.tygvar
list.t	.tygvar
_real.entry_prefix_ty	.tygvar
list.prim.u	.tygvar
gsdl.cgs.symbol.t	.tygvar
list.prefix.ty	.tylet	list.t	_real.entry_prefix_ty
_prefix.load_body_c	.subcode
ibio.prim.unit	.gvar
eo	.fv	ibio.prim.oport	rune.t
prn	.fv	list.t	_real.entry_prefix_ty
vs0	.karg	list.prim.u	gsdl.cgs.symbol.t
	.analyze	vs0	:	nil
		.case	:
v0		.fkarg	0	gsdl.cgs.symbol.t
vs1		.fkarg	1	list.t	gsdl.cgs.symbol.t
body			.alloc	_prefix.load_body_c
			.enter	body
		.case	nil
			.lift
			.app	prn
			.yield	ibio.prim.unit	list.prefix.ty

_prefix.load_body_c	.impprog	ibio.prim	ibio
ibio.prim.oport	.tygvar
rune.t	.tygvar
list.t	.tygvar
_real.entry_prefix_ty	.tygvar
gsdl.cgs.symbol.t	.tygvar
_prefix.load_body_prn1_c	.subcode
_prefix.load_body_body_c	.subcode
eo	.fv	ibio.prim.oport	rune.t
prn	.fv	list.t	_real.entry_prefix_ty
v0	.fv	gsdl.cgs.symbol.t
vs1	.fv	list.t	gsdl.cgs.symbol.t
prn1	.bind	_prefix.load_body_prn1_c
	.body	_prefix.load_body_body_c

_prefix.load_body_prn1_c	.expr
ibio.prim.oport	.tygvar
rune.t	.tygvar
list.t	.tygvar
_real.entry_prefix_ty	.tygvar
gsdl.cgs.symbol.t	.tygvar
_prefix.load.var	.gvar
eo	.fv	ibio.prim.oport	rune.t
prn	.fv	list.t	_real.entry_prefix_ty
v0	.fv	gsdl.cgs.symbol.t
	.app	eo	v0	prn
	.enter	_prefix.load.var

# §paragraph{Main loop: given §gs{v} and §gs{prn} (stack of prefixen), read in files and their dependencies until §gs{v} has been loaded}
_prefix.load.var_c	.expr
ibio.prim.oport	.tygvar
rune.t	.tygvar
gsdl.cgs.symbol.t	.tygvar
list.t	.tygvar
_real.entry_prefix_ty	.tygvar
list.prefix.ty	.tylet	list.t	_real.entry_prefix_ty	# Temp
_prefix.load.var_k	.subcode
list.t.out	.cogvar
eo	.larg	ibio.prim.oport	rune.t
v	.larg	gsdl.cgs.symbol.t
prn	.larg	list.t	_real.entry_prefix_ty
	.force	_prefix.load.var_k
	.coerce	list.t.out	_real.entry_prefix_ty
	.enter	prn

# §paragraph{§gs{_prefix.load.var}: branch on prefix list: empty or non-empty?}
_prefix.load.var_k	.forcecont
ibio.prim.oport	.tygvar
rune.t	.tygvar
gsdl.cgs.symbol.t	.tygvar
list.prim.u	.tygvar
_real.entry_prefix_ty	.tygvar
list.t	.tygvar
_prefix.load.var_w_file_ty	.tygvar
list.prefix.ty	.tylet	list.t	_real.entry_prefix_ty
_prefix.load.var_w	.gvar
list.singleton	.gvar
gsdl.cgs.symbol.components.get	.gvar
ibio.prim.unit	.gvar
list.nil	.gvar
eo	.fv	ibio.prim.oport	rune.t
v	.fv	gsdl.cgs.symbol.t
prn0	.karg	list.prim.u	_real.entry_prefix_ty
	.analyze	prn0	:	nil
		.case	:
pr0		.fkarg	0	_real.entry_prefix_ty
prn1		.fkarg	1	list.t	_real.entry_prefix_ty
fn			.lfield	filename	pr0
isd			.lfield	isdir	pr0
relv			.apply	gsdl.cgs.symbol.components.get	|	v
file			.lrecord	filename	fn	isdir	isd	relv	relv
files			.apply	list.singleton	_prefix.load.var_w_file_ty	|	file
			.app	eo	v	files	pr0	prn1
			.enter	_prefix.load.var_w
		.case	nil
nil			.apply	list.nil	_real.entry_prefix_ty
			.lift
			.app	nil
			.yield	ibio.prim.unit	list.prefix.ty

# §paragraph{Secondary loop}
# Given §gs{v}, a variable,
# §gs{files}, a list of files to examine,
# §gs{pr0}, the prefix we're reading from, and
# §gs{prn1}, the context of prefixen beneath the current one, read files until §gs{v} is loaded or §gs{files} is exhausted;
# in the event that §gs{files} is exhausted before §gs{v} is found, loop on §gs{prn1} (and etc.).
_prefix.load.var_w_c	.expr
ibio.prim.oport	.tygvar
rune.t	.tygvar
gsdl.cgs.symbol.t	.tygvar
list.t	.tygvar
gsdl.cgs.syntax.var.component.t	.tygvar
_prefix.load.var_w_file_ty	.tygvar
_real.entry_prefix_ty	.tygvar
_prefix.load.var_w_k	.subcode
bool.t.out	.cogvar
ordered.set.elem	.gvar
gsdl.cgs.symbol.compare	.gvar
eo	.larg	ibio.prim.oport	rune.t
v	.larg	gsdl.cgs.symbol.t
files	.larg	list.t	_prefix.load.var_w_file_ty
pr0	.larg	_real.entry_prefix_ty
prn1	.larg	list.t	_real.entry_prefix_ty
bvs	.lfield	bvs	pr0
	.force	_prefix.load.var_w_k
	.coerce	bool.t.out
	.app	gsdl.cgs.symbol.compare	v	bvs
	.enter	ordered.set.elem	gsdl.cgs.symbol.t

# §paragraph{Branch on whether the variable has been loaded}
_prefix.load.var_w_k	.forcecont
ibio.prim.oport	.tygvar
rune.t	.tygvar
gsdl.cgs.symbol.t	.tygvar
_real.entry_prefix_ty	.tygvar
list.t	.tygvar
_prefix.load.var_w_file_ty	.tygvar
bool.prim.u	.tygvar
ibio.prim.t	.tygvar	# Temp
list.prefix.ty	.tylet	list.t	_real.entry_prefix_ty	# Temp
_prefix.load.var_w_false_k	.subcode
list.t.out	.cogvar
eo	.fv	ibio.prim.oport	rune.t
v	.fv	gsdl.cgs.symbol.t
pr0	.fv	_real.entry_prefix_ty
prn1	.fv	list.t	_real.entry_prefix_ty
files	.fv	list.t	_prefix.load.var_w_file_ty
b0	.karg	bool.prim.u	# Is §gs{v} already loaded?
	.analyze	b0	false	true
		.case	false
			# OK, so now we need a list of §gs{〈 filename; isdir; relname; 〉} to load, like such:
			.force	_prefix.load.var_w_false_k
			.coerce	list.t.out	_prefix.load.var_w_file_ty
			.enter	files
		.case	true
			.undef	ibio.prim.t	list.prefix.ty

# §paragraph{Variable has not been loaded; branch on whether §gs{files} has been exhausted or not}
_prefix.load.var_w_false_k	.forcecont
ibio.prim.oport	.tygvar
rune.t	.tygvar
gsdl.cgs.symbol.t	.tygvar
_real.entry_prefix_ty	.tygvar
list.t	.tygvar
list.prim.u	.tygvar
_prefix.load.var_w_file_ty	.tygvar
ibio.prim.t	.tygvar	# Temp
list.prefix.ty	.tylet	list.t	_real.entry_prefix_ty	# Temp
_prefix.load.var_w_false_:_k	.subcode
_prefix.load.var_w_false_nil_res_c	.subcode
bool.t.out	.cogvar
list.t.out	.cogvar
eo	.fv	ibio.prim.oport	rune.t
v	.fv	gsdl.cgs.symbol.t
pr0	.fv	_real.entry_prefix_ty
prn1	.fv	list.t	_real.entry_prefix_ty
files0	.karg	list.prim.u	_prefix.load.var_w_file_ty
	.analyze	files0	:	nil
		.case	:
file0		.fkarg	0	_prefix.load.var_w_file_ty
files1		.fkarg	1	list.t	_prefix.load.var_w_file_ty
isd			.lfield	isdir	file0
			.force	_prefix.load.var_w_false_:_k
			.coerce	bool.t.out
			.enter	isd
		.case	nil
res			.alloc	_prefix.load.var_w_false_nil_res_c
			.enter	res

# §paragraph{§gs{files} has not been exhausted; branch on whether the next file is a directory}
_prefix.load.var_w_false_:_k	.forcecont
ibio.prim.oport	.tygvar
rune.t	.tygvar
gsdl.cgs.symbol.t	.tygvar
_real.entry_prefix_ty	.tygvar
_prefix.load.var_w_file_ty	.tygvar
list.t	.tygvar
bool.prim.u	.tygvar
ibio.file.name.t	.tygvar
_prefix.load.var_w_false_:_false_k	.subcode
_prefix.load.var_w_false_:_true_res_c	.subcode
bool.t.out	.cogvar
ordered.set.elem	.gvar
ibio.file.name.compare	.gvar
eo	.fv	ibio.prim.oport	rune.t
v	.fv	gsdl.cgs.symbol.t
pr0	.fv	_real.entry_prefix_ty
prn1	.fv	list.t	_real.entry_prefix_ty
file0	.fv	_prefix.load.var_w_file_ty
files1	.fv	list.t	_prefix.load.var_w_file_ty
b0	.karg	bool.prim.u	# Is this file a directory?
	.analyze	b0	false	true
		.case	false
fn			.lfield	filename	file0
loaded			.lfield	files.loaded	pr0
			.force	_prefix.load.var_w_false_:_false_k
			.coerce	bool.t.out
			.app	ibio.file.name.compare	fn	loaded
			.enter	ordered.set.elem	ibio.file.name.t
		.case	true
res			.alloc	_prefix.load.var_w_false_:_true_res_c
			.enter	res

# §paragraph{Processing a regular file; branch on whether the file has been loaded yet}
_prefix.load.var_w_false_:_false_k	.forcecont
ibio.prim.oport	.tygvar
rune.t	.tygvar
gsdl.cgs.symbol.t	.tygvar
list.t	.tygvar
_prefix.load.var_w_file_ty	.tygvar
ibio.file.name.t	.tygvar
bool.prim.u	.tygvar
string.t	.tygvar
ibio.prim.t	.tygvar	# Temp
list.t	.tygvar	 # Temp
_real.entry_prefix_ty	.tygvar	 # Temp
list.prefix.ty	.tylet	list.t	_real.entry_prefix_ty	# Temp
_prefix.load.var_w_false_:_false_false_k	.subcode
list.t.out	.cogvar
list.reverse	.gvar
ibio.file.name.components.get	.gvar
eo	.fv	ibio.prim.oport	rune.t
v	.fv	gsdl.cgs.symbol.t
pr0	.fv	_real.entry_prefix_ty
prn1	.fv	list.t	_real.entry_prefix_ty
files1	.fv	list.t	_prefix.load.var_w_file_ty
fn	.fv	ibio.file.name.t
b0	.karg	bool.prim.u	# Has this file been loaded yet?
	.analyze	b0	false	true
		.case	false
cs			.apply	ibio.file.name.components.get	|	fn
exts			.lfield	exts	cs
txes			.apply	list.reverse	string.t	|	exts
			.force	_prefix.load.var_w_false_:_false_false_k
			.coerce	list.t.out	string.t
			.enter	txes
		.case	true
			.undef	ibio.prim.t	list.prefix.ty

# §paragraph{Get the last extension to check if we should load the file}
# File has not been loaded; check the extension and make sure we should load it.
# Default is don't load, §emph{and} complain about the file (bad file in prefix directory)
# To load the file, check out §ags{_prefix.load.var_w_false_:_false_false_res_c}
_prefix.load.var_w_false_:_false_false_k	.forcecont
ibio.prim.oport	.tygvar
rune.t	.tygvar
gsdl.cgs.symbol.t	.tygvar
_real.entry_prefix_ty	.tygvar
list.t	.tygvar
_prefix.load.var_w_file_ty	.tygvar
ibio.file.name.t	.tygvar
list.prim.u	.tygvar
string.t	.tygvar
_prefix.load.var_w_false_:_false_false_cgs.scheme_k	.subcode
bool.t.out	.cogvar
string.≡	.gvar
_prefix.load.var_w_false_:_false_false_cgs.scheme.s	.gvar
_bad.file.name	.gvar
eo	.fv	ibio.prim.oport	rune.t
v	.fv	gsdl.cgs.symbol.t
pr0	.fv	_real.entry_prefix_ty
prn1	.fv	list.t	_real.entry_prefix_ty
files1	.fv	list.t	_prefix.load.var_w_file_ty
fn	.fv	ibio.file.name.t
txes0	.karg	list.prim.u	string.t
	.analyze	txes0	:	nil
		.case	:
txe0		.fkarg	0	string.t
txes1		.fkarg	1	list.t	string.t
			# OK, now we have §gs{txe0}; we need to see what extension that is
			.force	_prefix.load.var_w_false_:_false_false_cgs.scheme_k
			.coerce	bool.t.out
			.app	txe0	_prefix.load.var_w_false_:_false_false_cgs.scheme.s
			.enter	string.≡
		.case	nil
			.app	eo	fn
			.enter	_bad.file.name

_prefix.load.var_w_false_:_false_false_cgs.scheme_k	.forcecont
ibio.prim.oport	.tygvar
rune.t	.tygvar
gsdl.cgs.symbol.t	.tygvar
_real.entry_prefix_ty	.tygvar
list.t	.tygvar
_prefix.load.var_w_file_ty	.tygvar
ibio.file.name.t	.tygvar
string.t	.tygvar
bool.prim.u	.tygvar
ordered.set.t	.tygvar	# Temp
_prefix.load.var_w_false_:_false_false_ags_k	.subcode
bool.t.out	.cogvar
string.≡	.gvar
_prefix.load.var_w_false_:_false_false_ags.s	.gvar
_prefix.load.var_w	.gvar
ordered.set.insert	.gvar
ibio.file.name.compare	.gvar
eo	.fv	ibio.prim.oport	rune.t
v	.fv	gsdl.cgs.symbol.t
pr0	.fv	_real.entry_prefix_ty
prn1	.fv	list.t	_real.entry_prefix_ty
files1	.fv	list.t	_prefix.load.var_w_file_ty
fn	.fv	ibio.file.name.t
txe0	.fv	string.t
b0	.karg	bool.prim.u	# Is this a §sh{.cgs-scheme} file?
	.analyze	b0	false	true
		.case	false
			.force	_prefix.load.var_w_false_:_false_false_ags_k
			.coerce	bool.t.out
			.app	txe0	_prefix.load.var_w_false_:_false_false_ags.s
			.enter	string.≡
		.case	true
bvs			.lfield	bvs	pr0
filename			.lfield	filename	pr0
files.loaded			.lfield	files.loaded	pr0
files.loaded.1			.apply	ordered.set.insert	ibio.file.name.t	|	ibio.file.name.compare	fn	files.loaded
isdir			.lfield	isdir	pr0
pr0.1			.lrecord	bvs	bvs	filename	filename	files.loaded	files.loaded.1	isdir	isdir
			.app	eo	v	files1	pr0.1	prn1
			.enter	_prefix.load.var_w

_prefix.load.var_w_false_:_false_false_ags_k	.forcecont
ibio.prim.oport	.tygvar
rune.t	.tygvar
gsdl.cgs.symbol.t	.tygvar
_real.entry_prefix_ty	.tygvar
list.t	.tygvar
_prefix.load.var_w_file_ty	.tygvar
ibio.file.name.t	.tygvar
bool.prim.u	.tygvar
_bad.file.name	.gvar
_prefix.load.file	.gvar
bool.true	.gvar
eo	.fv	ibio.prim.oport	rune.t
v	.fv	gsdl.cgs.symbol.t
pr0	.fv	_real.entry_prefix_ty
prn1	.fv	list.t	_real.entry_prefix_ty
files1	.fv	list.t	_prefix.load.var_w_file_ty
fn	.fv	ibio.file.name.t
b0	.karg	bool.prim.u	# Is this a §sh{.ags} file?
	.analyze	b0	false	true
		.case	false
			.app	eo	fn
			.enter	_bad.file.name
		.case	true
			.app	eo	v	pr0	prn1	files1	fn	bool.true
			.enter	_prefix.load.file

# §paragraph{Compain about §gs{fn}, which has a bad extension to be loaded (§gs{ext})}
_bad.file.name_c	.impprog	ibio.prim	ibio
ibio.prim.oport	.tygvar
rune.t	.tygvar
ibio.file.name.t	.tygvar
_bad.file.name_err_c	.subcode
_bad.file.name_body_c	.subcode
eo	.larg	ibio.prim.oport	rune.t
fn	.larg	ibio.file.name.t
r	.bind	_bad.file.name_err_c
	.body	_bad.file.name_body_c

# §paragraph{Print warning about skipping file}
_bad.file.name_err_c	.expr
ibio.prim.oport	.tygvar
rune.t	.tygvar
ibio.file.name.t	.tygvar
list.t	.tygvar	# Temp
ibio.prim.write	.gvar
list.<>	.gvar
ibio.file.name.out	.gvar
_bad.file.name_err_col.sp.s	.gvar
eo	.fv	ibio.prim.oport	rune.t
fn	.fv	ibio.file.name.t
fn.s	.apply	ibio.file.name.out	|	fn
s2	.undefined	list.t	rune.t
s1	.apply	list.<>	rune.t	|	_bad.file.name_err_col.sp.s	s2
s	.apply	list.<>	rune.t	|	fn.s	s1
	.app	eo	s
	.yield	ibio.prim.write	rune.t

# §paragraph{Loop with remaining files} (this means this function becomes recursive)
_bad.file.name_body_c	.expr
ibio.prim.t	.tygvar	# Temp
list.t	.tygvar	 # Temp
_real.entry_prefix_ty	.tygvar	 # Temp
list.prefix.ty	.tylet	list.t	_real.entry_prefix_ty	# Temp
	.undef	ibio.prim.t	list.prefix.ty

# §paragraph{File has not been loaded yet, and has an appropriate extension to be loaded}
_prefix.load.file_c	.impprog	ibio.prim	ibio
ibio.prim.oport	.tygvar
rune.t	.tygvar
gsdl.cgs.symbol.t	.tygvar
_real.entry_prefix_ty	.tygvar
list.t	.tygvar
_prefix.load.var_w_file_ty	.tygvar
ibio.file.name.t	.tygvar
bool.t	.tygvar
_prefix.load.file_file.parsed_c	.subcode
_prefix.load.file_pr0.1_c	.subcode
_prefix.load.file_body_c	.subcode
eo	.larg	ibio.prim.oport	rune.t
v	.larg	gsdl.cgs.symbol.t
pr0	.larg	_real.entry_prefix_ty
prn1	.larg	list.t	_real.entry_prefix_ty
files1	.larg	list.t	_prefix.load.var_w_file_ty
fn	.larg	ibio.file.name.t
isags	.larg	bool.t
file.parsed	.bind	_prefix.load.file_file.parsed_c
pr0.1	.alloc	_prefix.load.file_pr0.1_c
	.body	_prefix.load.file_body_c

# §paragraph{Read in the actual file}
_prefix.load.file_file.parsed_c	.expr
ibio.prim.oport	.tygvar
rune.t	.tygvar
ibio.file.name.t	.tygvar
bool.t	.tygvar
gsac.input.prefix.file.load	.gvar
eo	.fv	ibio.prim.oport	rune.t
fn	.fv	ibio.file.name.t
isags	.fv	bool.t
	.app	eo	isags	fn
	.enter	gsac.input.prefix.file.load

# §paragraph{Add the file to §gs{pr0}}
_prefix.load.file_pr0.1_c	.expr
gsac.input.prefix.t	.tygvar
_real.entry_prefix_ty	.tygvar
gsdl.cgs.symbol.t	.tygvar	# Temp
ordered.set.t	.tygvar 	# Temp
ibio.file.name.t	.tygvar	# Temp
ordered.set.union	.gvar
gsdl.cgs.symbol.compare	.gvar
gsac.input.prefix.boundvars	.gvar
pr0	.fv	_real.entry_prefix_ty
file.parsed	.fv	gsac.input.prefix.t
pr0.bvs	.lfield	bvs	pr0
file.parsed.bvs	.apply	gsac.input.prefix.boundvars	|	file.parsed
bvs1	.apply	ordered.set.union	gsdl.cgs.symbol.t	|	gsdl.cgs.symbol.compare	pr0.bvs	file.parsed.bvs
pr0.filename	.lfield	filename	pr0
pr0.files.loaded	.lfield	files.loaded	pr0
files.loaded.1	.undefined	ordered.set.t	ibio.file.name.t	# Add the file to §gs{#files.loaded pr0}
id	.lfield	isdir	pr0
r	.record	bvs	bvs1	filename	pr0.filename	files.loaded	files.loaded.1	isdir	id	# Add the file's contents to the prefix in pr0
	.lift
	.yield	r

# §paragraph{Loop with the updated §gs{pr0.1} and the remaining files}
_prefix.load.file_body_c	.expr
ibio.prim.oport	.tygvar
rune.t	.tygvar
gsdl.cgs.symbol.t	.tygvar
list.t	.tygvar
_prefix.load.var_w_file_ty	.tygvar
_real.entry_prefix_ty	.tygvar
_prefix.load.var_w	.gvar
eo	.fv	ibio.prim.oport	rune.t
v	.fv	gsdl.cgs.symbol.t
prn1	.fv	list.t	_real.entry_prefix_ty
files1	.fv	list.t	_prefix.load.var_w_file_ty
pr0.1	.fv	_real.entry_prefix_ty
	.app	eo	v	files1	pr0.1	prn1
	.enter	_prefix.load.var_w

# §paragraph{File is a directory; scan it for entries that look like they match §gs{v} and push those onto the front of §gs{files}}
_prefix.load.var_w_false_:_true_res_c	.impprog	ibio.prim	ibio
ibio.prim.oport	.tygvar
rune.t	.tygvar
gsdl.cgs.symbol.t	.tygvar
_real.entry_prefix_ty	.tygvar
_prefix.load.var_w_file_ty	.tygvar
list.t	.tygvar
_prefix.load.var_w_false_:_true_res_if_c	.subcode
_prefix.load.var_w_false_:_true_res_dirs_c	.subcode
_prefix.load.var_w_false_:_true_res_body_c	.subcode
eo	.fv	ibio.prim.oport	rune.t
v	.fv	gsdl.cgs.symbol.t
pr0	.fv	_real.entry_prefix_ty
prn1	.fv	list.t	_real.entry_prefix_ty
file0	.fv	_prefix.load.var_w_file_ty
files1	.fv	list.t	_prefix.load.var_w_file_ty
if	.bind	_prefix.load.var_w_false_:_true_res_if_c
dirs	.bind	_prefix.load.var_w_false_:_true_res_dirs_c
	.body	_prefix.load.var_w_false_:_true_res_body_c

# §paragraph{Open directory}
_prefix.load.var_w_false_:_true_res_if_c	.expr
_prefix.load.var_w_file_ty	.tygvar
ibio.dir.t	.tygvar
ibio.file.read.open.prim	.gvar
ibio.dir.external.io	.gvar
file0	.fv	_prefix.load.var_w_file_ty
fn	.lfield	filename	file0
	.app	ibio.dir.external.io	fn
	.enter	ibio.file.read.open.prim	ibio.dir.t

# §paragraph{Read directory contents}
_prefix.load.var_w_false_:_true_res_dirs_c	.expr
ibio.prim.iport	.tygvar
ibio.dir.t	.tygvar
list.t	.tygvar
list.dir.ty	.tylet	list.t	ibio.dir.t
ibio.lex.receive	.gvar
ibio.lex.receiver.many	.gvar
ibio.lex.receiver.symbol	.gvar
if	.efv	ibio.prim.iport	ibio.dir.t
sym	.apply	ibio.lex.receiver.symbol	ibio.dir.t
ms	.apply	ibio.lex.receiver.many	ibio.dir.t	ibio.dir.t	|	sym
	.app	ms	if
	.enter	ibio.lex.receive	ibio.dir.t	list.dir.ty

# §paragraph{Recurse with directory entries pushed onto §gs{files}}
_prefix.load.var_w_false_:_true_res_body_c	.expr
ibio.prim.oport	.tygvar
rune.t	.tygvar
gsdl.cgs.symbol.t	.tygvar
_real.entry_prefix_ty	.tygvar
list.t	.tygvar
_prefix.load.var_w_file_ty	.tygvar
ibio.dir.t	.tygvar
_prefix.load.var_w_false_:_true_res_body_files0.f_c	.subcode
_prefix.load.var_w	.gvar
list.<>	.gvar
list.filterMap	.gvar
eo	.fv	ibio.prim.oport	rune.t
v	.fv	gsdl.cgs.symbol.t
pr0	.fv	_real.entry_prefix_ty
prn1	.fv	list.t	_real.entry_prefix_ty
file0	.fv	_prefix.load.var_w_file_ty
files1	.fv	list.t	_prefix.load.var_w_file_ty
dirs	.fv	list.t	ibio.dir.t	# The files in §gs{file0}
files0.f	.alloc	_prefix.load.var_w_false_:_true_res_body_files0.f_c
files0	.apply	list.filterMap	ibio.dir.t	_prefix.load.var_w_file_ty	|	files0.f	dirs
files2	.apply	list.<>	_prefix.load.var_w_file_ty	|	files0	files1
	.app	eo	v	files2	pr0	prn1
	.enter	_prefix.load.var_w

# §paragraph{Filter §gs{dir} to see whether it looks like it matches §gs{v}}
# §gs{files0} contains the key information, which is: what components of §gs{v} are un-matched to this point?
_prefix.load.var_w_false_:_true_res_body_files0.f_c	.expr
_prefix.load.var_w_file_ty	.tygvar
ibio.dir.t	.tygvar
_prefix.load.var_w_false_:_true_res_body_files0.f_k	.subcode
bool.t.out	.cogvar
file0	.fv	_prefix.load.var_w_file_ty
dir	.larg	ibio.dir.t
isd	.lfield	mode.directory	dir
	.force	_prefix.load.var_w_false_:_true_res_body_files0.f_k
	.coerce	bool.t.out
	.enter	isd

# §paragraph{Branch on whether §gs{dir} is a directory}
# If directory: match entire contents but require more components in §gs{v} after those we match
# If file: match root of file (before §emph{first} extension, if any) against first (and possibly last) component;
#     ignore other components of file name & variable name
_prefix.load.var_w_false_:_true_res_body_files0.f_k	.forcecont
_prefix.load.var_w_file_ty	.tygvar
ibio.dir.t	.tygvar
bool.prim.u	.tygvar
gsdl.cgs.syntax.var.component.t	.tygvar
string.t	.tygvar	# Temp
list.t	.tygvar	# Temp
_prefix.load.var_w_false_:_true_res_body_files0.f_false_k	.subcode
list.t.out	.cogvar
_prefix.load.var_w_false_:_true_res_body_files0.f_true_w	.gvar
list.:	.gvar
ibio.file.name.components.get	.gvar
file0	.fv	_prefix.load.var_w_file_ty
dir	.fv	ibio.dir.t
isd0	.karg	bool.prim.u
relv	.lfield	relv	file0
	.analyze	isd0	false	true
		.case	false
			.force	_prefix.load.var_w_false_:_true_res_body_files0.f_false_k
			.coerce	list.t.out	gsdl.cgs.syntax.var.component.t
			.enter	relv
		.case	true
fn			.lfield	name	dir
fn.comps			.apply	ibio.file.name.components.get	|	fn
fn.root			.lfield	root	fn.comps
fn.exts			.undefined	list.t	string.t
cs			.apply	list.:	string.t	|	fn.root	fn.exts
			.app	relv	cs
			.enter	_prefix.load.var_w_false_:_true_res_body_files0.f_true_w

# §paragraph{File is not directory; check if file matches}
_prefix.load.var_w_false_:_true_res_body_files0.f_false_k	.forcecont
_prefix.load.var_w_file_ty	.tygvar
ibio.dir.t	.tygvar
list.prim.u	.tygvar
gsdl.cgs.syntax.var.component.t	.tygvar
list.t	.tygvar
maybe.t	.tygvar	# Temp
_prefix.load.var_w_false_:_true_res_body_files0.f_false_:_k	.subcode
bool.t.out	.cogvar
string.≡	.gvar
ibio.file.name.components.get	.gvar
gsdl.cgs.syntax.var.component.print	.gvar
file0	.fv	_prefix.load.var_w_file_ty
dir	.fv	ibio.dir.t
relv0	.karg	list.prim.u	gsdl.cgs.syntax.var.component.t
	.analyze	relv0	:	nil
		.case	:
c0		.fkarg	0	gsdl.cgs.syntax.var.component.t
relv1		.fkarg	1	list.t	gsdl.cgs.syntax.var.component.t
fn			.lfield	name	dir
fn.comps			.apply	ibio.file.name.components.get	|	fn
fn.root			.lfield	root	fn.comps
c0.nm			.apply	gsdl.cgs.syntax.var.component.print	|	c0
			.force	_prefix.load.var_w_false_:_true_res_body_files0.f_false_:_k
			.coerce	bool.t.out
			.app	fn.root	c0.nm
			.enter	string.≡
		.case	nil
			# Can't happen: we must have at least one component left or we wouldn't have gotten to this point
			.undef	maybe.t	_prefix.load.var_w_file_ty

# §paragraph{File is not directory; branch on whether file name matches variable or not}
_prefix.load.var_w_false_:_true_res_body_files0.f_false_:_k	.forcecont
_prefix.load.var_w_file_ty	.tygvar
ibio.file.name.t	.tygvar
list.t	.tygvar
gsdl.cgs.syntax.var.component.t	.tygvar
bool.prim.u	.tygvar
maybe.nothing	.gvar
maybe.just	.gvar
ibio.file.name.</>	.gvar
bool.false	.gvar
file0	.fv	_prefix.load.var_w_file_ty
fn	.fv	ibio.file.name.t
relv1	.fv	list.t	gsdl.cgs.syntax.var.component.t
b0	.karg	bool.prim.u	# Does this file match the identifier?
	.analyze	b0	false	true
		.case	false
			.enter	maybe.nothing	_prefix.load.var_w_file_ty
		.case	true
dirn			.lfield	filename	file0
absfn			.apply	ibio.file.name.</>	|	dirn	fn
file1			.lrecord	filename	absfn	isdir	bool.false	relv	relv1
			.app	file1
			.yield	maybe.just	_prefix.load.var_w_file_ty

# §paragraph{Third loop: check §gs{relv} against §gs{dircs}}
# §gs{dircs} should be a prefix of §gs{relv},
# but we want to work out the remaining components of §gs{relv} so we can scan the contents of this directory on match.
_prefix.load.var_w_false_:_true_res_body_files0.f_true_w_c	.expr
list.t	.tygvar
gsdl.cgs.syntax.var.component.t	.tygvar
string.t	.tygvar
_prefix.load.var_w_false_:_true_res_body_files0.f_true_w_relv.k	.subcode
list.t.out	.cogvar
relv	.larg	list.t	gsdl.cgs.syntax.var.component.t
dircs	.larg	list.t	string.t
	.force	_prefix.load.var_w_false_:_true_res_body_files0.f_true_w_relv.k
	.coerce	list.t.out	gsdl.cgs.syntax.var.component.t
	.enter	relv

# §paragraph{Get head and tail of §gs{relv}}
# If §gs{relv} is empty, fail: even if §gs{dircs} is non-empty, files in this directory can't match this variable anyway
_prefix.load.var_w_false_:_true_res_body_files0.f_true_w_relv.k	.forcecont
list.t	.tygvar
string.t	.tygvar
list.prim.u	.tygvar
gsdl.cgs.syntax.var.component.t	.tygvar
maybe.t	.tygvar	# Temp
_prefix.load.var_w_file_ty	.tygvar	# Temp
_prefix.load.var_w_false_:_true_res_body_files0.f_true_w_:_dircs.k	.subcode
list.t.out	.cogvar
dircs	.fv	list.t	string.t
relv0	.karg	list.prim.u	gsdl.cgs.syntax.var.component.t
	.analyze	relv0	:	nil
		.case	:
vc0		.fkarg	0	gsdl.cgs.syntax.var.component.t
relv1		.fkarg	1	list.t	gsdl.cgs.syntax.var.component.t
			.force	_prefix.load.var_w_false_:_true_res_body_files0.f_true_w_:_dircs.k
			.coerce	list.t.out	string.t
			.enter	dircs
		.case	nil
			.undef	maybe.t	_prefix.load.var_w_file_ty

# §paragraph{Check §gs{dircs}; if it's empty, we're done; otherwise check head & tail against §gs{vc0} and §gs{relv1} respectively}
_prefix.load.var_w_false_:_true_res_body_files0.f_true_w_:_dircs.k	.forcecont
gsdl.cgs.syntax.var.component.t	.tygvar
list.prim.u	.tygvar
string.t	.tygvar
list.t	.tygvar
maybe.t	.tygvar	# Temp
_prefix.load.var_w_file_ty	.tygvar	# Temp
_prefix.load.var_w_false_:_true_res_body_files0.f_true_w_:_dircs_:_k	.subcode
bool.t.out	.cogvar
string.≡	.gvar
gsdl.cgs.syntax.var.component.print	.gvar
vc0	.fv	gsdl.cgs.syntax.var.component.t
dircs0	.karg	list.prim.u	string.t
	.analyze	dircs0	:	nil
		.case	:
dc0		.fkarg	0	string.t
dircs1		.fkarg	1	list.t	string.t
vc0.nm			.apply	gsdl.cgs.syntax.var.component.print	|	vc0
			.force	_prefix.load.var_w_false_:_true_res_body_files0.f_true_w_:_dircs_:_k
			.coerce	bool.t.out
			.app	vc0.nm	dc0
			.enter	string.≡
		.case	nil
			.undef	maybe.t	_prefix.load.var_w_file_ty

# §paragraph{Branch on whether first component of file name and first component of directory match}
_prefix.load.var_w_false_:_true_res_body_files0.f_true_w_:_dircs_:_k	.forcecont
bool.prim.u	.tygvar
_prefix.load.var_w_file_ty	.tygvar
maybe.t	.tygvar	# Temp
maybe.nothing	.gvar
b0	.karg	bool.prim.u	# Components match?
	.analyze	b0	false	true
		.case	false
			.enter	maybe.nothing	_prefix.load.var_w_file_ty
		.case	true
			.undef	maybe.t	_prefix.load.var_w_file_ty

# §paragraph{§gs{files} is exhausted: recurse on §gs{prn1}, then put §gs{pr0} back on top of the returned stack}
_prefix.load.var_w_false_nil_res_c	.impprog	ibio.prim	ibio
ibio.prim.oport	.tygvar
rune.t	.tygvar
gsdl.cgs.symbol.t	.tygvar
_real.entry_prefix_ty	.tygvar
list.t	.tygvar
_prefix.load.var_w_false_nil_res_prn2_c	.subcode
_prefix.load.var_w_false_nil_res_body_c	.subcode
eo	.fv	ibio.prim.oport	rune.t
v	.fv	gsdl.cgs.symbol.t
pr0	.fv	_real.entry_prefix_ty
prn1	.fv	list.t	_real.entry_prefix_ty
prn2	.bind	_prefix.load.var_w_false_nil_res_prn2_c
	.body	_prefix.load.var_w_false_nil_res_body_c

# §paragraph{Recurse on §gs{prn1}, returning the tail of §gs{_prefix.load.var_w}'s result}
_prefix.load.var_w_false_nil_res_prn2_c	.expr
ibio.prim.oport	.tygvar
rune.t	.tygvar
gsdl.cgs.symbol.t	.tygvar
list.t	.tygvar
_real.entry_prefix_ty	.tygvar
_prefix.load.var	.gvar
eo	.fv	ibio.prim.oport	rune.t
v	.fv	gsdl.cgs.symbol.t
prn1	.fv	list.t	_real.entry_prefix_ty
	.app	eo	v	prn1
	.enter	_prefix.load.var

# §paragraph{Push §gs{pr0} back onto the recursion result and return it}
_prefix.load.var_w_false_nil_res_body_c	.expr
_real.entry_prefix_ty	.tygvar
list.t	.tygvar
res_ty	.tylet	list.t	_real.entry_prefix_ty
ibio.prim.unit	.gvar
list.:	.gvar
pr0	.fv	_real.entry_prefix_ty
prn2	.fv	list.t	_real.entry_prefix_ty
res	.apply	list.:	_real.entry_prefix_ty	|	pr0	prn2
	.lift
	.app	res
	.yield	ibio.prim.unit	res_ty

_prefix.load_body_body_c	.expr
ibio.prim.oport	.tygvar
rune.t	.tygvar
list.t	.tygvar
gsdl.cgs.symbol.t	.tygvar
_real.entry_prefix_ty	.tygvar
_prefix.load	.gvar
eo	.fv	ibio.prim.oport	rune.t
vs1	.fv	list.t	gsdl.cgs.symbol.t
prn1	.fv	list.t	_real.entry_prefix_ty
	.app	eo	vs1	prn1
	.enter	_prefix.load

# §section Calculate type of the prefixen and build a type environment from them

_real.entry_env_c	.expr
list.t	.tygvar
_real.entry_prefix_ty	.tygvar
gsdl.cgs.typeenv.t	.tygvar
either.t	.tygvar	# Temp
string.t	.tygvar	# Temp
ibio.from.either.prim	.gvar
_prefix.typecheck	.gvar
prefix.loaded	.fv	list.t	_real.entry_prefix_ty
e	.apply	_prefix.typecheck	|	prefix.loaded
	.app	e
	.enter	ibio.from.either.prim	gsdl.cgs.typeenv.t

_prefix.typecheck_c	.expr
list.t	.tygvar
_real.entry_prefix_ty	.tygvar
_prefix.typecheck_k	.subcode
list.t.out	.cogvar
prn	.larg	list.t	_real.entry_prefix_ty
	.force	_prefix.typecheck_k
	.coerce	list.t.out	_real.entry_prefix_ty
	.enter	prn

_prefix.typecheck_k	.forcecont
list.prim.u	.tygvar
_real.entry_prefix_ty	.tygvar
list.t	.tygvar
string.t	.tygvar
gsdl.cgs.typeenv.t	.tygvar
_prefix.typecheck_:_k	.subcode
either.t.out	.cogvar
_prefix.typecheck	.gvar
either.right	.gvar
gsdl.cgs.typeenv.empty	.gvar
prn0	.karg	list.prim.u	_real.entry_prefix_ty
	.analyze	prn0	:	nil
		.case	:
pr0		.fkarg	0	_real.entry_prefix_ty
prn1		.fkarg	1	list.t	_real.entry_prefix_ty
			.force	_prefix.typecheck_:_k
			.coerce	either.t.out	string.t	gsdl.cgs.typeenv.t
			.app	prn1
			.enter	_prefix.typecheck
		.case	nil
			.app	gsdl.cgs.typeenv.empty
			.enter	either.right	string.t	gsdl.cgs.typeenv.t

_prefix.typecheck_:_k	.forcecont
either.prim.u	.tygvar
string.t	.tygvar
gsdl.cgs.typeenv.t	.tygvar
gsac.prefix.t	.tygvar
either.t	.tygvar	# Temp
_prefix.typecheck_:_right_k	.subcode
either.t.out	.cogvar
gsac.prefix.typecheck	.gvar
eenv0	.karg	either.prim.u	string.t	gsdl.cgs.typeenv.t
	.analyze	eenv0	left	right
		.case	left
err		.fkarg	0	string.t
			.undef	either.t	string.t	gsdl.cgs.typeenv.t
		.case	right
env		.fkarg	0	gsdl.cgs.typeenv.t
pr0.prefix			.undefined	gsac.prefix.t
			.force	_prefix.typecheck_:_right_k
			.coerce	either.t.out	string.t	gsdl.cgs.typeenv.t
			.app	env	pr0.prefix
			.enter	gsac.prefix.typecheck	# > :: gsdl.cgs.typeenv.t → gsac.prefix.t → either.t	string.t	gsdl.cgs.typeenv.t

_prefix.typecheck_:_right_k	.forcecont
gsdl.cgs.typeenv.t	.tygvar
either.prim.u	.tygvar
string.t	.tygvar
either.t	.tygvar	# Temp
gsdl.cgs.typeenv.overlay	.gvar
either.right	.gvar
env	.fv	gsdl.cgs.typeenv.t
eenv0	.karg	either.prim.u	string.t	gsdl.cgs.typeenv.t
	.analyze	eenv0	left	right
		.case	left
err		.fkarg	0	string.t
			.undef	either.t	string.t	gsdl.cgs.typeenv.t
		.case	right
env1		.fkarg	0	gsdl.cgs.typeenv.t
env2			.apply	gsdl.cgs.typeenv.overlay	|	env1	env
			.app	env2
			.enter	either.right	string.t	gsdl.cgs.typeenv.t

# §section Process §gs{sccs} to get (symtable, output)

# NB: We will need to read in §gs{.gsac} files --- those that we need --- §emph{before} this step;
# that can be deferred until a later stage.

_real.entry_output_c	.expr
gsdl.cgs.typeenv.t	.tygvar
gsdl.cgs.file.t	.tygvar
list.t	.tygvar	# Temp
_real.entry_output_k	.subcode
list.t.out	.cogvar
cut	.fv	list.t	gsdl.cgs.file.t
env	.fv	gsdl.cgs.typeenv.t
	.force	_real.entry_output_k
	.coerce	list.t.out	gsdl.cgs.file.t
	.enter	cut

_real.entry_output_k	.forcecont
gsdl.cgs.typeenv.t	.tygvar
list.prim.u	.tygvar
gsdl.cgs.file.t	.tygvar
list.t	.tygvar
ibio.prim.t	.tygvar	# Temp
gsdl.ags.file.t	.tygvar	# Temp
_real.entry_output_k1	.subcode
list.t.out	.cogvar
env	.fv	gsdl.cgs.typeenv.t
cut0	.karg	list.prim.u	gsdl.cgs.file.t
	.analyze	cut0	:	nil
		.case	:
cut0.0		.fkarg	0	gsdl.cgs.file.t
cut1		.fkarg	1	list.t	gsdl.cgs.file.t
			.force	_real.entry_output_k1
			.coerce	list.t.out	gsdl.cgs.file.t
			.enter	cut1
		.case	nil
			.undef	ibio.prim.t	gsdl.ags.file.t

_real.entry_output_k1	.forcecont
gsdl.cgs.typeenv.t	.tygvar
gsdl.cgs.file.t	.tygvar
list.prim.u	.tygvar
list.t	.tygvar
gsdl.ags.file.t	.tygvar	# Temp
_real.entry_output_k1_nil_k	.subcode
ibio.prim.unit	.gvar
gsdl.cgs.file.t.out	.cogvar
env	.fv	gsdl.cgs.typeenv.t
cut0.0	.fv	gsdl.cgs.file.t
cut1.0	.karg	list.prim.u	gsdl.cgs.file.t
	.analyze	cut1.0	:	nil
		.case	:
cut1.0.0		.fkarg	0	gsdl.cgs.file.t
cut2		.fkarg	1	list.t	gsdl.cgs.file.t
res			.undefined	gsdl.ags.file.t
			.lift
			.app	res
			.yield	ibio.prim.unit	gsdl.ags.file.t
		.case	nil
			.force	_real.entry_output_k1_nil_k
			.coerce	gsdl.cgs.file.t.out
			.enter	cut0.0

_real.entry_output_k1_nil_k	.forcecont
gsdl.cgs.typeenv.t	.tygvar
gsdl.cgs.file.prim.u	.tygvar
gsdl.cgs.document.t	.tygvar
string.t	.tygvar
gsdl.ags.file.t	.tygvar
either.t	.tygvar	# Temp
_real.entry_output_k1_nil_doc_k	.subcode
either.t.out	.cogvar
gsac.document.compile	.gvar
env	.fv	gsdl.cgs.typeenv.t
f0	.karg	gsdl.cgs.file.prim.u
	.analyze	f0	document
		.case	document
doc		.fkarg	0	gsdl.cgs.document.t
			.force	_real.entry_output_k1_nil_doc_k
			.coerce	either.t.out	string.t	gsdl.ags.file.t
			.app	env	doc
			.enter	gsac.document.compile
	# > :: ibio.prim.t	gsdl.ags.file.t

_real.entry_output_k1_nil_doc_k	.forcecont
either.prim.u	.tygvar
string.t	.tygvar
gsdl.ags.file.t	.tygvar
ibio.prim.t	.tygvar	# Temp
ibio.prim.unit	.gvar
res0	.karg	either.prim.u	string.t	gsdl.ags.file.t
	.analyze	res0	left	right
		.case	left
err		.fkarg	0	string.t
			.undef	ibio.prim.t	gsdl.ags.file.t
		.case	right
res		.fkarg	0	gsdl.ags.file.t
			.lift
			.app	res
			.yield	ibio.prim.unit	gsdl.ags.file.t

# §section Write out §gs{output} on stdout

_real.entry_send.output_c	.expr
ibio.prim.oport	.tygvar
rune.t	.tygvar
gsdl.ags.file.t	.tygvar
ibio.prim.write	.gvar
gsdl.ags.file.print	.gvar
o	.fv	ibio.prim.oport	rune.t
output	.fv	gsdl.ags.file.t
out.s	.apply	gsdl.ags.file.print	|	output
	.lift
	.app	o	out.s
	.yield	ibio.prim.write	rune.t

	.type

_epbodytype	.tyexpr
ibio.prim.m	.tygvar
record.empty	.tygvar
	.tylift
	.tyref	ibio.prim.m	record.empty

_args.parsed.t	.tyexpr
_args.parsed.u	.tygvar
	.tylift
	.tyref	_args.parsed.u

_args.parsed.u	.tyexpr
list.t	.tygvar
ibio.file.name.t	.tygvar
0.ty	.tylet	list.t	ibio.file.name.t
1.ty	.tylet	list.t	ibio.file.name.t
	.typroduct	0	0.ty	1	1.ty

_args.parse_ty	.tyexpr
list.t	.tygvar
string.t	.tygvar
either.t	.tygvar
_args.parsed.t	.tygvar
	.tylift
	.tyfun	list.t	string.t
	.tyref	either.t	string.t	_args.parsed.t

_real.entry_prefix_ty	.tyexpr
_real.entry_prefix_u	.tygvar
	.tylift
	.tyref	_real.entry_prefix_u

_real.entry_prefix_u	.tyexpr
ordered.set.t	.tygvar
gsdl.cgs.symbol.t	.tygvar
ibio.file.name.t	.tygvar
bool.t	.tygvar
bvs_ty	.tylet	ordered.set.t	gsdl.cgs.symbol.t
files.loaded_ty	.tylet	ordered.set.t	ibio.file.name.t
	.typroduct	bvs	bvs_ty	filename	ibio.file.name.t	files.loaded	files.loaded_ty	isdir	bool.t	# 〈 name :: file.name.t; isdir :: bool.t; bvars :: set.t symbol.t; loaded :: set.t file.name.t; prefix :: prefix.t; 〉

_prefix.init_ty	.tyexpr
list.t	.tygvar
_real.entry_prefix_ty	.tygvar
ibio.file.name.t	.tygvar
ibio.prim.t	.tygvar
list.prefix.ty	.tylet	list.t	_real.entry_prefix_ty
	.tylift
	.tyfun	list.t	_real.entry_prefix_ty
	.tylift
	.tyfun	list.t	ibio.file.name.t
	.tyref	ibio.prim.t	list.prefix.ty

_prefix.load_ty	.tyexpr
ibio.prim.oport	.tygvar
rune.t	.tygvar
list.t	.tygvar
gsdl.cgs.symbol.t	.tygvar
_real.entry_prefix_ty	.tygvar
ibio.prim.t	.tygvar
list.prefix.ty	.tylet	list.t	_real.entry_prefix_ty
	.tylift
	.tyfun	ibio.prim.oport	rune.t
	.tylift
	.tyfun	list.t	gsdl.cgs.symbol.t
	.tylift
	.tyfun	list.t	_real.entry_prefix_ty
	.tyref	ibio.prim.t	list.prefix.ty

_prefix.load.var_ty	.tyexpr
ibio.prim.oport	.tygvar
rune.t	.tygvar
gsdl.cgs.symbol.t	.tygvar
list.t	.tygvar
_real.entry_prefix_ty	.tygvar
ibio.prim.t	.tygvar
list.prefix.ty	.tylet	list.t	_real.entry_prefix_ty
	.tylift
	.tyfun	ibio.prim.oport	rune.t
	.tylift
	.tyfun	gsdl.cgs.symbol.t
	.tylift
	.tyfun	list.t	_real.entry_prefix_ty
	.tyref	ibio.prim.t	list.prefix.ty

_prefix.load.var_w_ty	.tyexpr
ibio.prim.oport	.tygvar
rune.t	.tygvar
gsdl.cgs.symbol.t	.tygvar
list.t	.tygvar
gsdl.cgs.syntax.var.component.t	.tygvar
_prefix.load.var_w_file_ty	.tygvar
ibio.prim.t	.tygvar
_real.entry_prefix_ty	.tygvar
list.prefix.ty	.tylet	list.t	_real.entry_prefix_ty
	.tylift
	.tyfun	ibio.prim.oport	rune.t
	.tylift
	.tyfun	gsdl.cgs.symbol.t
	.tylift
	.tyfun	list.t	_prefix.load.var_w_file_ty
	.tylift
	.tyfun	_real.entry_prefix_ty
	.tylift
	.tyfun	list.t	_real.entry_prefix_ty
	.tyref	ibio.prim.t	list.prefix.ty

_prefix.load.var_w_file_ty	.tyexpr
_prefix.load.var_w_file_u	.tygvar
	.tylift
	.tyref	_prefix.load.var_w_file_u

_prefix.load.var_w_file_u	.tyexpr
ibio.file.name.t	.tygvar
bool.t	.tygvar
list.t	.tygvar
gsdl.cgs.syntax.var.component.t	.tygvar
list.component.ty	.tylet	list.t	gsdl.cgs.syntax.var.component.t
	.typroduct	filename	ibio.file.name.t	isdir	bool.t	relv	list.component.ty

_prefix.load.var_w_false_:_true_res_body_files0.f_true_w_ty	.tyexpr
list.t	.tygvar
gsdl.cgs.syntax.var.component.t	.tygvar
string.t	.tygvar
maybe.t	.tygvar
_prefix.load.var_w_file_ty	.tygvar
	.tylift
	.tyfun	list.t	gsdl.cgs.syntax.var.component.t
	.tylift
	.tyfun	list.t	string.t
	.tyref	maybe.t	_prefix.load.var_w_file_ty

_prefix.typecheck_ty	.tyexpr
list.t	.tygvar
_real.entry_prefix_ty	.tygvar
either.t	.tygvar
string.t	.tygvar
gsdl.cgs.typeenv.t	.tygvar
	.tylift
	.tyfun	list.t	_real.entry_prefix_ty
	.tyref	either.t	string.t	gsdl.cgs.typeenv.t

	.coercion

_ep.in	.tycoercion
ibio.m	.tygvar
rune.t	.tygvar
record.empty	.tygvar
	.tydefinition ibio.m	rune.t	rune.t	record.empty
