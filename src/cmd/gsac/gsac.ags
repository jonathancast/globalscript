	.document

	.data

	.cast	_ep.in	_real.entry
_real.entry	.closure	_real.entry_c

_args.parse	.closure	_args.parse_c	_args.parse_ty
_args.parsed.empty	.closure	_args.parsed.empty_c	_args.parsed.t
_flag.l	.string	-l

	.code

_real.entry_c	.eprog	ibio.prim	ibio
ibio.prim.iport	.tygvar
ibio.prim.oport	.tygvar
rune.t	.tygvar
_real.entry_args_c	.subcode
_real.entry_parsed.args_c	.subcode
_real.entry_read.arguments_c	.subcode
_real.entry_sccs_c	.subcode
_real.entry_output_c	.subcode
_real.entry_send.output_c	.subcode
i	.larg	ibio.prim.iport	rune.t
o	.larg	ibio.prim.oport	rune.t
eo	.larg	ibio.prim.oport	rune.t
args	.bind	_real.entry_args_c
parsed.args	.bind	_real.entry_parsed.args_c
read.arguments	.bind	_real.entry_read.arguments_c
sccs	.bind	_real.entry_sccs_c
output	.bind	_real.entry_output_c
	.body	_real.entry_send.output_c

_real.entry_args_c	.expr
ibio.prim.env.args.get	.gvar
	.yield	ibio.prim.env.args.get

# §section Split §gs{as} into (prefix arguments, component under test)

_real.entry_parsed.args_c	.expr
list.t	.tygvar
string.t	.tygvar
_args.parsed.t	.tygvar
_real.entry_parsed.args_pure_c	.subcode
ibio.from.either.prim	.gvar
args	.fv	list.t	string.t
pa	.alloc	_real.entry_parsed.args_pure_c
	.app	pa
	.enter	ibio.from.either.prim	_args.parsed.t

_real.entry_parsed.args_pure_c	.expr
list.t	.tygvar
string.t	.tygvar
_args.parse	.gvar
args	.fv	list.t	string.t
	.app	args
	.enter	_args.parse

# §section §gs{_args.parse}

_args.parse_c	.expr
list.t	.tygvar
string.t	.tygvar
_args.parse_k0	.subcode
list.t.out	.cogvar
as	.larg	list.t	string.t
	.force	_args.parse_k0
	.coerce	list.t.out	string.t
	.enter	as

_args.parse_k0	.forcecont
list.prim.u	.tygvar
string.t	.tygvar
list.t	.tygvar
rune.t	.tygvar
either.t	.tygvar
_args.parsed.t	.tygvar
_args.parse_k1	.subcode
bool.t.out	.cogvar
list.≡	.gvar
rune.≡	.gvar
_flag.l	.gvar
either.unit	.gvar
_args.parsed.empty	.gvar
as0	.karg	list.prim.u	string.t
	.analyze	as0	:	nil
		.case	:
a0		.fkarg	0	string.t
as1		.fkarg	1	list.t	string.t
			.force	_args.parse_k1
			.coerce	bool.t.out
			.app	rune.≡	a0	_flag.l
			.enter	list.≡	rune.t
		.case	nil
			.app	_args.parsed.empty
			.enter	either.unit	string.t	_args.parsed.t

_args.parse_k1	.forcecont
list.t	.tygvar
string.t	.tygvar
bool.prim.u	.tygvar
_args.parsed.t	.tygvar
_args.parse_file_pre_c	.subcode
_args.parse_file_ap0_c	.subcode
_args.parse_l.option_k	.subcode
list.t.out	.cogvar
either.map	.gvar
a0	.fv	string.t
as1	.fv	list.t	string.t
is.l0	.karg	bool.prim.u
	.analyze	is.l0	false	true
		.case	false
pre			.alloc	_args.parse_file_pre_c
ap0			.alloc	_args.parse_file_ap0_c
			.app	pre	ap0
			.enter	either.map	string.t	_args.parsed.t	_args.parsed.t
		.case	true
			.force	_args.parse_l.option_k
			.coerce	list.t.out	string.t
			.enter	as1

_args.parse_file_pre_c	.expr
string.t	.tygvar
_args.parsed.t	.tygvar
_args.parse_file_pre_k	.subcode
a0	.fv	string.t
ap0	.larg	_args.parsed.t
	.force	_args.parse_file_pre_k
	.enter	ap0

_args.parse_file_pre_k	.forcecont
string.t	.tygvar
_args.parsed.u	.tygvar
ibio.file.name.t	.tygvar
list.t	.tygvar	# Temp
list.:	.gvar
ibio.file.name.in	.gvar
a0	.fv	string.t
ap00	.karg	_args.parsed.u
ps	.field	0	ap00
cut1	.field	1	ap00
cut0	.apply	ibio.file.name.in	|	a0
cut	.apply	list.:	ibio.file.name.t	|	cut0	cut1
ap1	.record	0	ps	1	cut
	.lift
	.yield	ap1

_args.parse_file_ap0_c	.expr
list.t	.tygvar
string.t	.tygvar
_args.parse	.gvar
as1	.fv	list.t	string.t
	.app	as1
	.enter	_args.parse

# paragraph{§gs{a0} is §sh{-l} flag}
_args.parse_l.option_k	.forcecont
list.prim.u	.tygvar
string.t	.tygvar
list.t	.tygvar
either.t	.tygvar
_args.parsed.t	.tygvar
_args.parse_l.option_pre_c	.subcode
_args.parse_l.option_ap0_c	.subcode
either.map	.gvar
as1.0	.karg	list.prim.u	string.t
	.analyze	as1.0	:	nil
		.case	:
a1		.fkarg	0	string.t
as2		.fkarg	1	list.t	string.t
pre			.alloc	_args.parse_l.option_pre_c
ap0			.alloc	_args.parse_l.option_ap0_c
			.app	pre	ap0
			.enter	either.map	string.t	_args.parsed.t	_args.parsed.t
		.case	nil
			.undef	either.t	string.t	_args.parsed.t

# §paragraph{Prepend §gs{a1} to the list}
_args.parse_l.option_pre_c	.expr
string.t	.tygvar
_args.parsed.t	.tygvar
_args.parse_l.option_pre_k	.subcode
a1	.fv	string.t
ap0	.larg	_args.parsed.t
	.force	_args.parse_l.option_pre_k
	.enter	ap0

_args.parse_l.option_pre_k	.forcecont
string.t	.tygvar
_args.parsed.u	.tygvar
_args.parsed.t	.tygvar
_args.parse_l.option_pre_ps1_c	.subcode
a1	.fv	string.t
ap00	.karg	_args.parsed.u
ps	.field	0	ap00
cut	.field	1	ap00
ps1	.alloc	_args.parse_l.option_pre_ps1_c
ap1	.record	0	ps1	1	cut
	.lift
	.yield	ap1

_args.parse_l.option_pre_ps1_c	.expr
string.t	.tygvar
list.t	.tygvar
ibio.file.name.t	.tygvar
_args.parse_l.option_pre_ps1_fn_c	.subcode
list.:	.gvar
a1	.fv	string.t
ps	.fv	list.t	ibio.file.name.t
fn	.alloc	_args.parse_l.option_pre_ps1_fn_c
	.app	fn	ps
	.enter	list.:	ibio.file.name.t

_args.parse_l.option_pre_ps1_fn_c	.expr
string.t	.tygvar
ibio.file.name.in	.gvar
a1	.fv	string.t
	.app	a1
	.enter	ibio.file.name.in

# §paragraph{Recursive call on §gs{as2}}
_args.parse_l.option_ap0_c	.expr
list.t	.tygvar
string.t	.tygvar
_args.parse	.gvar
as2	.fv	list.t	string.t
	.app	as2
	.enter	_args.parse

_args.parsed.empty_c	.expr
_args.parsed.empty_ps_c	.subcode
_args.parsed.empty_cut_c	.subcode
ps	.alloc	_args.parsed.empty_ps_c
cut	.alloc	_args.parsed.empty_cut_c
r	.record	0	ps	1	cut
	.lift
	.yield	r

_args.parsed.empty_ps_c	.expr
ibio.file.name.t	.tygvar
list.nil	.gvar
	.enter	list.nil	ibio.file.name.t

_args.parsed.empty_cut_c	.expr
ibio.file.name.t	.tygvar
list.nil	.gvar
	.enter	list.nil	ibio.file.name.t

# §section Process §gs{parsed.args} into (List of (lists of (files, some of which have been parsed)), list of parsed files)

# ‘CUT’ = ‘component under translation’; ‘component’ = ‘strongly-connected component of the dependency graph’

_real.entry_read.arguments_c	.eprog	ibio.prim	ibio
ibio.prim.oport	.tygvar
rune.t	.tygvar
_args.parsed.t	.tygvar
_real.entry_read.arguments_prefix.files_c	.subcode
_real.entry_read.arguments_prefix_c	.subcode
_real.entry_read.arguments_cut.files_c	.subcode
_real.entry_read.arguments_cut_c	.subcode
_real.entry_read.arguments_body_c	.subcode
eo	.fv	ibio.prim.oport	rune.t
parsed.args	.fv	_args.parsed.t
prefix.files	.alloc	_real.entry_read.arguments_prefix.files_c
prefix	.bind	_real.entry_read.arguments_prefix_c
cut.files	.alloc	_real.entry_read.arguments_cut.files_c
cut	.bind	_real.entry_read.arguments_cut_c
	.body	_real.entry_read.arguments_body_c

_real.entry_read.arguments_prefix.files_c	.expr
_args.parsed.t	.tygvar
_real.entry_read.arguments_prefix.files_k	.subcode
parsed.args	.fv	_args.parsed.t
	.force	_real.entry_read.arguments_prefix.files_k
	.enter	parsed.args

_real.entry_read.arguments_prefix.files_k	.forcecont
_args.parsed.u	.tygvar
list.t	.tygvar
ibio.file.name.t	.tygvar
pa0	.karg	_args.parsed.u
pas	.field	0	pa0
	.enter	pas

_real.entry_read.arguments_prefix_c	.expr
ibio.prim.t	.tygvar
list.t	.tygvar
gsac.input.prefix.file.t	.tygvar
ibio.file.name.t	.tygvar
res.elem.ty	.tylet	list.t	gsac.input.prefix.file.t
res.ty	.tylet	list.t	res.elem.ty
ibio.mapM.prim	.gvar
gsac.input.prefix.load	.gvar
prefix.files	.fv	list.t	ibio.file.name.t
	.app	gsac.input.prefix.load	prefix.files
	.enter	ibio.mapM.prim	ibio.file.name.t	res.elem.ty

_real.entry_read.arguments_cut.files_c	.expr
_args.parsed.t	.tygvar
parsed.args	.fv	_args.parsed.t
fs	.lfield	1	parsed.args
	.enter	fs

_real.entry_read.arguments_cut_c	.expr
ibio.prim.oport	.tygvar
rune.t	.tygvar
list.t	.tygvar
ibio.file.name.t	.tygvar
gsdl.cgs.file.t	.tygvar
ibio.mapM.prim	.gvar
gsdl.cgs.file.read	.gvar
eo	.fv	ibio.prim.oport	rune.t
cut.files	.fv	list.t	ibio.file.name.t
f	.apply	gsdl.cgs.file.read	|	eo
	.app	f	cut.files
	.enter	ibio.mapM.prim	ibio.file.name.t	gsdl.cgs.file.t

_real.entry_read.arguments_body_c	.expr
list.t	.tygvar
gsdl.cgs.file.t	.tygvar
_real.entry_read.arguments_ty	.tygvar
ibio.prim.unit	.gvar
cut	.fv	list.t	gsdl.cgs.file.t
res	.lrecord	cut	cut
	.lift
	.app	res
	.yield	ibio.prim.unit	_real.entry_read.arguments_ty

# §section Split §gs{read.arguments} into strongly-connected components

# NB: §sh{.ags} files have been read in, and can be split here; §sh{.gsac} files have not, and should be treated as single nodes.
# §sh{.gsac} files have type signatures/kind signatures on all symbols, and so cannot depend on anything

_real.entry_sccs_c	.expr
_real.entry_read.arguments_ty	.tygvar
_real.entry_sccs_k	.subcode
read.arguments	.fv	_real.entry_read.arguments_ty
	.force	_real.entry_sccs_k
	.enter	read.arguments

_real.entry_sccs_k	.forcecont
_real.entry_read.arguments_u	.tygvar
_real.entry_sccs_ty	.tygvar	# Temp
ibio.prim.unit	.gvar
as0	.karg	_real.entry_read.arguments_u
res	.undefined	_real.entry_sccs_ty
	.lift
	.app	res
	.yield	ibio.prim.unit	_real.entry_sccs_ty

# §section Process §gs{sccs} to get (symtable, output)

# NB: We will need to read in §gs{.gsac} files --- those that we need --- §emph{before} this step;
# that can be deferred until a later stage.

_real.entry_output_c	.expr
_real.entry_read.arguments_ty	.tygvar
gsdl.cgs.file.t	.tygvar
_real.entry_output_k	.subcode
list.t.out	.cogvar
read.arguments	.fv	_real.entry_read.arguments_ty
cut	.lfield	cut	read.arguments
	.force	_real.entry_output_k
	.coerce	list.t.out	gsdl.cgs.file.t
	.enter	cut

_real.entry_output_k	.forcecont
list.prim.u	.tygvar
gsdl.cgs.file.t	.tygvar
list.t	.tygvar
ibio.prim.t	.tygvar	# Temp
gsdl.ags.file.t	.tygvar	# Temp
_real.entry_output_k1	.subcode
list.t.out	.cogvar
cut0	.karg	list.prim.u	gsdl.cgs.file.t
	.analyze	cut0	:	nil
		.case	:
cut0.0		.fkarg	0	gsdl.cgs.file.t
cut1		.fkarg	1	list.t	gsdl.cgs.file.t
			.force	_real.entry_output_k1
			.coerce	list.t.out	gsdl.cgs.file.t
			.enter	cut1
		.case	nil
			.undef	ibio.prim.t	gsdl.ags.file.t

_real.entry_output_k1	.forcecont
gsdl.cgs.file.t	.tygvar
list.prim.u	.tygvar
list.t	.tygvar
gsdl.ags.file.t	.tygvar	# Temp
_real.entry_output_k1_nil_k	.subcode
ibio.prim.unit	.gvar
gsdl.cgs.file.t.out	.cogvar
cut0.0	.fv	gsdl.cgs.file.t
cut1.0	.karg	list.prim.u	gsdl.cgs.file.t
	.analyze	cut1.0	:	nil
		.case	:
cut1.0.0		.fkarg	0	gsdl.cgs.file.t
cut2		.fkarg	1	list.t	gsdl.cgs.file.t
res			.undefined	gsdl.ags.file.t
			.lift
			.app	res
			.yield	ibio.prim.unit	gsdl.ags.file.t
		.case	nil
			.force	_real.entry_output_k1_nil_k
			.coerce	gsdl.cgs.file.t.out
			.enter	cut0.0

_real.entry_output_k1_nil_k	.forcecont
gsdl.cgs.file.prim.u	.tygvar
gsdl.cgs.document.t	.tygvar
string.t	.tygvar
gsdl.ags.file.t	.tygvar
either.t	.tygvar	# Temp
_real.entry_output_k1_nil_doc_k	.subcode
either.t.out	.cogvar
gsac.document.compile	.gvar
f0	.karg	gsdl.cgs.file.prim.u
	.analyze	f0	document
		.case	document
doc		.fkarg	0	gsdl.cgs.document.t
			.force	_real.entry_output_k1_nil_doc_k
			.coerce	either.t.out	string.t	gsdl.ags.file.t
			.app	doc
			.enter	gsac.document.compile
	# > :: ibio.prim.t	gsdl.ags.file.t

_real.entry_output_k1_nil_doc_k	.forcecont
either.prim.u	.tygvar
string.t	.tygvar
gsdl.ags.file.t	.tygvar
ibio.prim.t	.tygvar	# Temp
ibio.prim.unit	.gvar
res0	.karg	either.prim.u	string.t	gsdl.ags.file.t
	.analyze	res0	left	right
		.case	left
err		.fkarg	0	string.t
			.undef	ibio.prim.t	gsdl.ags.file.t
		.case	right
res		.fkarg	0	gsdl.ags.file.t
			.lift
			.app	res
			.yield	ibio.prim.unit	gsdl.ags.file.t

# §section Write out §gs{output} on stdout

_real.entry_send.output_c	.expr
ibio.prim.oport	.tygvar
rune.t	.tygvar
gsdl.ags.file.t	.tygvar
ibio.prim.write	.gvar
gsdl.ags.file.print	.gvar
o	.fv	ibio.prim.oport	rune.t
output	.fv	gsdl.ags.file.t
out.s	.apply	gsdl.ags.file.print	|	output
	.lift
	.app	o	out.s
	.yield	ibio.prim.write	rune.t

	.type

_epbodytype	.tyexpr
ibio.prim.m	.tygvar
record.empty	.tygvar
	.tylift
	.tyref	ibio.prim.m	record.empty

_args.parsed.t	.tyexpr
_args.parsed.u	.tygvar
	.tylift
	.tyref	_args.parsed.u

_args.parsed.u	.tyexpr
list.t	.tygvar
ibio.file.name.t	.tygvar
0.ty	.tylet	list.t	ibio.file.name.t
1.ty	.tylet	list.t	ibio.file.name.t
	.typroduct	0	0.ty	1	1.ty

_real.entry_read.arguments_ty	.tyexpr
_real.entry_read.arguments_u	.tygvar
	.tylift
	.tyref	_real.entry_read.arguments_u

_real.entry_read.arguments_u	.tyexpr
list.t	.tygvar
gsdl.cgs.file.t	.tygvar
cut_ty	.tylet	list.t	gsdl.cgs.file.t
	.typroduct	cut	cut_ty

_real.entry_sccs_ty	.tyexpr
list.t	.tygvar
_real.entry_sccs_scc_ty	.tygvar
	.tyref	list.t	_real.entry_sccs_scc_ty

_real.entry_sccs_scc_ty	.tyexpr
graph.scc.t	.tygvar
gsac.input.sorted.node.t	.tygvar
	.tyref	graph.scc.t	gsac.input.sorted.node.t

_args.parse_ty	.tyexpr
list.t	.tygvar
string.t	.tygvar
either.t	.tygvar
_args.parsed.t	.tygvar
	.tylift
	.tyfun	list.t	string.t
	.tyref	either.t	string.t	_args.parsed.t

	.coercion

_ep.in	.tycoercion
ibio.m	.tygvar
rune.t	.tygvar
record.empty	.tygvar
	.tydefinition ibio.m	rune.t	rune.t	record.empty
