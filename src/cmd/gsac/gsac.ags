	.document

	.data

	.cast	_ep.in	_real.entry
_real.entry	.closure	_real.entry_c

_args.parse	.closure	_args.parse_c	_args.parse_ty
_args.parsed.empty	.closure	_args.parsed.empty_c	_args.parsed.t
_flag.l	.string	-l

	.code

_real.entry_c	.eprog	ibio.prim	ibio
ibio.prim.oport	.tygvar
rune.t	.tygvar
_real.entry_args_c	.subcode
_real.entry_parsed.args_c	.subcode
_real.entry_read.arguments_c	.subcode
_real.entry_sccs_c	.subcode
_real.entry_output_c	.subcode
_real.entry_send.output_c	.subcode
o	.larg	ibio.prim.oport	rune.t
args	.bind	_real.entry_args_c
parsed.args	.bind	_real.entry_parsed.args_c	|	args
read.arguments	.bind	_real.entry_read.arguments_c	|	parsed.args
sccs	.bind	_real.entry_sccs_c
output	.bind	_real.entry_output_c
	.body	_real.entry_send.output_c

_real.entry_args_c	.expr
ibio.prim.env.args.get	.gvar
	.yield	ibio.prim.env.args.get

# §section Split §gs{as} into (prefix arguments, component under test)

_real.entry_parsed.args_c	.expr
list.t	.tygvar
_string.ty	.tygvar
_args.parsed.t	.tygvar
_real.entry_parsed.args_pure_c	.subcode
ibio.from.either.prim	.gvar
args	.fv	list.t	_string.ty
pa	.alloc	_real.entry_parsed.args_pure_c	|	args
	.app	pa
	.enter	ibio.from.either.prim	_args.parsed.t

_real.entry_parsed.args_pure_c	.expr
list.t	.tygvar
_string.ty	.tygvar
_args.parse	.gvar
args	.fv	list.t	_string.ty
	.app	args
	.enter	_args.parse

# §section §gs{_args.parse}

_args.parse_c	.expr
list.t	.tygvar
_string.ty	.tygvar
_args.parse_k0	.subcode
list.t.out	.cogvar
as	.larg	list.t	_string.ty
	.force	_args.parse_k0
	.coerce	list.t.out	_string.ty
	.enter	as

_args.parse_k0	.forcecont
list.prim.u	.tygvar
_string.ty	.tygvar
list.t	.tygvar
rune.t	.tygvar
either.t	.tygvar
_args.parsed.t	.tygvar
_args.parse_k1	.subcode
bool.t.out	.cogvar
list.≡	.gvar
rune.≡	.gvar
_flag.l	.gvar
either.unit	.gvar
_args.parsed.empty	.gvar
as0	.karg	list.prim.u	_string.ty
	.analyze	as0	:	nil
		.case	:
a0		.fkarg	0	_string.ty
as1		.fkarg	1	list.t	_string.ty
			.force	_args.parse_k1	|	as1
			.coerce	bool.t.out
			.app	rune.≡	a0	_flag.l
			.enter	list.≡	rune.t
		.case	nil
			.app	_args.parsed.empty
			.enter	either.unit	_string.ty	_args.parsed.t

_args.parse_k1	.forcecont
list.t	.tygvar
_string.ty	.tygvar
bool.prim.u	.tygvar
_args.parsed.t	.tygvar
_args.parse_file_pre_c	.subcode
_args.parse_file_ap0_c	.subcode
_args.parse_l.option_k	.subcode
list.t.out	.cogvar
either.map	.gvar
as1	.fv	list.t	_string.ty
is.l0	.karg	bool.prim.u
	.analyze	is.l0	false	true
		.case	false
pre			.alloc	_args.parse_file_pre_c
ap0			.alloc	_args.parse_file_ap0_c	|	as1
			.app	pre	ap0
			.enter	either.map	_string.ty	_args.parsed.t	_args.parsed.t
		.case	true
			.force	_args.parse_l.option_k
			.coerce	list.t.out	_string.ty
			.enter	as1

_args.parse_file_pre_c	.expr
_args.parsed.t	.tygvar
_args.parse_file_pre_k	.subcode
ap0	.larg	_args.parsed.t
	.force	_args.parse_file_pre_k
	.enter	ap0

_args.parse_file_pre_k	.forcecont
_args.parsed.u	.tygvar
_args.parsed.t	.tygvar
_args.parse_file_pre_cut1_c	.subcode
ap00	.karg	_args.parsed.u
ps	.field	0	ap00
cut	.field	1	ap00
cut1	.alloc	_args.parse_file_pre_cut1_c
ap1	.record	0	ps	1	cut1
	.lift
	.yield	ap1

_args.parse_file_pre_cut1_c	.expr
list.t	.tygvar
ibio.file.name.t	.tygvar
	.undef	list.t	ibio.file.name.t

_args.parse_file_ap0_c	.expr
list.t	.tygvar
_string.ty	.tygvar
_args.parse	.gvar
as1	.fv	list.t	_string.ty
	.app	as1
	.enter	_args.parse

# paragraph{§gs{a0} is §sh{-l} flag}
_args.parse_l.option_k	.forcecont
list.prim.u	.tygvar
_string.ty	.tygvar
list.t	.tygvar
either.t	.tygvar
_args.parsed.t	.tygvar
_args.parse_l.option_pre_c	.subcode
_args.parse_l.option_ap0_c	.subcode
either.map	.gvar
as1.0	.karg	list.prim.u	_string.ty
	.analyze	as1.0	:	nil
		.case	:
a1		.fkarg	0	_string.ty
as2		.fkarg	1	list.t	_string.ty
pre			.alloc	_args.parse_l.option_pre_c	|	a1
ap0			.alloc	_args.parse_l.option_ap0_c	|	as2
			.app	pre	ap0
			.enter	either.map	_string.ty	_args.parsed.t	_args.parsed.t
		.case	nil
			.undef	either.t	_string.ty	_args.parsed.t

# §paragraph{Prepend §gs{a1} to the list}
_args.parse_l.option_pre_c	.expr
_string.ty	.tygvar
_args.parsed.t	.tygvar
_args.parse_l.option_pre_k	.subcode
a1	.fv	_string.ty
ap0	.larg	_args.parsed.t
	.force	_args.parse_l.option_pre_k	|	a1
	.enter	ap0

_args.parse_l.option_pre_k	.forcecont
_string.ty	.tygvar
_args.parsed.u	.tygvar
_args.parsed.t	.tygvar
_args.parse_l.option_pre_ps1_c	.subcode
a1	.fv	_string.ty
ap00	.karg	_args.parsed.u
ps	.field	0	ap00
cut	.field	1	ap00
ps1	.alloc	_args.parse_l.option_pre_ps1_c	|	a1	ps
ap1	.record	0	ps1	1	cut
	.lift
	.yield	ap1

_args.parse_l.option_pre_ps1_c	.expr
_string.ty	.tygvar
list.t	.tygvar
ibio.file.name.t	.tygvar
_args.parse_l.option_pre_ps1_fn_c	.subcode
list.:	.gvar
a1	.fv	_string.ty
ps	.fv	list.t	ibio.file.name.t
fn	.alloc	_args.parse_l.option_pre_ps1_fn_c	|	a1
	.app	fn	ps
	.enter	list.:	ibio.file.name.t

_args.parse_l.option_pre_ps1_fn_c	.expr
_string.ty	.tygvar
ibio.file.name.read	.gvar
a1	.fv	_string.ty
	.app	a1
	.enter	ibio.file.name.read

# §paragraph{Recursive call on §gs{as2}}
_args.parse_l.option_ap0_c	.expr
list.t	.tygvar
_string.ty	.tygvar
_args.parse	.gvar
as2	.fv	list.t	_string.ty
	.app	as2
	.enter	_args.parse

_args.parsed.empty_c	.expr
_args.parsed.empty_ps_c	.subcode
_args.parsed.empty_cut_c	.subcode
ps	.alloc	_args.parsed.empty_ps_c
cut	.alloc	_args.parsed.empty_cut_c
r	.record	0	ps	1	cut
	.lift
	.yield	r

_args.parsed.empty_ps_c	.expr
ibio.file.name.t	.tygvar
list.nil	.gvar
	.enter	list.nil	ibio.file.name.t

_args.parsed.empty_cut_c	.expr
ibio.file.name.t	.tygvar
list.nil	.gvar
	.enter	list.nil	ibio.file.name.t

# §section Process §gs{parsed.args} into (List of (lists of (files, some of which have been parsed)), list of parsed files)

# ‘CUT’ = ‘component under translation’; ‘component’ = ‘strongly-connected component of the dependency graph’

_real.entry_read.arguments_c	.eprog	ibio.prim	ibio
_args.parsed.t	.tygvar
_real.entry_read.arguments_prefix.files_c	.subcode
_real.entry_read.arguments_prefix_c	.subcode
_real.entry_read.arguments_cut.files_c	.subcode
_real.entry_read.arguments_cut_c	.subcode
_real.entry_read.arguments_res_c	.subcode
_real.entry_read.arguments_body_c	.subcode
parsed.args	.fv	_args.parsed.t
prefix.files	.alloc	_real.entry_read.arguments_prefix.files_c	|	parsed.args
prefix	.bind	_real.entry_read.arguments_prefix_c	|	prefix.files
cut.files	.alloc	_real.entry_read.arguments_cut.files_c
cut	.bind	_real.entry_read.arguments_cut_c
res	.alloc	_real.entry_read.arguments_res_c
	.body	_real.entry_read.arguments_body_c

_real.entry_read.arguments_prefix.files_c	.expr
_args.parsed.t	.tygvar
_real.entry_read.arguments_prefix.files_k	.subcode
parsed.args	.fv	_args.parsed.t
	.force	_real.entry_read.arguments_prefix.files_k
	.enter	parsed.args

_real.entry_read.arguments_prefix.files_k	.forcecont
_args.parsed.u	.tygvar
list.t	.tygvar
ibio.file.name.t	.tygvar
pa0	.karg	_args.parsed.u
pas	.field	0	pa0
	.enter	pas

_real.entry_read.arguments_prefix_c	.expr
ibio.prim.t	.tygvar
list.t	.tygvar
gsac.input.prefix.file.t	.tygvar
ibio.file.name.t	.tygvar
res.elem.ty	.tylet	list.t	gsac.input.prefix.file.t
res.ty	.tylet	list.t	res.elem.ty
ibio.mapM.prim	.gvar
gsac.input.prefix.load	.gvar
prefix.files	.fv	list.t	ibio.file.name.t
	.app	gsac.input.prefix.load	prefix.files
	.enter	ibio.mapM.prim	ibio.file.name.t	res.elem.ty

_real.entry_read.arguments_cut.files_c	.expr
list.t	.tygvar
_string.ty	.tygvar
	.undef	list.t	_string.ty

_real.entry_read.arguments_cut_c	.expr
ibio.prim.t	.tygvar
list.t	.tygvar
gsdl.cgs.file.t	.tygvar
res.ty	.tylet	list.t	gsdl.cgs.file.t
	.undef	ibio.prim.t	res.ty

_real.entry_read.arguments_res_c	.expr
_real.entry_read.arguments_ty	.tygvar
	.undef	_real.entry_read.arguments_ty

_real.entry_read.arguments_body_c	.expr
ibio.prim.t	.tygvar
_real.entry_read.arguments_ty	.tygvar
	.undef	ibio.prim.t	_real.entry_read.arguments_ty

# §section Split §gs{read.arguments} into strongly-connected components

# NB: §sh{.ags} files have been read in, and can be split here; §sh{.gsac} files have not, and should be treated as single nodes.
# §sh{.gsac} files have type signatures/kind signatures on all symbols, and so cannot depend on anything

_real.entry_sccs_c	.expr
ibio.prim.t	.tygvar
_real.entry_sccs_ty	.tygvar
	.undef	ibio.prim.t	_real.entry_sccs_ty

# §section Process §gs{sccs} to get (symtable, output)

# NB: We will need to read in §gs{.gsac} files --- those that we need --- §emph{before} this step;
# that can be deferred until a later stage.

_real.entry_output_c	.expr
ibio.prim.t	.tygvar
_real.entry_output_ty	.tygvar
	.undef	ibio.prim.t	_real.entry_output_ty

# §section Write out §gs{output} on stdout

_real.entry_send.output_c	.expr
ibio.prim.t	.tygvar
_empty.record	.tygvar
	.undef	ibio.prim.t	_empty.record

	.type

_epbodytype	.tyexpr
ibio.prim.m	.tygvar
_empty.record	.tygvar
	.tylift
	.tyref	ibio.prim.m	_empty.record

_args.parsed.t	.tyexpr
_args.parsed.u	.tygvar
	.tylift
	.tyref	_args.parsed.u

_args.parsed.u	.tyexpr
list.t	.tygvar
ibio.file.name.t	.tygvar
0.ty	.tylet	list.t	ibio.file.name.t
1.ty	.tylet	list.t	ibio.file.name.t
	.typroduct	0	0.ty	1	1.ty

_real.entry_read.arguments_ty	.tyexpr
	.tylift
	.typroduct

_real.entry_sccs_ty	.tyexpr
list.t	.tygvar
_real.entry_sccs_scc_ty	.tygvar
	.tyref	list.t	_real.entry_sccs_scc_ty

_real.entry_sccs_scc_ty	.tyexpr
graph.scc.t	.tygvar
gsac.input.sorted.node.t	.tygvar
	.tyref	graph.scc.t	gsac.input.sorted.node.t

_real.entry_output_ty	.tyexpr
gsdl.ags.file.t	.tygvar
	.tyref	gsdl.ags.file.t

_args.parse_ty	.tyexpr
list.t	.tygvar
_string.ty	.tygvar
either.t	.tygvar
_args.parsed.t	.tygvar
	.tylift
	.tyfun	list.t	_string.ty
	.tyref	either.t	_string.ty	_args.parsed.t

# §cut Everything below this is obsolete

_process.args.ty	.tyexpr
gsdl.symtable.t	.tygvar
list.t	.tygvar
_string.ty	.tygvar
ibio.prim.m	.tygvar
_empty.record	.tygvar
	.tylift
	.tyfun	gsdl.symtable.t
	.tylift
	.tyfun	list.t	_string.ty
	.tylift
	.tyref	ibio.prim.m	_empty.record

_string.ty	.tyexpr
list.t	.tygvar
rune.t	.tygvar
	.tyref	list.t	rune.t

	.coercion

_ep.in	.tycoercion
ibio.m	.tygvar
rune.t	.tygvar
_empty.record	.tygvar
	.tydefinition ibio.m	rune.t	rune.t	_empty.record
